
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>题解 [APIO2009]抢掠计划 | Acfboy 的博客</title>
<meta name="description" content="纵世事物欲横流，仍心归少年志向。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://acfboy.pw/favicon.ico?v=1618916801042">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://acfboy.pw/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://acfboy.pw">
        <img class="avatar" src="https://acfboy.pw/images/avatar.png?v=1618916801042" alt="" width="32px" height="32px">
      </a>
      <a href="https://acfboy.pw">
        <h1 class="site-title">Acfboy 的博客</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">题解 [APIO2009]抢掠计划</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2021-04-15</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://acfboy.pw/suo-dian/">
                    缩点
                    
                      ，
                    
                  </a>
                
                  <a href="https://acfboy.pw/ti-jie/">
                    题解
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p>很久很久以前就想学缩点，现在因为这题终于学会了 tarjan 求强联通分量和缩点。</p>
<!-- more -->
<blockquote>
<p>给定一个有向图，每个节点都可以通过无限次，但上面的权值只能加一次，求从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始到一些点结束经过的节点权值和最大。</p>
</blockquote>
<p>如果这是一张有向无环图，那么我们肯定可以利用拓扑排序来愉快地 dp 求出这个答案。</p>
<p>但这不是一张有向无环图，缩点就是这样一种算法，可以将图中互相联通的一坨点缩成一个，使图变成 DAG，让你可以愉快地 dp。</p>
<p>现在来讲一讲 tarjan 算法。</p>
<p>这个算法的主要思想是这样的：</p>
<ol>
<li>dfs 一遍，记录 dfs 序，记作 <code>dfn</code>, 记录当前一个点可以连到最小 dfs 序，记作 <code>low</code></li>
<li>在 dfs 的过程中，先标记当前点被访问，然后将其加入栈中，更新时若连到的点没有 dfs 过，那么就 dfs 下去，然后更新 <code>low</code>, 不然只更新 <code>low</code>。</li>
<li>若 <code>dfn == low</code> 那么现在栈中的点就是一个强联通分量中的点了，把它们弹出做你想要的操作，然后都标记成未访问就可以了。</li>
</ol>
<p>这样的做法为什么是对的？</p>
<p>首先，如果连到了当前 dfs 到这点的路径上的点，那么肯定可以回去再来就是互相到达了，所以我们把点都塞进栈中，并且用 <code>low</code> 来做到识别是否连回去到更早的。</p>
<p>如果不是在 dfs 树上最早被抵达的强联通分量的点肯定 <code>dfn</code> 不和 <code>low</code> 相等，反之肯定相等，我们可以用这个性质来缩点，把其它点的性质都加入到这个最早被访问到的点上。栈就是为了记录这样的一些点。</p>
<p>然后为什么要把强联通分块中的标记成未访问呢？因为搜索树上不是向自己的祖先，而是横叉出去的边肯定不会和其它边构成环，所以把它们都取消可以成为强联通分量的资格，从候选的栈中弹出。</p>
<p>会缩点了一个就是一个拓扑排序和 dp 就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
const int N = 500005, M = N;
int vet[M], uet[M], next[M], head[N], vet2[M], next2[M], head2[N], num, num2,
	low[N], dfn[N], vis[N], c[N], scc[N], n, m, x, y, in[N], sum[N], tim, s, p;
std::queue&lt;int&gt; q;
std::stack&lt;int&gt; st;
void add(int u, int v) {
	vet[++num] = v; uet[num] = u;
	next[num] = head[u];
	head[u] = num;
}
void add2(int u, int v) {
	in[v] ++;
	vet2[++num2] = v; 
	next2[num2] = head2[u];
	head2[u] = num2;
}
void dfs(int u) {
	low[u] = dfn[u] = ++tim;
	st.push(u);
	vis[u] = 1;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(!dfn[v]) {
			dfs(v);
			low[u] = std::min(low[u], low[v]);
		}
		else if(vis[v]) low[u] = std::min(low[u], low[v]);
	}
	if(dfn[u] == low[u]) {
		int now;
		while(!st.empty()) {
			now = st.top();
			st.pop();
			scc[now] = u;
			vis[now] = 0;
			if(now == u) break;
			c[u] += c[now];
		}
	}
}
int topo() {
	q.push(scc[s]);
	sum[scc[s]] = c[scc[s]];
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for(int i = head2[u]; i; i = next2[i]) {
			int v = vet2[i];
			sum[v] = std::max(sum[v], sum[u] + c[v]);
			in[v] --;
			if(in[v] == 0) q.push(v);
		}
	}
	int ans = 0;
	for(int i = 1; i &lt;= p; i++) {
		scanf(&quot;%d&quot;, &amp;x);
		ans = std::max(ans, sum[scc[x]]);
	}
	return ans;
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		add(x, y);
	}
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;c[i]);
	scanf(&quot;%d%d&quot;, &amp;s, &amp;p);
	dfs(s);
	for(int i = 1; i &lt;= n; i++) {
		if(scc[i] == 0) continue;
		for(int j = head[i]; j; j = next[j]) 
			if(scc[vet[j]] &amp;&amp; scc[vet[j]] != scc[i]) add2(scc[i], scc[vet[j]]);
	}
	printf(&quot;%d&quot;, topo());
	return 0;
}
</code></pre>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://acfboy.pw/nt1/">
              <h3 class="post-title">
                下一篇：从头学数论一：算术基本定理
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">纵世事物欲横流，仍心归少年志向。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  <a href="https://github.com/Acfboy/acfboy.github.io/tree/master/source">博文源码</a> | <a class="rss" href="https://acfboy.pw/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
