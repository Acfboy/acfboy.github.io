<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的小站</title>
    <updated>2021-04-05T00:13:14.925Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的小站</rights>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2007]动物园]]></title>
        <id>https://acfboy.pw/apio2007dongwuyuan/</id>
        <link href="https://acfboy.pw/apio2007dongwuyuan/">
        </link>
        <updated>2021-04-04T23:29:46.000Z</updated>
        <summary type="html"><![CDATA[<p>感觉对这类在环上的状压问题很不熟悉（其实也不是环的原因），来记录一下心得。</p>
<p>其实，这不是一篇题解。</p>
]]></summary>
        <content type="html"><![CDATA[<p>感觉对这类在环上的状压问题很不熟悉（其实也不是环的原因），来记录一下心得。</p>
<p>其实，这不是一篇题解。</p>
<!-- more -->
<p>题面……难以概括。</p>
<p>这题的第一篇题解写的非常清楚，只是令我不太理解的是为什么这样的一个仅有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 为状压的状态能代表最后的结果。</p>
<p>展示一下方程。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>S</mi></mrow></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>{</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>(</mo><mi>S</mi><mi mathvariant="normal">&amp;</mi><mn>15</mn><mo>)</mo><mo>×</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mo>(</mo><mi>S</mi><mi mathvariant="normal">&amp;</mi><mn>15</mn><mo>)</mo><mo>×</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow></msub><mo>}</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f_{i,S} = \max\{f_{i-1, (S\&amp;15) \times2}, f_{(S\&amp; 15) \times 2 + 1}\} + num[i][S]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">&amp;</span><span class="mord mtight">1</span><span class="mord mtight">5</span><span class="mclose mtight">)</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">&amp;</span><span class="mord mtight">1</span><span class="mord mtight">5</span><span class="mclose mtight">)</span><span class="mbin mtight">×</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span></span></p>
<p>写出这个方程的精髓就在于，记录了当前之前的 若干个有用状态，并能从前面的状态继承答案，又能利于推出下面的状态。</p>
<p>意思是说，虽然只记录了五个东西的状态，但是记录的是到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 为止的答案，因为无后效性，使得这样子继承前面的答案并转移可以得到到当前这一位的答案，感觉很神奇的样子。</p>
<p>其实和 [NOI2001] 炮兵阵地 是同理的，只记录当前两行的状态，却能得到前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行的答案，状压说白了就是将有后效性的部分状压掉放进状态里，使剩下的没有后效性。</p>
<p>另一个使我注意的地方在于，一类问题是形成环的，即开始的状态和结尾的状态时一模一样的。如这道题和 [SCOI2009]围豆豆。</p>
<p>处理这个问题的方法在这道题中表现为将除了初始状态的其它状态都设置为负无穷，并在最外层枚举起始/终结点，这是要求起始和结束状态完全一样的情况。</p>
<p>但在豆豆那题中，起始和结尾状态时可以不一样的，也可以一样，所以直接看做不同的点按照原来的 bfs 处理就可以了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #712 (Div. 2) 游记]]></title>
        <id>https://acfboy.pw/cf1504/</id>
        <link href="https://acfboy.pw/cf1504/">
        </link>
        <updated>2021-04-04T01:21:28.000Z</updated>
        <summary type="html"><![CDATA[<p>掉分。</p>
<p>本想着破釜沉舟成 expert, 结果差点掉成 pupil。</p>
]]></summary>
        <content type="html"><![CDATA[<p>掉分。</p>
<p>本想着破釜沉舟成 expert, 结果差点掉成 pupil。</p>
<!-- more -->
<p>因为上次打得比较好，所以感觉离蓝名不远了，所以直接开了 C 题，希望能通过 CBAD 的做题顺序获得更高的分数。</p>
<p>然后 C 题就翻车了，一开始想了一个复杂而错误的解法，WA 了两发才发觉做法不对。</p>
<p>后来发现是我想难了，这其实是一道很简单的题。</p>
<h2 id="c">C</h2>
<p>看题，观察了一下样例和自己的小数据，发现了一个似乎显而易见的结论，如果原串可以被分成几个长度为偶数的，一开头的回文，那么上面类似 <code>()()</code> 的结构，下面用根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 串来做就可以了。</p>
<p>判断回文我选择了字符串哈希。</p>
<p>想到这个用的时间就比较的久，写得也比较慢，哈希最开始也写错了。然后到快一个小时才交第一发，当然，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">Wrong</mtext><mtext> </mtext><mtext mathvariant="monospace">answer</mtext><mtext> </mtext><mtext mathvariant="monospace">on</mtext><mtext> </mtext><mtext mathvariant="monospace">pretest</mtext><mtext> </mtext><mtext mathvariant="monospace">2</mtext></mrow><annotation encoding="application/x-tex">\texttt{Wrong answer on pretest 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Wrong answer on pretest 2</span></span></span></span></span>。</p>
<p>然后还抱着这个想法不肯放手，发现了一个小问题，但改完继续 WA, 代码也放一放吧，纪念。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 200005, p = 998244353;
std::vector&lt;char&gt; ans1, ans2;
char st[N];
int hashb[N], hashf[N], pow[N], T, n;
void init() {
    memset(hashb, 0, sizeof hashb);
    memset(hashf, 0, sizeof hashf);
    ans1.clear();
    ans2.clear();
}
bool check(int l, int r) {
    int mid = l + (r-l)/2;
    int hf = (hashf[mid] - hashf[l-1] + p) % p, hb = (hashb[mid+1] - hashb[r+1] + p) % p;
    int len0f = l-1, len0b = n-r;
    if(len0f &gt; len0b) hb = hb * pow[len0f - len0b] % p;
    else hf = hf * pow[len0b - len0f] % p;
    if(hf == hb) return true;
    else return false;
}
void getans(int l, int r) {
    for(int i = l; i &lt;= r; i++) ans1.push_back(((i-l) % 2 == 0) ? '(' : ')');
    for(int i = l; i &lt;= r; i++) 
        if(st[i] == '1') ans2.push_back(((i-l) % 2 == 0) ? '(' : ')');
        else ans2.push_back(((i-l) % 2 == 0) ? ')' : '(');
}
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%lld&quot;, &amp;n);
        scanf(&quot;%s&quot;, st+1);
        init();
        pow[0] = 1;
        for(int i = 1; i &lt;= n; i++) pow[i] = pow[i-1] * 2 % p;
        for(int i = n; i &gt;= 1; i--) hashb[i] = (hashb[i+1]  + (st[i] - '0' + p) % p * pow[n-i] % p) % p;
        for(int i = 1; i &lt;= n; i++) hashf[i] = (hashf[i-1]  + (st[i] - '0' + p) % p * pow[i-1] % p) % p;
        int now = 0;
        st[n+1] = '1';
        for(int i = 1; i &lt;= n; i++) 
            if((i - now) % 2 == 0 &amp;&amp; st[now+1] == '1' &amp;&amp; check(now+1, i) ) {
                getans(now+1, i);
                now = i;
            }
        if((signed)ans1.size() &lt; n) puts(&quot;NO&quot;);
        else {
            puts(&quot;YES&quot;);
            for(int i = 0; i &lt; (signed)ans1.size(); i++) printf(&quot;%c&quot;, ans1[i]);
            puts(&quot;&quot;);
            for(int i = 0; i &lt; (signed)ans2.size(); i++) printf(&quot;%c&quot;, ans2[i]);
            puts(&quot;&quot;);
        }
    }
}
</code></pre>
<p>哈希来判这样的回文倒是挺棒的想法，但是 hack 数据很显然。</p>
<pre><code class="language-plain">11110011
</code></pre>
<p>虽然仍然是可以划分，但是我们的程序并不知道正确的划分位置，而且就算正确划分了，也不能得到正确答案。</p>
<p>写了那么多的代码，当然不肯放弃，觉得可能就是个小问题，所以一直想改改解决。</p>
<p>然后发现解决不了，终于放弃。</p>
<p>接着发现有很简单的做法。</p>
<p>即中间的 <code>0</code> 的部分反转后都是可以匹配的，只需要左右有多出来的就可以了，但是左右仍然要匹配。</p>
<p>所以找左右 <code>0</code> 之前较少的 <code>1</code> 的个数，括号向中间靠拢，其它的 <code>0</code> 和 <code>1</code> 分开正常匹配就可以了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
const int N = 200005;
int T, n;
char st[N], ans1[N];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d&quot;, &amp;n);
        scanf(&quot;%s&quot;, st+1);
        int num1f = 0, num1b = 0;
        for(int i = 1; i &lt;= n; i++) {
            if(st[i] == '0') break;
            num1f ++;
        }
        for(int i = n; i &gt;= 1; i--) {
            if(st[i] == '0') break;
            num1b ++;
        }
        if(num1f == 0 || num1b == 0) {
            puts(&quot;NO&quot;);
            continue;
        }
        int k = 0, flag1 = 0, flag0 = 0;
        if(num1b != n) k = std::min(num1f, num1b);
        for(int i = 1; i &lt;= k; i++) ans1[i] = '(';
        for(int i = n; i &gt;= n-k+1; i--) ans1[i] = ')';
        for(int i = k+1; i &lt;= n-k; i++) 
            if(st[i] == '1') {
                if(flag1) ans1[i] = ')';
                else ans1[i] = '(';
                flag1 = 1^flag1;
            }
            else {
                if(flag0) ans1[i] = ')';
                else ans1[i] = '(';
                flag0 = 1^flag0;
            }
        if(flag1 || flag0) puts(&quot;NO&quot;);
        else {
            puts(&quot;YES&quot;);
            for(int i = 1; i &lt;= n; i++) printf(&quot;%c&quot;, ans1[i]);
            puts(&quot;&quot;);
            for(int i = 1; i &lt;= n; i++) 
                if(st[i] == '1') printf(&quot;%c&quot;, ans1[i]);
                else printf(&quot;%c&quot;, (ans1[i] == '(') ? ')' : '(');
            puts(&quot;&quot;);
        }
    }
}
</code></pre>
<p>A 题是道有些细节的题，也花了我一定的时间，最后没有机会做 B 了，于是惨痛掉分。</p>
<p>所以题目开始写代码之前一定要想清楚，一定要验证好正确性，不然只会浪费大量的时间。</p>
<hr>
<p>虽然陷入了一个低谷，但不可被此打倒而整天郁郁寡欢，振作起来，去完成目标，去实现梦想！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC009B] Tournament]]></title>
        <id>https://acfboy.pw/agc009b/</id>
        <link href="https://acfboy.pw/agc009b/">
        </link>
        <updated>2021-04-03T09:23:55.000Z</updated>
        <summary type="html"><![CDATA[<p>我记得 CF 也有一题是这个名字，当时做到感觉从题意到做法都很难懂，有些阴影，所以又做了这题。</p>
<p>这题代码非常短，但一看题面还是觉得一副不可做的样子，<s>所以叫这名字的没一个好东西</s>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我记得 CF 也有一题是这个名字，当时做到感觉从题意到做法都很难懂，有些阴影，所以又做了这题。</p>
<p>这题代码非常短，但一看题面还是觉得一副不可做的样子，<s>所以叫这名字的没一个好东西</s>。</p>
<!-- more -->
<blockquote>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个选手进行淘汰赛，每场比赛后输的一方就会立刻被淘汰。现在比赛已经结束，我们已知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号是最后的胜者，而第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>(</mo><mi>i</mi><mo>&gt;</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">i(i&gt;1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 号是被 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 号淘汰的。求获得胜利需要比赛最多的人最少的比赛次数。</p>
</blockquote>
<p>考虑建出题目中的那一棵树，那这棵树是什么意义呢？即父亲淘汰了它的一堆儿子。</p>
<p>由于淘汰以后和比赛无关，没有后效性，又显然有最优子结构性质，所以考虑进行树形 dp. 令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">f_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 这个点的答案，那么由于它被它父亲给淘汰，所以和父亲比试要么父亲的答案要增加一场，但如果儿子的答案更大的话，那么得看作儿子多比一场，所以只要确定一个顺序来比赛即可。</p>
<p>显然，儿子答案小的来最优。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
const int N = 100005;
int n, x, f[N];
std::vector&lt;int&gt; g[N];
bool cmp(int x, int y) {return f[x] &lt; f[y];}
void dfs(int u) {
    for(int i = 0; i &lt; g[u].size(); i++) dfs(g[u][i]);
    std::sort(g[u].begin(), g[u].end(), cmp);
    for(int i = 0; i &lt; g[u].size(); i++) f[u] = std::max(f[u], f[g[u][i]]) + 1;
}
int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 2; i &lt;= n; i++) {
        scanf(&quot;%d&quot;, &amp;x);
        g[x].push_back(i);
    }
    dfs(1);
    printf(&quot;%d&quot;, f[1]);
    return 0;
}
</code></pre>
<p>是一道好题，讲起来简单，但思路有点难以想到，也不是很好理解这个转移，不愧是 AGC.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [BalticOI 2004]Sequence 数字序列]]></title>
        <id>https://acfboy.pw/balticoi2004sequence/</id>
        <link href="https://acfboy.pw/balticoi2004sequence/">
        </link>
        <updated>2021-04-03T03:56:38.000Z</updated>
        <summary type="html"><![CDATA[<p>感觉是很有意思的一道题，巧妙运用了可并堆来动态维护中位数，还有改严格递增为非严格的 trick, 感觉都挺妙的，不是那么容易想到。</p>
]]></summary>
        <content type="html"><![CDATA[<p>感觉是很有意思的一道题，巧妙运用了可并堆来动态维护中位数，还有改严格递增为非严格的 trick, 感觉都挺妙的，不是那么容易想到。</p>
<!-- more -->
<blockquote>
<p>给出序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 求严格单调递增序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，使得  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mi>i</mi></msub><mo>−</mo><msub><mi>B</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\sum |A_i-B_i|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> 最小</p>
</blockquote>
<p>考虑以下结论:</p>
<ol>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 递增则令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B = A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 即可</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 递减则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 中所有数都相同且是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的中位数最优。</li>
</ol>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 递增了反而拉开更大距离，没用，所以每一个数都相同；然后就变成了初中数学题，显然取中位数最优。</p>
<p>可是题目要求严格，那么我们可以把每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>， 最后再补上去，这样差不会有变化而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 就可以不严格了，因为若相同，最后差还是会有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 而差不能为负，所以加上后肯定不会相同。感觉挺妙的。</p>
<p>然后我们可以把每个数都单独作为一份，取的都是它自己。合并时按照原来的原则，如果下降了就用新的中位数，上升了那直接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B = A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 就可以了。</p>
<p>怎么维护能合并的中位数呢？原来动态维护中位数用堆，我们这里可以使用可并堆，每次维护当前区间最大的几个就可以了。</p>
<p>最后计算答案并把每一块中的答案都输出就好了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define int long long
const int N = 1000005;
int n, a[N], val[N], L[N], R[N], rt[N], size[N], cnt,
    ls[N], rs[N], dis[N], ans;
int merge(int x, int y) {
    if(x == 0 || y == 0) return x+y;
    if(val[x] &lt; val[y]) std::swap(x, y);
    rs[x] = merge(rs[x], y);
    if(dis[ls[x]] &lt; dis[rs[x]]) std::swap(ls[x], rs[x]);
    dis[x] = dis[rs[x]] + 1;
    return x;
}
void pop(int x) {
    size[x] --;
    rt[x] = merge(ls[rt[x]], rs[rt[x]]);
}
signed main() {
    dis[0] = -1;
    scanf(&quot;%lld&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), a[i] -= i;
    for(int i = 1; i &lt;= n; i++) {
        size[++cnt] = 1, val[i] = a[i];
        rt[cnt] = i;
        L[cnt] = R[cnt] = i;
        while(cnt &gt; 1 &amp;&amp; val[rt[cnt-1]] &gt; val[rt[cnt]]) {
            cnt--;
            size[cnt] += size[cnt+1], R[cnt] = R[cnt+1];
            rt[cnt] = merge(rt[cnt], rt[cnt+1]);
            while(size[cnt] &gt; (R[cnt] - L[cnt])/2+1) pop(cnt);
        }
    }
    for(int i = 1; i &lt;= cnt; i++)
        for(int j = L[i]; j &lt;= R[i]; j++)
            ans += abs(a[j] - val[rt[i]]);
    printf(&quot;%lld\n&quot;, ans);
    for(int i = 1; i &lt;= cnt; i++)
        for(int j = L[i]; j &lt;= R[i]; j++) printf(&quot;%lld &quot;, val[rt[i]] + j);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2012]派遣 & [JLOI2015]城池攻占]]></title>
        <id>https://acfboy.pw/apio2012paiqian/</id>
        <link href="https://acfboy.pw/apio2012paiqian/">
        </link>
        <updated>2021-04-02T11:51:33.000Z</updated>
        <summary type="html"><![CDATA[<p>左偏树的基本运用加上一点点的树形 dp。</p>
<p>堆里也可以懒标记。</p>
]]></summary>
        <content type="html"><![CDATA[<p>左偏树的基本运用加上一点点的树形 dp。</p>
<p>堆里也可以懒标记。</p>
<!-- more -->
<h2 id="apio2012派遣">[APIO2012]派遣</h2>
<blockquote>
<p>给定一棵数，每个点有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 值和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, 选定一棵子树，在其中选一些根节点，记子树的根为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>, 求满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi>c</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\sum c \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的情况瞎 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>u</mi></msub><mo>×</mo></mrow><annotation encoding="application/x-tex">l_u \times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">×</span></span></span></span> 选中点个数 的最大值。</p>
</blockquote>
<p>我们要选的点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 肯定要尽可能的小，因为这样才能选用更多的点，于是可以利用堆。</p>
<p>但是对于每个子树重新建堆太慢了，需要快速地合并两个堆，所以介绍左偏树(可并堆)。</p>
<p>左偏树是这样的一棵树:</p>
<ol>
<li>满足堆的性质</li>
<li>任意一点左儿子到儿子不全的点的距离(简称“距离”)大于右儿子的</li>
</ol>
<p>显然对于合并两棵左偏树(根为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>)，可以这样(假设小根)：</p>
<ol>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>x</mi></msub><mo>&gt;</mo><msub><mi>v</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">v_x &gt; v_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></li>
<li>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 并到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的右儿子</li>
<li>递归求解</li>
<li>若不满足左偏性质就交换左右儿子。</li>
<li>返回新的根 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></li>
</ol>
<p>就是这样, <code>dis</code> 就是前文所说距离。</p>
<pre><code class="language-cpp">int merge(int x, int y) {
	if(x == 0 || y == 0) return x+y;
	if(c[x] &lt; c[y]) std::swap(x, y);
	rs[x] = merge(rs[x], y);
	if(dis[ls[x]] &lt; dis[rs[x]]) std::swap(ls[x], rs[x]);
	dis[x] = dis[rs[x]] + 1;
	return x;
}
</code></pre>
<p>其实这样确保树 ”左偏“ 以及在右边合并都是为了确保个堆在整个过程中尽可能平衡，避免退化成链的情况，又用了动态的儿子分配方式，方便合并，又好写，感觉完胜原来的堆啊。</p>
<p>但这题还需要记录一个堆中的元素的和，怎么办，记在堆顶上是不行的，因为这个被删掉了就完了。</p>
<p>这里采用类似树形 dp 的方式，直接用 <code>size</code> 和 <code>sum</code> 标记在一个节点上来表示以其为根当前的堆大小和元素和。</p>
<p>这题由于保证了边一定从小连到大，所以 dfs 都不需要，直接从后往前扫描一遍来建树就可以了。</p>
<p>注意我们每次直接更新了父亲，所以只选叶子节点的答案没有被算进，需要先计算。</p>
<p>代码</p>
<pre><code class="language-cpp">signed main() {
	dis[0] = -1; // 空节点
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;fa[i], &amp;c[i], &amp;l[i]);
		rt[i] = i, sum[i] = c[i], size[i] = 1;
		ans = std::max(ans, l[i]);
	}
	for(int i = n; i &gt; 1; i--) {
		rt[fa[i]] = merge(rt[fa[i]], rt[i]);
		size[fa[i]] += size[i], sum[fa[i]] += sum[i];
		while(sum[fa[i]] &gt; m) {
			sum[fa[i]] -= c[rt[fa[i]]];
			rt[fa[i]] = merge(ls[rt[fa[i]]], rs[rt[fa[i]]]);
			size[fa[i]] --;
		}
		ans = std::max(ans, l[fa[i]] * size[fa[i]]);
	}
	printf(&quot;%lld&quot;, ans);
}
</code></pre>
<h2 id="jloi2015城池攻占">[JLOI2015]城池攻占</h2>
<p>其实也是维护树上每一个点都开一个堆，然后进行合并，这里是小根堆，每次把不符合要求的就弹出。</p>
<p>但是对于攻击力的值怎么变化呢？更新所有会超时。每个堆的中数的变化方式是一样的，可如果记录下来变化方式的话，又记录在哪里呢？</p>
<p>这时就可以用到我们的老朋友，懒惰标记。对于堆，同样也是只要用到的进行处理就可以了啊，为什么每次要更新所有？只要在根节点打个懒标记，要删了时，直接把懒标记下传再合并两个就可以了。</p>
<p>注意，合并的时候也先给把懒标记下传， 因为合来合去的要依靠当前的根，而且树形会发生变化，所以处理之前得先把标记给儿子。</p>
<p>同时乘和加相同的数，不会改变元素间大小关系，所以这样子是对的。</p>
<p>带懒标记的代码。</p>
<pre><code class="language-cpp">void cov(int x, int mu, int ad) {
    if(x == 0) return;
    s[x] *= mu, s[x] += ad;
    mul[x] *= mu, add[x] *= mu, add[x] += ad;
}
void pushdown(int x) {
    // printf(&quot;*%lld\n&quot;, x);
    cov(ls[x], mul[x], add[x]);
    cov(rs[x], mul[x], add[x]);
    mul[x] = 1, add[x] = 0;
}
int merge(int x, int y) {
    if(x == 0 || y == 0) return x + y;
    pushdown(x); pushdown(y);
    if(s[x] &gt; s[y]) std::swap(x, y);
    rs[x] = merge(rs[x], y);
    if(dis[ls[x]] &lt; dis[rs[x]]) std::swap(ls[x], rs[x]);
    dis[x] = dis[rs[x]] + 1;
    return x;
}
</code></pre>
<p>删除操作：</p>
<pre><code class="language-cpp">pushdown(rt[u]);
rt[u] = merge(ls[rt[u]], rs[rt[u]]);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.2 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210422/</id>
        <link href="https://acfboy.pw/20210422/">
        </link>
        <updated>2021-04-02T03:37:47.000Z</updated>
        <summary type="html"><![CDATA[<p>其实正解都想得挺快的，但是 D 题细节有些恶心，最终调了很久，没空做最后一题了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>其实正解都想得挺快的，但是 D 题细节有些恶心，最终调了很久，没空做最后一题了。</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>一个字符串，若干个操作，每次翻转或在开头/结尾插入，输出最后结果。</p>
</blockquote>
<p>水题，<code>deque</code> 解决。</p>
<h2 id="b">B</h2>
<blockquote>
<p>一个字符串，维护区间内不同的字符个数，支持单点修改。</p>
</blockquote>
<p>线段树裸题。</p>
<h2 id="c">C</h2>
<p>水题，题目都不想打了。</p>
<h2 id="d">D</h2>
<p>随便来个样例，把所有的列出来。</p>
<pre><code class="language-plain">3
35
354
3543
 5
 54 
 543
  43
   3
</code></pre>
<p>中间显然有很多重复。</p>
<p>若只维护第一组，那么每次每个要减去的数不一样，所以从后面开始。</p>
<pre><code class="language-plain">   3
  43
 543
3543
  4
 54
354
 5
35
3
</code></pre>
<p>这样对于每一组，就是把第一个去掉，然后剩下的每一个减去最后一个位再除以十就可以了。</p>
<p>因为对于所有数的处理都一样，所以直接把取模完每一个答案有几个给记下来，然后维护一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, 满足经过了哪些操作原来答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的答案会变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 然后加上这个就可以了。</p>
<p>具体地，比如有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 个数，我现在要求倒数第二组的答案，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 需要满足(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">inv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的逆元)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mi>k</mi><mo>−</mo><msub><mi>s</mi><mn>5</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>)</mo><mo>−</mo><msub><mi>s</mi><mn>4</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>)</mo><mo>−</mo><msub><mi>s</mi><mn>3</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="1em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">((((((k-s_5)\times inv) - s_4) \times inv) - s_3) \times inv \equiv 0 \pmod p
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p>化简一下就是每次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>p</mi><mi>o</mi><mi>w</mi></mrow></msup></mrow><annotation encoding="application/x-tex">s_i \times 10^{pow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></span> 。</p>
<p>然后你就可以交了。</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#define int long long
int n, m, p, ans, f[10005];
char s[200005];
signed main() {
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p);
    scanf(&quot;%s&quot;, s + 1);
    for (int i = n, pow = 1, now = 0; i &gt;= 1; i--, pow = pow * 10 % p) {
        now = (now + (s[i] - '0' + p) * pow % p) % p;
        f[now]++;
    }
    for (int i = n, pow = 1, now = 0; i &gt;= 1; i--, pow = pow * 10 % p) {
        ans = ans + f[now];
        now = (now + (s[i] - '0') * pow % p) % p;
        f[now]--;
    }
    printf(&quot;%lld&quot;, ans);
}

</code></pre>
<p>交了以后会发现：WA 了</p>
<p>细细一想，发现若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的约数时连个逆元都没有，你乘个锤子！</p>
<p>所以特判一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的情况。</p>
<pre><code class="language-cpp">    if (p == 2 || p == 5) {
        for (int i = 1; i &lt;= n; i++)
            if ((s[i] - '0') % p == 0)
                ans += i;
        printf(&quot;%lld&quot;, ans);
        return 0;
    }
</code></pre>
<p>现在真的过了。这错误我调了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span> 分钟</p>
<h2 id="e">E</h2>
<p>原题是 ABC158F。</p>
<p><s>看了题解</s> 觉得 dp 还是比较显然的，肯定得排一个序，然后倒着。因为我们能唯一能确定的状态就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这个编号，根本没有机器人，方案只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个的方案数。显然可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_i = f_{i+1} + f_{next}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span> 是后面不受影响的。</p>
<p>问题在于后面那个怎么求。 <code>next</code> 即后面第一个大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x + d - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的，那不就是单调栈吗？</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
const int N = 200005, p = 998244353;
int n, f[N];
std::pair&lt;int, int&gt; a[N];
std::stack&lt;std::pair&lt;int, int&gt; &gt; st;
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i].first, &amp;a[i].second);
	std::sort(a+1, a+1+n);
	f[n+1] = 1;
	for(int i = n; i &gt;= 1; i--) {
		int t = a[i].first + a[i].second, next = i+1;
		while(!st.empty() &amp;&amp; t &gt; a[st.top().first].first) {
			next = st.top().second;
			st.pop();
		}
		st.push({i, next});
		f[i] = (f[i+1] + f[next]) % p;
	}
	printf(&quot;%d&quot;, f[1]);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[焦点]]></title>
        <id>https://acfboy.pw/fighting/</id>
        <link href="https://acfboy.pw/fighting/">
        </link>
        <updated>2021-04-01T23:22:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>一个焦点是木桩，一个焦点在远方。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>一个焦点是木桩，一个焦点在远方。</p>
</blockquote>
<!-- more -->
<p>语出萨曼·霍伊斯·艾伯特·康佩尔·威斯·阿瑞尔·佩格·赛真猪，原指在 Shaopi 的研究中，知道绳长较长的一种是一个椭圆；又猜测猜测一种圆桌上的 Shaopi 构成椭圆，一个焦点是 “木桩”，另一个无法确定在哪。</p>
<p>现在我们知道，那不是椭圆，而是双曲线，另一个焦点，就在圆心。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [CF -1172D]Nauuo and Binary Tree]]></title>
        <id>https://acfboy.pw/nauuo-and-binary-tree/</id>
        <link href="https://acfboy.pw/nauuo-and-binary-tree/">
        </link>
        <updated>2021-04-01T23:21:17.000Z</updated>
        <summary type="html"><![CDATA[<p>清新的好题，考验了对树剖的总和理解和运用。</p>
<p>只可惜 <a href="https://ouuan.github.io/post/bad-round-%E4%B8%8E%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E5%9D%9A%E5%AE%88/">赛前四天撞题</a>，这道题没能出现在真正的 CF 里。</p>
]]></summary>
        <content type="html"><![CDATA[<p>清新的好题，考验了对树剖的总和理解和运用。</p>
<p>只可惜 <a href="https://ouuan.github.io/post/bad-round-%E4%B8%8E%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E5%9D%9A%E5%AE%88/">赛前四天撞题</a>，这道题没能出现在真正的 CF 里。</p>
<!-- more -->
<blockquote>
<p><strong>交互题</strong>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个节点的二叉树，每次可以询问两个点的距离，求这个二叉树的结构。树的大小不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3000</mn></mrow><annotation encoding="application/x-tex">3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>, 可以询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30000</mn></mrow><annotation encoding="application/x-tex">30000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次。</p>
</blockquote>
<p>看到这个题面我是没有一点想法，甚至连暴力做法都不太清楚。</p>
<p>看了题解直呼好题。</p>
<ol>
<li>
<p>首先可以询问出每一个点的深度，这样可以按照深度确定点，从而确保去确定一个点的时候它的祖先都已经确定了。</p>
</li>
<li>
<p>每次确定一个点时</p>
<ol>
<li>先用 dfs 维护已知树上的轻重链。注意，因为是二叉树，所以一个点若有两个儿子，那么必定是一条轻边一条重边。如果只有一个儿子，我们规定连向它的是重边。这个性质非常有用。</li>
<li>在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子树中找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 时，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 已经没有儿子了，肯定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的父亲。</li>
<li>否则询问当前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 所在重链底部的距离记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>, 通过类似通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">LCA</mtext></mrow><annotation encoding="application/x-tex">\texttt{LCA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">LCA</span></span></span></span></span> 求两点距离的那个式子可以求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">LCA</mtext></mrow><annotation encoding="application/x-tex">\texttt{LCA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">LCA</span></span></span></span></span> 的深度，进而求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">LCA</mtext></mrow><annotation encoding="application/x-tex">\texttt{LCA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">LCA</span></span></span></span></span>, 然后就可以确定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 所在的新子树，递归求解。</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 只有一个儿子，那它就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 了，因为只有一个儿子那么肯定是重边，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 所在重链的最底端也是它自己。</li>
</ol>
</li>
</ol>
<p>具体可以见下图。</p>
<figure data-type="image" tabindex="1"><img src="https://oi-wiki.org/graph/images/hld2.png" alt="" loading="lazy"></figure>
<p>时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的，询问由于每次都会确定一个子树，所以是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span> 级别的，具体分析可以去看 OI-wiki</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
const int N = 3005;
struct twt {
	int dep, id;
	bool operator &lt; (twt b) const {
		return dep &lt; b.dep;
	}
} a[N];
int n, ch[N][2], son[N], fa[N], bot[N], deep[N], size[N];
void Print() {
	std::cout &lt;&lt; &quot;! &quot;;
	for(int i = 2; i &lt;= n; i++) std::cout &lt;&lt; fa[i] &lt;&lt; &quot; &quot;;
	std::cout &lt;&lt; std::endl;
}
int ask(int u, int v) {
	std::cout &lt;&lt; &quot;? &quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; std::endl;
	int d;
	std::cin &gt;&gt; d;
	return d;
}
void add(int u, int v) {
	fa[v] = u;
	if(ch[u][0] != 0) ch[u][1] = v;
	else ch[u][0] = v;
}
void dfs(int u) {
	if(ch[u][0]) dfs(ch[u][0]);
	if(ch[u][1]) dfs(ch[u][1]);
	size[u] = size[ch[u][0]] + size[ch[u][1]] + 1;
	if(ch[u][1] != 0) son[u] = size[ch[u][1]] &gt; size[ch[u][0]];
	else son[u] = 0;
	if(ch[u][son[u]] != 0) bot[u] = bot[ch[u][son[u]]];
	else bot[u] = u;
}
void solve(int u, int k) {
	if(ch[u][0] == 0) {
		add(u, k);
		return;
	}
	int d = ask(k, bot[u]), v = bot[u];
	while(deep[v] &gt; (deep[k] + deep[bot[u]] - d) / 2) v = fa[v];
	int w = ch[v][son[v] ^ 1];
	if(w != 0) solve(w, k);
	else add(v, k);
}
int main() {
	std::cin &gt;&gt; n;
	for(int i = 2; i &lt;= n; i++) {
		a[i].id = i;
		a[i].dep = ask(1, i);
		deep[i] = a[i].dep;
	}
	std::sort(a+2, a+1+n);
	for(int i = 2; i &lt;= n; i++) {
		dfs(1);
		solve(1, a[i].id);
	}
	Print();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.3.31 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/2021331/</id>
        <link href="https://acfboy.pw/2021331/">
        </link>
        <updated>2021-04-01T00:15:33.000Z</updated>
        <summary type="html"><![CDATA[<p>极其糟糕的比赛体验，中文题面比 CF 的英文题面还要难以读懂。</p>
<p>赛后一直搞 T4 的瞎搞哈希做法，用了一整个晚自修。</p>
]]></summary>
        <content type="html"><![CDATA[<p>极其糟糕的比赛体验，中文题面比 CF 的英文题面还要难以读懂。</p>
<p>赛后一直搞 T4 的瞎搞哈希做法，用了一整个晚自修。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>题面有些迷，样例又出锅。</p>
<p>看懂题面后就好做了。</p>
<blockquote>
<p>就是要求一个最长不上升子序列，要求字典序最大。</p>
</blockquote>
<p>字典序最大的问题只需要反过来跑最长不下降子序列，更新的时候不把等号取上，然后正着找，等号也取上就行了。</p>
<h2 id="b">B</h2>
<p>简单的数学题。</p>
<blockquote>
<p>给出由 <code>abc?</code> 四个字符组成的字符串， <code>?</code> 可变为任意字符，问在所有的情况中子序列 <code>abc</code> 出现了几次。</p>
</blockquote>
<p>没有 <code>?</code> 的做法就左右记一下 <code>a</code> 和 <code>c</code> 的个数然后乘起来就可以了。</p>
<p>有 <code>?</code> 的就考虑定下一些 <code>?</code> 的字母，然后其它随便排就可以了。具体地，在找到 <code>b</code> 的时候把左边 <code>a</code> 的个数和右边 <code>?</code> 的个数乘起来再乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">3^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 就是以当前这个为中间，左边的 <code>a</code> 为左边，右边使用 <code>?</code> 在所有序列中出现的次数。</p>
<h2 id="c">C</h2>
<p>前两题都是签到题，现在开始略有难度(主要在读题)，原题是 CF980D。</p>
<p>其实不怪搬题人，洛谷的翻译过于糟糕了。分成的序列是可以不连续的，赛时按照连续的来做了。</p>
<p>两数相乘是平方数其实是由传递性的，很容易证明。</p>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo>∏</mo><msubsup><mi>a</mi><mi>i</mi><msub><mi>k</mi><mi>i</mi></msub></msubsup><mo separator="true">,</mo><mi>B</mi><mo>=</mo><mo>∏</mo><msubsup><mi>b</mi><mi>i</mi><msub><mi>m</mi><mi>i</mi></msub></msubsup><mo separator="true">,</mo><mi>C</mi><mo>=</mo><mo>∏</mo><msubsup><mi>c</mi><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">A = \prod a_i^{k_i}, B = \prod b_i ^ {m_i}, C = \prod c_i ^ {n_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.207872em;vertical-align:-0.276864em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.931008em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.026864em;vertical-align:-0.276864em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.026864em;vertical-align:-0.276864em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span>, 若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 是平方数，那么一定有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><msub><mi>k</mi><mi>i</mi></msub><mo>+</mo><msub><mi>m</mi><mi>i</mi></msub><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall i, k_i+m_i \equiv 0 \pmod 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61375em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, 同理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><msub><mi>n</mi><mi>i</mi></msub><mo>+</mo><msub><mi>m</mi><mi>i</mi></msub><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall i, n_i+m_i \equiv 0 \pmod 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61375em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, 所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><msub><mi>n</mi><mi>i</mi></msub><mo>≡</mo><msub><mi>k</mi><mi>i</mi></msub><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall i, n_i \equiv k_i\pmod 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \times C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 也是平方数。</p>
<p>那么就可以用并查集维护了，看一段子串中有几个不同集合就好了。</p>
<p>注意 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 不能参与上面运算，它可以放入任意集合，所以单独考虑。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 5005;
int n, a[N], fa[N], ans[N], map[N];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
bool check(int x, int y) {
	if(x * y &lt;= 0) return false;
	int an = sqrt(x*y);
	if(an * an == x * y) return true;
	else return false;
}
signed main() {
    scanf(&quot;%lld&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) fa[i] = i;
    for(int i = 1; i &lt;= n; i++) {
        scanf(&quot;%lld&quot;, &amp;a[i]);
        for(int j = 1; j &lt; i; j++)
            if(check(a[i], a[j]))  fa[find(i)] = find(j);
    }
    for(int i = 1; i &lt;= n; i++) {
        memset(map, 0, sizeof(map));
        int an = 0;
        for (int j = i; j &lt;= n; j++)
            if(a[j] == 0) ans[std::max(an, 1ll)]++;
            else {
                if(!map[fa[j]]) an++;
                map[fa[j]] = 1;
                ans[an]++;
            }
    }
    for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]);
    return 0;
}
</code></pre>
<h2 id="d">D</h2>
<p>原题是 [SDOI2008]Sandy的卡片。</p>
<p>题面可以转化为(作差以后)。</p>
<blockquote>
<p>求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个串的最长相同子串</p>
</blockquote>
<p>赛场上以为是要最长相同的相同子串，样例太水，还让我过了，居然有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>。</p>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n, m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span> 非常小，所以不用啥后缀自动机了，直接 dp 就好。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 是前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 串前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个且以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 结尾的最长相同子串， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 是相邻的两行前一行以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 结尾， 后一行以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 结尾的前面的最长相同子串。利用辅助的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 可以方便转移。</p>
<p>其实挺妙的，想不到用两个来维护转移。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 1005, INF = 0x3f3f3f3f3f3f3f3f;
int n, m, x, ans, g[N][N], f[N][N];
std::vector&lt;int&gt; a[N];
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%lld&quot;, &amp;m);
		for(int j = 1; j &lt;= m; j++) {
			scanf(&quot;%lld&quot;, &amp;x);
			a[i].push_back(x);
		}
		for(int j = (signed)a[i].size()-1; j &gt;= 1; j--) a[i][j] -= a[i][j-1]; 
	}
	for(int i = 1; i &lt; (signed)a[1].size(); i++) f[1][i] = INF;
	for(int i = 2; i &lt;= n; i++) {
		memset(g, 0, sizeof g);
		for(int j = 1; j &lt; (signed)a[i].size(); j++)
			for(int k =  1; k &lt; (signed)a[i-1].size(); k++)
				if(a[i][j] == a[i-1][k]) 
					g[j][k] = std::min(f[i-1][k], g[j-1][k-1] + 1),
					f[i][j] = std::max(f[i][j], g[j][k]);
	}
	for(int j = 1; j &lt; (signed)a[n].size(); j++)
		ans = std::max(ans, f[n][j]);
	printf(&quot;%lld&quot;, ans+1);
	return 0;
}
</code></pre>
<p>好，正戏收场，<strong>开始乱搞。</strong></p>
<p>赛时我按照错误的理解写了一个 <code>map</code> 做法，然后挂掉了，所以赛后我不甘心，一定要使用 <code>map</code> 来做。</p>
<p>如果把所有的子串直接用 <code>map</code> 来映射到它的长度，那肯定是要超时的，因为枚举所有子串用的总复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><msup><mi>m</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">nm^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> 了，再乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span> 再乘上移动串所需要的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的复杂度，显然超时。</p>
<p><strong>注意：</strong> <code>erase</code> 的时候不能直接 <code>erase</code> 因为 <code>map</code> 的迭代器不会自动跳到下一个，所以要写作 <code>erase(j++)</code> 先传进去，没删掉就到下一个，不然会 RE。</p>
<p><a href="https://www.luogu.com.cn/record/48778679">提交记录</a></p>
<p>氧气也救不了</p>
<p><a href="https://www.luogu.com.cn/record/48778698">吸氧的记录</a></p>
<p>代码如下。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#define int long long
const int N = 1005;
int n, m, x, ans;
typedef std::vector&lt;int&gt; twt;
twt a[N], hash;
std::map&lt;twt, int&gt; anst, t;
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%lld&quot;, &amp;m);
		for(int j = 1; j &lt;= m; j++) {
			scanf(&quot;%lld&quot;, &amp;x);
			a[i].push_back(x);
		}
		for(int j = (signed)a[i].size()-1; j &gt;= 1; j--) a[i][j] -= a[i][j-1]; 
		t.clear();
		for(int j = 1; j &lt; (signed)a[i].size(); j++) {
			hash.clear();
			for(int k = j; k &lt; (signed)a[i].size(); k++) {
				hash.push_back(a[i][k]);
				t[hash] = std::max(t[hash], k-j+1);
			}
		}  
		for(std::map&lt;twt, int&gt;::iterator j = anst.begin(); j != anst.end();)
			if(t[j -&gt; first] != 0) j -&gt; second = std::min(j -&gt; second, t[j -&gt; first]), j++;
			else anst.erase(j++);			
		if(i == 1) 
			for(std::map&lt;twt, int&gt;::iterator j = t.begin(); j != t.end(); j++) 
				anst[j -&gt; first] = j -&gt; second;
	}
	for(std::map&lt;twt, int&gt;::iterator j = anst.begin(); j != anst.end(); j++)
		ans = std::max(ans, j -&gt; second);
	printf(&quot;%lld&quot;, ans+1);
	return 0;
}
</code></pre>
<p>那么怎么办呢？我们难道要放弃这个伟大的做法吗？</p>
<p>不，上面的程序复杂度大主要在于要把整个串给存进去，那么我们先哈希一下再存进去不就可以避免这个问题了吗。</p>
<p>但在这题中似乎特别容易冲突，毕竟全是数，值域大，然而<a href="https://www.luogu.com.cn/record/48778790">单哈希过了</a>......</p>
<p>为了追求严谨，还是使用三哈希。</p>
<p>代码如下，其实就是重写了上面的 twt.</p>
<p>重写成这样:</p>
<pre><code class="language-cpp">struct twt {
	int h[T];
	void clear() {
		for(int i = 0; i &lt; T; i++) h[i] = 0;
	}
	void insert(int x) {
		for(int i = 0; i &lt; T; i++) h[i] = h[i] * ti[i] + x % mod[i];
	}
	bool operator &lt; (twt b) const {
		return h[0] &lt; b.h[0];
	}
} hash;
</code></pre>
<p>就好了，注意必须要重载严格弱序的 <code>&lt;</code>, 因为在红黑树中需要用到。</p>
<p><a href="https://www.luogu.com.cn/record/48760531">交了</a>发现 TLE on #5</p>
<p>吸口氧就过了。</p>
<p>我们知道主要复杂度在于 <code>map</code> (?), 所以使用传说中的 <code>unordered_map</code> 是不是就可以过了呢？</p>
<p>对于单哈希的那玩意儿，直接把 <code>map</code> 替换为 <code>unoredered_map</code> 就可以了，确实快了很多，但本地测试最慢的点仍然要 1.64s 还是过不了，在洛谷上不开 O2 就 TLE， <a href="https://www.luogu.com.cn/record/48778899">开了</a> 需要 545ms, <s>比暴力程序还要慢</s>。</p>
<p>那么对于三哈希的 twt, 如果你直接使用 <code>unordered_map</code> ，恭喜，会收到<a href="https://www.luogu.com.cn/record/48763002">一大坨 CE</a>, 因为 <code>unordered_map</code> 不知道该如何哈希 twt， 所以我们需要自定义哈希函数，并重载等号的运算，哈希函数需要写成伪函数的形式，最后就是这个样子的。</p>
<pre><code class="language-cpp">struct twt {
	int h[T];
	void clear()  {for(int i = 0; i &lt; T; i++) h[i] = 0; }
	void insert(int x) { for(int i = 0; i &lt; T; i++) h[i] = h[i] * ti[i] + x % mod[i]; }
	bool operator == (twt b) const {	return h[0] == b.h[0] &amp;&amp; h[1] == b.h[1] &amp;&amp; h[2] == b.h[2]; }
} hash;
struct hashf{
	size_t operator() (twt a) const {
		return (unsigned) a.h[0] + a.h[1] + a.h[2];
	} 
};
std::unordered_map&lt;twt, int, hashf&gt; anst, t;
</code></pre>
<p><s>hash 到最后又合成了一个，这三哈希了个寂寞。</s></p>
<p>其实说了那么多，就是想普及一下 <code>unordered_map</code> 的用法。</p>
<p>但遗憾的是 <code>unordered_map</code> 不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的，仍然过不了，开了 O2 也一样........</p>
<hr>
<p>这场主要难度在于读题的比赛其实对我的帮助在于普及了 <code>unordered_map</code>  和 <code>map.erase()</code>的用法......</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [2019 ICPC 上海网络赛] Lighting Routing I]]></title>
        <id>https://acfboy.pw/lightingrouting/</id>
        <link href="https://acfboy.pw/lightingrouting/">
        </link>
        <updated>2021-03-31T00:26:37.000Z</updated>
        <summary type="html"><![CDATA[<p><s>封面图是随便找的真实的 Lighting Routing</s></p>
<p>据说这题有神奇的 LCT 和 树套树 的做法，很可惜，我都不会。</p>
<p>于是搞了一个用欧拉序来维护直径的做法，搭配线段树和倍增 LCA 来解决这题。</p>
]]></summary>
        <content type="html"><![CDATA[<p><s>封面图是随便找的真实的 Lighting Routing</s></p>
<p>据说这题有神奇的 LCT 和 树套树 的做法，很可惜，我都不会。</p>
<p>于是搞了一个用欧拉序来维护直径的做法，搭配线段树和倍增 LCA 来解决这题。</p>
<!-- more -->
<blockquote>
<p>支持边的修改操作，每次询问树上离一个点最远的点和它的距离。</p>
</blockquote>
<p>我们知道从树上任意一个点出发，能到达的最远的点一定是树的直径的一个端点，所以这题也就是要动态维护树的直径，然后求一下距离就可以了。</p>
<p>那么怎么维护树的直径呢？这里介绍一下一个神奇的做法，欧拉序。</p>
<p>欧拉序是一个类似 DFS 序的东西，不同的是，欧拉序在遍历完一个点的子树的时候还会把这个点加入欧拉序中，相当于一个人沿 DFS 的顺序走完树上所有点的路径。欧拉序的长度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 因为每一条边两个端点都要算一次，最后退出的时候根节点过算了一次。</p>
<p>求得欧拉序的代码, 其中 <code>pos[(i+1)/2] = v</code> 是将输入边的编号和指向的点对应起来，因为是双向建边的，所以要除以二上取整。而且这样子给这条边定的指向的点是以我们定的根为根的，这个处理其实挺妙。</p>
<p><code>tin</code> 和 <code>tout</code> 用来记录一个子树在欧拉序中的起点和终点。</p>
<pre><code class="language-cpp">void dfs(int u, int fa) {
	dfn[++tot] = u; tin[u] = tot;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(v == fa) continue;
		pos[(i+1)/2] = v, dep[v] = dep[u] + len[i];
		dfs(v, u);
		dfn[++tot] = u;
	}
	tout[u] = tot;
}
</code></pre>
<p>那么使用欧拉序有什么好处呢？</p>
<p>在两个点的欧拉序之间，深度最小的一定就是它们的 LCA 了，这很好理解，因为欧拉序就是走过每一个点的路径嘛，你要走过两个点，肯定是要先到一个，然后退出来，再接着到第二个。这样就把 LCA 的问题转换成了 RMQ 问题。因为欧拉序也具有 dfs 序子树都在一起的性质，所以给一条边的边权加上一个数就是给一段区间的 <code>dep</code> 都加上一个数。</p>
<p>然后考虑在欧拉序上维护直径。</p>
<p>我们在树形 DP 求直径的时候是到每一个点把它们最深的两个拼在了一起，链的长度是两个点的距离，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>x</mi></msub><mo>+</mo><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>y</mi></msub><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><msub><mi>p</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dep_x + dep_y - 2dep_{lca}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，经过每一个点时，就是要让这个东西最大，或者直接采用下面的答案。</p>
<p>可以用线段树来维护这样几个东西。</p>
<ul>
<li>最大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span></span></span></span>, 记作 <code>maxd</code></li>
<li>最大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><msub><mi>p</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">-2dep_{lca}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 记作 <code>vlca</code></li>
<li>最大的左边和中间拼起来的，即最大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>x</mi></msub><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><msub><mi>p</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dep_x - 2dep_{lca}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 记作 <code>lm</code></li>
<li>同理 <code>mr</code></li>
<li>还有当前子树的直径 <code>lmr</code></li>
</ul>
<p>因为一段欧拉序代表的都是树的一部分，所以可以这样来维护，也可以合并。<br>
<code>pushup</code> 的时候 <code>maxd</code> 和 <code>vlca</code> 显然都是子树取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop">max</span></span></span></span> 就可以了，<code>lm</code> 要考虑左边的 <code>maxd</code> 和 <code>vlca</code> 拼成或直接用下面的答案，<code>mr</code> 同理， <code>lmr</code> 要考虑直接用下面的答案或左边的 <code>lm</code> 拼右边的 <code>maxd</code> 或者右边的 <code>mr</code> 配左边的 <code>maxd</code>。</p>
<p>但这样怎么记录方案呢？我们可以参考 dp 的时候记录方案的做法，从哪边转移过来就继承哪边的结果。然后我们就可以得到以下的 <code>pushup</code> 代码。</p>
<pre><code class="language-cpp">void pushUp(int p) {
	maxd[p] = std::max(maxd[p+p], maxd[p+p+1]);
	vlca[p] = std::max(vlca[p+p], vlca[p+p+1]);
	lm[p] = std::max(std::max(lm[p+p], lm[p+p+1]), maxd[p+p] + vlca[p+p+1]);
	mr[p] = std::max(std::max(mr[p+p], mr[p+p+1]), vlca[p+p] + maxd[p+p+1]);
	lmr[p] = std::max(std::max(lmr[p+p], lmr[p+p+1]), std::max(lm[p+p]+maxd[p+p+1], maxd[p+p]+mr[p+p+1]));
	
	if(maxd[p] == maxd[p+p]) vd[p] = vd[p+p];
	else vd[p] = vd[p+p+1];
	
	if(lm[p] == lm[p+p]) vl[p] = vl[p+p];
	else if(lm[p] == lm[p+p+1]) vl[p] = vl[p+p+1];
	else vl[p] = vd[p+p];
	
	if(mr[p] == mr[p+p]) vr[p] = vr[p+p];
	else if(mr[p] == mr[p+p+1]) vr[p] = vr[p+p+1];
	else vr[p] = vd[p+p+1];
	
	if(lmr[p] == lmr[p+p]) s[p] = s[p+p], t[p] = t[p+p];
	else if(lmr[p] == lmr[p+p+1]) s[p] = s[p+p+1], t[p] = t[p+p+1];
	else if(lmr[p] == lm[p+p] + maxd[p+p+1]) s[p] = vl[p+p], t[p] = vd[p+p+1];
	else s[p] = vd[p+p], t[p] = vr[p+p+1];
}
</code></pre>
<p>这是整道题的核心。</p>
<p>剩下的部分就是普通的线段树以及求两点间距离了(线段树中单个点的 <code>maxd</code> 其实就是 <code>dep</code>)， 不难实现， 要注意区分欧拉序编号和原始编号，我为这个调了很久。</p>
<p><a href="https://vjudge.net/solution/30295703">完整代码链接</a></p>
]]></content>
    </entry>
</feed>