<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的博客</title>
    <updated>2021-04-20T11:06:29.285Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的博客</rights>
    <entry>
        <title type="html"><![CDATA[题解 P3634 [APIO2012]守卫]]></title>
        <id>https://acfboy.pw/apio2012shou-wei/</id>
        <link href="https://acfboy.pw/apio2012shou-wei/">
        </link>
        <updated>2021-04-20T11:01:41.000Z</updated>
        <summary type="html"><![CDATA[<p>一道从开始就被我想歪的题目，以至于写了一天最后发现根本就是错误的算法，只好照题解写去了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一道从开始就被我想歪的题目，以至于写了一天最后发现根本就是错误的算法，只好照题解写去了。</p>
<!-- more -->
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 的区间内有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个标记在整数上，给出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 段区间内有/没有标记，输出一定有标记的数字。</p>
</blockquote>
<p>看完题我就直接给出了一堆“显然”的结论：</p>
<ol>
<li>去掉没有的，若有的区间长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 那这个就肯定是的了。</li>
<li>把肯定是的去掉，当且仅当剩下还有的标记数和现在有覆盖标记的数字数一样的时候有一定有标记的数字，且一定是全都是。</li>
</ol>
<p>看上去是不是挺有道理？于是我就设计了一个用 <code>std::set</code> 的算法，用 <code>(twt){st, len}</code> 表示从 <code>st</code> 开始长度 <code>len</code> 的有覆盖，维护一个可能有的区间，和一个一定没有到区间，然后用一定没有的在有的区间内除去，然后判一下前面两条就行了。合并区间的时候注意有标记的区间刚刚好相接是不能接上的，因为要注意一号判断。</p>
<p>似乎好有道理，然后我就写、调了俩小时，最后获得了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 分的优异成绩。</p>
<p>其实反例很显然：</p>
<pre><code class="language-cpp">3 1 3
1 1 1
1 2 1
1 3 1
</code></pre>
<p>这样我认为是无法确定的，其实第一个明显是可以确定的。解决这个问题可不是仅仅把开始时长度就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的判掉那么简单。</p>
<p>比如这组反例：</p>
<pre><code class="language-cpp">5 1 3
2 3 1
1 5 1
3 3 0
</code></pre>
<p>把前两段并起来后就损失了它们单独的信息了！</p>
<p>所以前面的断言根本就是错的。浪费了我许多的时间。<strong>在开始写代码前一定要想清楚，充分考虑算法的正确性是否成立。</strong></p>
<p>那么现在来讲正确的做法吧。</p>
<p>正确做法同样维护了可能由标记的区间并从中去掉了一定没有标记的区间，那它是如何处理在合并中的信息损失呢？</p>
<p>其实，正确做法根本不需要这个信息，<s>因为它不依赖于我的断言</s>。</p>
<p>想法很简单，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 记录前面到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 段所需的最少标记数量，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">g_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 记录从后面开始的。然后枚举每一个点就强制它不选，选它左边一个，再看下前后所需的会不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 就好了。</p>
<p>当然细节还是要处理的。</p>
<p>题解里处理合并的方式比我的 <code>set</code> 好多了，既快（没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>） 又好写 （不用处理迭代器删除的问题），用差分把现在不是肯定没有的点抓出来重新编号，用新编号表示线段的端点。</p>
<p>处理合并可以将一个端点排序后使用单调栈处理合并。至于找左右的线段端点？既然有序，直接二分就好了。</p>
<p>代码实现感觉也一些的难度。</p>
<pre><code class="language-cpp">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m);
	for(int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d%d&quot;, &amp;a[i].l, &amp;a[i].r, &amp;a[i].f);
		if(a[i].f == 0) ++b[a[i].l], --b[a[i].r+1];
	}
	int now = 0, cnt = 0;
	for(int i = 1; i &lt;= n; i++) {
		now += b[i];
		if(now == 0) L[i] = R[i] = ++cnt, be[cnt] = i;
	}
	if(cnt == k) {
		for(int i = 1; i &lt;= cnt; i++) printf(&quot;%d\n&quot;, be[i]);
		return 0;
	}
</code></pre>
<p>先是重新编号的过程，如果发现这些点恰好就是需要的，那么直接输出就可以了。</p>
<p>同时标记出了一个新的点左右最靠近的一个端点。</p>
<pre><code class="language-cpp">	L[n+1] = n+1;
	for(int i = 1; i &lt;= n; i++) 
		if(R[i] == 0) R[i] = R[i-1];
	for(int i = n; i &gt;= 1; i--) 
		if(L[i] == 0) L[i] = L[i+1];
	cnt = 0;
	for(int i = 1; i &lt;= m; i++) {
		if(a[i].f == 0) continue;
		if(L[a[i].l] &lt;= R[a[i].r]) a[++cnt].l = L[a[i].l], a[cnt].r = R[a[i].r];
	}
	std::sort(a+1, a+cnt+1);
</code></pre>
<p>然后更新 <code>a</code> 的编号并进行排序。</p>
<p>以下重新使用了 <code>L</code> 和 <code>R</code> 作为栈，注意这里的合并不是我假做法里的合并，而是把完全覆盖的给并掉了。还求出了 <code>f</code> 和 <code>g</code>。</p>
<pre><code>	int top = 0;
	for(int i = 1; i &lt;= cnt; i++) {
		while(top != 0 &amp;&amp; a[i].l &gt;= L[top] &amp;&amp; a[i].r &lt;= R[top]) top--;
		L[++top] = a[i].l, R[top] = a[i].r;
	}
	int l = n+1, r = 0;
	for(int i = 1; i &lt;= top; i++) {	
		if (L[i] &gt; r) f[i] = f[i-1] + 1, r = R[i];
		else f[i] = f[i-1];
	}
	for(int i = top; i &gt;= 1; i--) {
		if (R[i] &lt; l) g[i] = g[i+1] + 1, l = L[i];
		else g[i] = g[i+1];
	}
</code></pre>
<p>最后是关键的判断环节。</p>
<p>这里还需要说明一下，最后栈中的编号是剩下线段的编号，我们每次只判断了最右边一个是否是一定要有的，是因为这样子显然是最优的，因为放在这个位置右边也可能会利用到，而因为每一段覆盖只需要一个就可以了，其它地方判断出来是不能确定的，因为可以放到线段最右边的位置可能更优。</p>
<pre><code class="language-cpp">	bool flag = 0;
	for(int i = 1; i &lt;= top; i++) {
		if(f[i] == f[i-1]) continue;
		if (L[i] == R[i]) {
			printf(&quot;%d\n&quot;, be[R[i]]);
			flag = 1; 
			continue;
		}
		int l = 1, r = i - 1, x = 0, y = top + 1;
		while (l &lt;= r) {				 
			int mid = l + ((r - l) &gt;&gt; 1);
			if (R[mid] &lt; R[i] - 1) x = mid, l = mid + 1;
			else r = mid - 1;
		}
		l = i + 1, r = top;
		while (l &lt;= r) {
			int mid = l + ((r - l) &gt;&gt; 1);
			if (L[mid] &gt; R[i] - 1) y = mid, r = mid - 1;
			else l = mid + 1;
		}
		if (f[x] + g[y] + 1 &gt; k) {
			printf(&quot;%d\n&quot;, be[R[i]]);
			flag = 1;
		}
	}
	if(flag == 0) puts(&quot;-1&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Japanese Student Championship 2021 游记]]></title>
        <id>https://acfboy.pw/jsc2021/</id>
        <link href="https://acfboy.pw/jsc2021/">
        </link>
        <updated>2021-04-18T08:28:50.000Z</updated>
        <summary type="html"><![CDATA[<p>这场比赛还是有收获的，特别是对 E 题的坚持。</p>
<p>但比赛体验真的比较糟糕，在学校里比赛就感觉特别吵，而且 D 题开始还读错了题目，E 题没有在赛时通过，最后上蓝再次失败。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这场比赛还是有收获的，特别是对 E 题的坚持。</p>
<p>但比赛体验真的比较糟糕，在学校里比赛就感觉特别吵，而且 D 题开始还读错了题目，E 题没有在赛时通过，最后上蓝再次失败。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题。</p>
<p>但开始时十分紧张，题目读了好久才明白，浪费了一些时间。</p>
<p>大概很多人一起比赛无形之中会增加紧张感吧。</p>
<h2 id="b">B</h2>
<p>水题。</p>
<p>做题开始有点儿状态了。</p>
<h2 id="c">C</h2>
<p>状态正常！</p>
<h2 id="d">D</h2>
<p>开始看错了题目，以为是要整个串的和是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的倍数，当然推不出什么结果，就直接看了别人的结论。</p>
<p>赛后发现读错题了之后就简单了，有一个显然的 dp， 然后它又可以很显然地化成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>p</mi><mo>−</mo><mn>2</mn><msup><mo>)</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(p-2)^{n-1}(p-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的形式。</p>
<h2 id="e">E</h2>
<p>最大的“亮点”，赛场上想了一会儿模拟了几个样例居然想到了正解。</p>
<p>不过实现起来就是另外一回事了，感觉细节特别特别多，然后就是……赛后补了一早上才过。</p>
<figure data-type="image" tabindex="1"><img src="https://www.hualigs.cn/image/607cc1c953043.jpg" alt="" loading="lazy"></figure>
<p>大致的思路其实很好想，就是每次分段一层一层的剖下来，然后对于每一个找出最多的把其它都改成它，然后就遇到了一堆的问题：</p>
<ol>
<li>如何快速找到最后一层的一个所对应的其它</li>
<li>若最后一层仍然回文怎么办</li>
<li>奇数个的如何匹配中间</li>
</ol>
<p>然后赛场上想到了设一个在最后串中左边有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个， 右边有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个就是每次加俩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 再加俩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>, 然后用栈处理有奇数个层的多出来的那个，先把所有当个的拉出来就好了，总和肯定不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。于是直接噼里啪啦写代码，写完错误一堆。</p>
<p>主要问题是考场上怕来不及，很多地方都没有想清楚，比如栈变化的那个操作序列怎么生成，又比如最后仍然回文应该怎么处理……</p>
<p>于是第二天还调了一早上才终于过了， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mo>+</mo></mrow><annotation encoding="application/x-tex">100+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">+</span></span></span></span> 行的代码。</p>
<p>最后一看题解发现人家 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> 几行就写完了。</p>
<p>好吧好吧，不过调这题大概真的锻炼了思维的严谨性，就把代码拿来纪念吧。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
std::vector&lt;int&gt; tmp;
const int N = 500005, SPJ = 19;
int k, n, sta[N], tub[28], ans, top, len, opt[N], pre[N], tns;
char st[N], st2[N];
bool check() {
	for(int i = 1; i &lt;= len; i++)
		if(st2[i] != st2[len-i+1]) return false;
	return true;
}
void doit(int opt) {
	for(int i = 0; i &lt; 26; i++) tub[i] = 0;
	for(int i = 0; i &lt; (signed)tmp.size(); i++) 
	    if(opt != SPJ) tub[st[tmp[i]]-'a'] ++;
	    else if(st[tmp[i]]-'a' != st2[tmp[i]]-'a') tub[st[tmp[i]]-'a'] ++;
	int maxj = 27;
	for(int i = 0; i &lt; 26; i++) 
		if(tub[i] &gt; tub[maxj]) maxj = i;
	int cnt = 0;
	for(int i = 0; i &lt; (signed)tmp.size(); i++) 
	    cnt += (st[tmp[i]] != maxj+'a'), st2[tmp[i]] = maxj + 'a';
	if(opt == SPJ) {
	    if(tmp[0] != (len+1)/2) tns = std::min(tns, cnt - pre[tmp[0]]);
	}
	else {
	    pre[tmp[0]] = cnt;
	    ans += cnt;
	}
}
int makeopt(int x) {
	if(x == 0) return 0;
	opt[1] = x;
	int j = 1;
	for(int i = x-1; i &gt;= 1; i--) {
		opt[++j] = i;
		for(int k = j-1; k &gt;= 1; k--) 
			opt[++j] = opt[k];
	}
	return j;
}
int main() {
	scanf(&quot;%d%s&quot;, &amp;k, st+1);
	n = strlen(st+1);
	if(k == 0) {
	    if(n == 1) return puts(&quot;impossible&quot;), 0;
	    ans = 1;
	    for(int i = 1; i &lt;= n; i++)
	        if(st[i] != st[n-i+1]) ans = 0;
	    printf(&quot;%d&quot;, ans);
	    return 0;
	}
	for(int i = 1; i &lt;= n; i++) st2[i] = st[i];
	if(k &gt; 20 || (n &gt;&gt; (k-1)) == 0 || (n &gt;&gt; k) == 1) return puts(&quot;impossible&quot;), 0;
	len = n;
	for(int j = 1; j &lt;= k; j++) {
		if(len &amp; 1) {
			int a = len &gt;&gt; 1;
			tmp.clear();
			int end = makeopt(top);
			tmp.push_back(a+1);
			for(int i = a+1, w = 1; i &lt;= n &amp;&amp; w &lt;= end; w++) {
				i += 2*a + sta[opt[w]] + 1;
				tmp.push_back(i);
			}
			doit(0);
			sta[++top] = 1;
		}
		else sta[++top] = 0;
		len &gt;&gt;= 1;
	}
	for(int i = 1; i &lt;= len; i++) {
		int a = i-1, b = len-i;
		tmp.clear();
		int end = makeopt(top);
		tmp.push_back(i);
		for(int j = i, c = 1, w = 1; j &lt;= n &amp;&amp; w &lt;= end; c++, w++) {
			if(c%2 == 1) j = j + 2*b + sta[opt[w]] + 1;
			else j = j + 2*a + sta[opt[w]] + 1;
			tmp.push_back(j);
		}
		doit(0);
	}
	if(len != 0 &amp;&amp; check()) {
	    tns = 0x3f3f3f3f;
	    for(int i = 1; i &lt;= len; i++) {
    		int a = i-1, b = len-i;
    		tmp.clear();
    		int end = makeopt(top);
    		tmp.push_back(i);
    		for(int j = i, c = 1, w = 1; j &lt;= n &amp;&amp; w &lt;= end; c++, w++) {
    			if(c%2 == 1) j = j + 2*b + sta[opt[w]] + 1;
    			else j = j + 2*a + sta[opt[w]] + 1;
    			tmp.push_back(j);
    		}
    		doit(SPJ);
    	}
    	ans = ans + tns;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.4.17 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/2020417/</id>
        <link href="https://acfboy.pw/2020417/">
        </link>
        <updated>2021-04-17T07:28:17.000Z</updated>
        <summary type="html"><![CDATA[<p>研究了 T2 一会儿居然写快速谭炜谭变换去了，结果后来发现这题……</p>
<p>以后得改变做题的模式了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>研究了 T2 一会儿居然写快速谭炜谭变换去了，结果后来发现这题……</p>
<p>以后得改变做题的模式了。</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>一只马，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的棋盘中能跳到几个点。</p>
</blockquote>
<p>对于大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">3 \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 的棋盘是都可以跳到的，因为在 上/下 和 右边 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的格子时就可以移动到右边的一个。</p>
<p>剩下的判掉就好了。</p>
<h2 id="b">B</h2>
<blockquote>
<p>输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 组数，每组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(l_i, d_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 每次两种操作：</p>
<ul>
<li>价值加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 去掉最左边的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">l_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个</li>
<li>把最后一个换到开头，其它每个后移</li>
</ul>
<p>求最大价值</p>
</blockquote>
<p>想了一下模拟了几个数据没有什么思路，唯一发现的性质就是它换了个寂寞，反正相对位置永远不变的。</p>
<p>想不到什么思路人又比较浮躁，于是直接大力 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">exFTT(extand</mtext><mtext> </mtext><mtext mathvariant="monospace">Fast</mtext><mtext> </mtext><mtext mathvariant="monospace">Tanweitan</mtext><mtext> </mtext><mtext mathvariant="monospace">Transform)</mtext></mrow><annotation encoding="application/x-tex">\texttt{exFTT(extand Fast Tanweitan Transform)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord texttt">exFTT(extand Fast Tanweitan Transform)</span></span></span></span></span>, 就是从头开始随机每个选不选，一波计算后发现期望最多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span> 次就可以构成一次操作，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 才 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> , 所以跑个几十万次没有问题。</p>
<p>然后……一下就被卡掉了。</p>
<p>因为从头开始选第一次选到后面的概率很小。于是就想着又随机每次从前还是从后开始，但是……对于分数来说还是没有任何用处，都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>, twt 直接无脑随机都有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>。</p>
<p>代码留作纪念吧，警示以后不要这么干了。</p>
<pre><code class="language-cpp">// Powered by exFTT(extand Fast Tanweitan Transform)
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt; 
#include &lt;algorithm&gt;
int n, ans, D;
bool vis[55];
struct twt { int l, d; } a[55];
int inc(int &amp;x) {
	x ++;
	if(x &gt; n) x = 1;
}
bool check(int x) {
	for(int j = 1; j &lt;= n; j++, D++) 
		if(!vis[j] &amp;&amp; a[j].l &lt;= x) return true;
	return false;
}
int main() {
	srand(time(0));
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i].l, &amp;a[i].d);
	while(D &lt; 50000000) {
		for(int j = 1; j &lt;= n; j++) vis[j] = 0;
		int now = 1, j = 1, num = n, an = 0;
		while(check(num)) {
			for( ; vis[j] || a[j].l &gt; num; inc(j), D++) ;
			if(rand()%2 == 0) { inc(j); continue; }
			an += a[j].d;
			int tmp = a[j].l;
			for(int cnt = 1; cnt &lt;= tmp; inc(j)) cnt += !vis[j], vis[j] = 1, D++,  num--;
		}
		ans = std::max(ans, an);
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
<p>然后是令人震惊的正解：直接 01 背包！</p>
<p>讲一下为什么：</p>
<ol>
<li>若选出来的一堆的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 大于了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那肯定没救了</li>
<li>若选出来的一堆 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,  那么肯定有一种方案可以选到这些所有，因为总有一个不会和其它接上。</li>
</ol>
<p>所以这就是一个 01 背包了。</p>
<h2 id="c">C</h2>
<p>不会。</p>
<h2 id="反思">反思</h2>
<p>感觉 B 题没做出来和我平时做了一会儿做不出就去看题解的做题习惯有很大的关系，失去了长时间思考的能力，就仿佛碎片化的阅读让人失去了读整本书的能力一样。</p>
<p>整天做些体力劳动远大于脑力劳动的练习是没有意义的，这样子追求所谓的过题量让算法竞赛本身的魅力丧失殆尽，此之谓失其本心。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 逛庙会]]></title>
        <id>https://acfboy.pw/guang-miao-hui/</id>
        <link href="https://acfboy.pw/guang-miao-hui/">
        </link>
        <updated>2021-04-17T00:07:58.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2238">传送门</a></p>
<p>状压 dp 的好题目，巧妙利用状压传递了有后效性的信息从而消除了后效性。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2238">传送门</a></p>
<p>状压 dp 的好题目，巧妙利用状压传递了有后效性的信息从而消除了后效性。</p>
<!-- more -->
<p>这题如果没有取周围的那么很容易想到一个 dp, 但由于会取周围的而且还要选出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个，所以有后效性，尝试通过改变 dp 的顺序来消除后效性，但是很遗憾，没有用。</p>
<p><s>所以上 老板dp/快速谭炜谭变换 吧。</s></p>
<p>然后我就没辙了，去看了 kkk 的题解，不得不说 kkk 的题解写得 <s>糟透了</s> <strong>真的好</strong>，非常考验读者的思维能力，不自己想根本就看不懂。</p>
<p>另一个解决后效性的方式：将需要记录的信息加入到状态中。</p>
<p>但知道了这一点要做这一题还是非常有难度，这题的状态还是很妙的。</p>
<p>考虑什么情况下是这题的难点，比如说要走如下的路径：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>→</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>→</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext mathvariant="sans-serif">twt</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>↓</mo></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}
\rightarrow &amp; \rightarrow \\
\textsf{twt} &amp; \downarrow
\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">→</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord textsf">twt</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">→</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">↓</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<p>那么 <code>twt</code> 的价值在两次中都可能被算进去，应该如何把取/没取的信息传递下去呢？这里有一个非常妙的做法，就是对于一个点，我们状压它 左下/下/右/右上 的状态。</p>
<p>这样子有什么的好处？那就是我们可以传递这样的一个状态了！</p>
<p>向右转移的时候必须保证其左下和原来的下是一样的，向下转移时保证新的右和原来的右下是一样的，这样子就可以把转角的信息（就是 <code>twt</code>）给不断传递了。</p>
<p>记得需要判断的是当前经过位置是一定要取的，然后还要取超过一个。</p>
<p>转移的时候只要加上相应的东西就可以了，因为剩下的都在其它的状态中判断过取不取的问题了，由于取了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span>, 可以保证其正确性。</p>
<p>代码：</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
const int N = 1005;
int n, m, sh[N][N], f[N][N][16];
int cnt[16] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4}; 
// 二进制中 1 的个数
char s[N];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	memset(f, 0x3f, sizeof f);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%s&quot;, s+1);
		for(int j = 1; j &lt;= m; j++) sh[i][j] = (s[j] == '.' ? 0 : (s[j] - '0'));
	}
	f[1][1][15] = 0;
	for(int i = 1; i &lt;= n; i++) 
		for(int j = 1; j &lt;= m; j++)
			for(int k = 0; k &lt; 16; k++) {
				for(int k2 = 0; k2 &lt; 16; k2++) {
					if(((k&amp;4)==0) != ((k2&amp;8)==0) || !(k&amp;2) || cnt[k&amp;1] + cnt[k2&amp;6] &lt;= 1) continue;
					int cost = f[i][j][k];
					if(k2 &amp; 1) cost += sh[i+2][j-1];
					if(k2 &amp; 2) cost += sh[i+2][j];
					if(k2 &amp; 4) cost += sh[i+1][j+1];
					f[i+1][j][k2] = std::min(f[i+1][j][k2], cost);
				}
				for(int k2 = 0; k2 &lt; 16; k2++) {
					if(((k&amp;2)==0) != ((k2&amp;1)==0) || !(k&amp;4) || cnt[k&amp;8] + cnt[k2&amp;6] &lt;= 1) continue;
					int cost = f[i][j][k];
					if(k2 &amp; 8) cost += sh[i-1][j+2];
					if(k2 &amp; 4) cost += sh[i][j+2];
					if(k2 &amp; 2) cost += sh[i+1][j+1];
					f[i][j+1][k2] = std::min(f[i][j+1][k2], cost);
				}
			}
	printf(&quot;%d&quot;, f[n][m][15]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC037E] Reversing and Concatenating]]></title>
        <id>https://acfboy.pw/agc037e/</id>
        <link href="https://acfboy.pw/agc037e/">
        </link>
        <updated>2021-04-16T06:14:11.000Z</updated>
        <summary type="html"><![CDATA[<p>总算是自己做了一道 AGC，没有浪费 AGC 的妙妙题了。以前看题解把这么好的题目都浪费掉了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>总算是自己做了一道 AGC，没有浪费 AGC 的妙妙题了。以前看题解把这么好的题目都浪费掉了。</p>
<!-- more -->
<blockquote>
<p>操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次，每次将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 复制一份反转一遍拼在其后面，从新字符串中取一个子串作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>。求操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次后字典序最小的字符串。</p>
</blockquote>
<p>首先想到只进行一步这样的操作，显然是要把最小的那个在一起最长的取走，若有相同长度，那么后面的字典序要尽可能的小。</p>
<p>那么要进行更多的步骤怎么做呢，显然每次把最小的放在头上是不合理的，因为只有尾部的会被复制，而一次操作可以把任意一段扔到队尾或放到开头，所以除了开头可结尾，让最小的字母组成的一段放在最末尾肯定是最优的。</p>
<p>但如果存在同样的几组的怎么办呢，模拟几个小的数据观察就会发现，复制后前面的一段就会反过来拼在最小的那段复制完的后面，而这一段是永远不会变的。</p>
<p>比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="sans-serif">twtwa</mtext><mo>→</mo><mrow><mtext mathvariant="sans-serif">t</mtext><munder accentunder="true"><mtext mathvariant="sans-serif">wtwaa</mtext><mo stretchy="true">‾</mo></munder><mtext mathvariant="sans-serif">wtwt</mtext></mrow><mo>→</mo><mrow><mtext mathvariant="sans-serif">wt</mtext><munder accentunder="true"><mtext mathvariant="sans-serif">waaaa</mtext><mo stretchy="true">‾</mo></munder><mtext mathvariant="sans-serif">wtw</mtext></mrow><mo>→</mo><mtext mathvariant="sans-serif">aaaaw</mtext></mrow><annotation encoding="application/x-tex">\textsf{twtwa}\rightarrow  \textsf{t\underline{wtwaa}wtwt}\rightarrow \textsf{wt\underline{waaaa}wtw} \rightarrow \textsf{aaaaw}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.57143em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">twtwa</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7714300000000001em;vertical-align:-0.2em;"></span><span class="mord text"><span class="mord textsf">t</span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.57143em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textsf">w</span><span class="mord textsf">t</span><span class="mord textsf">w</span><span class="mord textsf">a</span><span class="mord textsf">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span><span class="mord textsf">wtwt</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77143em;vertical-align:-0.19999999999999996em;"></span><span class="mord text"><span class="mord textsf">wt</span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.44444000000000006em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textsf">w</span><span class="mord textsf">a</span><span class="mord textsf">a</span><span class="mord textsf">a</span><span class="mord textsf">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19999999999999996em;"><span></span></span></span></span></span><span class="mord textsf">wtw</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">aaaaw</span></span></span></span></span></p>
<p>虽然最后结果中前面的 <code>a</code> 的数量增加了，但最后一直是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="sans-serif">wtwt</mtext></mrow><annotation encoding="application/x-tex">\textsf{wtwt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.57143em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">wtwt</span></span></span></span></span> 后面减少掉了一些，所以若开始时最小的字母组成的一块 <strong>前面一段倒过来</strong> 的字典序是最小的，变换后肯定也是最小的。</p>
<p>所以我们就有了以下做法：</p>
<ol>
<li>使用一步将最小的字母组成的最长的块（相同的取前面一段倒过来字典序最小的）移到最后。</li>
<li>按题目要求进行变换，同时保证最小的字母组成的一块在最后。</li>
<li>使用最后一步将最小的字母组成的移动到字符串最前面。</li>
</ol>
<p>需要注意的是，开始时取的前面一段字典序最小是要在复制后的意义下复制出来的部分前面一段字典序最小，因为那才是我们实际上取的，由于复制意义下才是我们真正取的，所以还要判断最后的几个字符复制以后成为最长的最小字母组成的一块的情况（因为这个调了很久）。</p>
<p>在第二步模拟时如果最小字母组成的那块长度已经大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, 就不用继续了。这条性质保证了时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的。（但第一步处理需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的时候要进行特判，因为没有机会让我们执行前两步了。</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
int n, k;
std::string s;
int main() {
	std::cin &gt;&gt; n &gt;&gt; k;
	std::cin &gt;&gt; s;
	char min = 'z';
	for(int i = 0; i &lt; n; i++) min = std::min(min, s[i]);
	int maxj = 0, maxs = 0;
	std::string minpre;
	for(int i = 0; i &lt; n; i++) minpre += 'z'+1;
	for(int i = n-1; i &gt;= 0; i--) 
		if(s[i] == min) {
			int cnt = 0, j = i;
			for( ; j &gt;= 0 &amp;&amp; s[j] == min; cnt++, j--) ;
			std::string tmp1 = s.substr(j+1, n-1-j-1+1);
			std::string tmp2 = s.substr(n-j-1, n-n+j+1+1);
			std::reverse(tmp2.begin(), tmp2.end());
			std::string twt = tmp1 + tmp2;
			if(cnt &gt; maxs || cnt == maxs &amp;&amp; twt &lt; minpre) 
				maxs = cnt, maxj = j, minpre = twt;
		}	
	int j = n-1, cnt = 0;
	for( ; j &gt;= 0 &amp;&amp; s[j] == min; j--, cnt++) ;
	std::string tm = s.substr(n-j-1, j+1) + s.substr(j+1, n-j-1);
	std::reverse(tm.begin(), tm.end());
	if(cnt*2 &gt; maxs || cnt*2 == maxs &amp;&amp; tm &lt; minpre) maxs = cnt, maxj = j, minpre = tm;
	maxj ++;
	std::string t;
	t = s;
	std::reverse(t.begin(), t.end());
	s = s + t;
	if(k == 1) {
		s = s.substr(maxj, n);
		std::cout &lt;&lt; s;
		return 0;
	}
	if(maxj + maxs != n) {
		s = s.substr(n-maxj, n);
		k -= 1;
	}
	for(int i = 1; i &lt; k; i++) {
		t = s;
		std::reverse(t.begin(), t.end());
		s = s + t;
		s = s.substr(maxs, n);
		maxs &lt;&lt;= 1;
		if(maxs &gt;= n) break; 
	}
	if(maxs &gt; n) maxs = n;
	t = s;
	std::reverse(t.begin(), t.end());
	s = s + t;
	s = s.substr(n-maxs, n);
	std::cout &lt;&lt; s;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC017E] Jigsaw]]></title>
        <id>https://acfboy.pw/agc017e/</id>
        <link href="https://acfboy.pw/agc017e/">
        </link>
        <updated>2021-04-15T06:25:24.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT2668">题目翻译传送门</a></p>
<p>这题其实十分的妙，尽管代码很短，但确实对得起它紫题的难度。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT2668">题目翻译传送门</a></p>
<p>这题其实十分的妙，尽管代码很短，但确实对得起它紫题的难度。</p>
<!-- more -->
<p>看到这样的一道题，首先一个很自然的想法就是按照能拼上的关系建图，然后通过一个神奇的方式找到一条路径。</p>
<p>但这样一来光建图就需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的时间，没有办法满足题目的需要。然后发现虽然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 很大，但是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 是很小的，那么下一个想法是，能不能使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 进行建图。</p>
<p>然后就有一个很妙的转换方式，其它题解里讲了一些转换为负的方法，很妙，其实不用这样，还得去处理负下标的问题，只需要确保两种会被映射到不相交的区间里就可以了，所以这样转化就可以了：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">r = d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>, 否则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">r = b+h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>。</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>c</mi><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">l = c+h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 否则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">l = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。</li>
</ul>
<p>经过这样的转换，右边的若和左边可以相接，它们就会变成一个一样的值，然后就可以用一条边来表示一块积木，这样边数和点数都在一个可接受的范围内。</p>
<p>然后就是要到若干条路径从小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点到大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点并经过所有边的问题了，找到经过每一条边的路径那么直接就可以想到欧拉回路，但这题目中不要求回到原点，也不一定是全部连通的（对应原来的积木中不一定全部是以凹凸的方式拼接的），所以又有了一个很巧妙的构造方式。</p>
<p>建立一个新的点，对于要构造的每一段路径将这个新点和它起点相连，在把终点与新点相连，然后找到一条欧拉回路，在把这新脸上的边和点给去掉就可以了。</p>
<p>所以可以根据欧拉回路要求满足的条件来判断是否能构造成功。有向图有欧拉回路的条件是每个点入度等于出度。</p>
<ol>
<li>对于小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点， 入度要小于等于出度，因为构造的时候还要和新点连边， 但不一定是最多只能小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 因为我们要找出若干条路径而不一定只有一条。</li>
<li>对于大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点同理。</li>
<li>每一块至少得有一个点入度出度不相等，因为全相等了再和新点连边就没有欧拉回路了。</li>
</ol>
<p>满足以上条件的就可以按上面数的构造出来，不满足的就肯定 <code>No</code> 了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
const int H = 405;
int n, h, fa[H], a, b, c, d, l, r, in[H], out[H], ok[H];
int find(int x) {
	if(x != fa[x]) fa[x] = find(fa[x]);
	return fa[x];
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;h);
	for(int i = 1; i &lt;= 2*h; i++) fa[i] = i;
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
		if(d) r = d; else r = b+h;
		if(c) l = c+h; else l = a;
		out[l] ++, in[r] ++;
		int fx = find(l), fy = find(r);
		if(fx == fy) continue;
		fa[fx] = fy;
	}
	for(int i = 1; i &lt;= h; i++) if(in[i] &gt; out[i]) return puts(&quot;NO&quot;), 0;
	for(int i = h+1; i &lt;= 2*h; i++) if(in[i] &lt; out[i]) return puts(&quot;NO&quot;), 0;
	for(int i = 1; i &lt;= 2*h; i++) if(in[i] != out[i] || !in[i] &amp;&amp; !out[i]) ok[find(i)] = 1;
	for(int i = 1; i &lt;= 2*h; i++) if(fa[i] == i &amp;&amp; !ok[i]) return puts(&quot;NO&quot;), 0;
	puts(&quot;YES&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.14 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210414/</id>
        <link href="https://acfboy.pw/20210414/">
        </link>
        <updated>2021-04-15T00:03:30.000Z</updated>
        <summary type="html"><![CDATA[<p>All Killed.</p>
]]></summary>
        <content type="html"><![CDATA[<p>All Killed.</p>
<!-- more -->
<h2 id=""><a href="https://imgtu.com/i/cguzND"><img src="https://z3.ax1x.com/2021/04/15/cguzND.png" alt="cguzND.png" loading="lazy"></a></h2>
<p>题目比较简单，没啥好说。</p>
<p>罚时最小，拿到榜一还是比较开心的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2010]巡逻]]></title>
        <id>https://acfboy.pw/apio2010xunluo/</id>
        <link href="https://acfboy.pw/apio2010xunluo/">
        </link>
        <updated>2021-04-15T00:01:38.000Z</updated>
        <summary type="html"><![CDATA[<p>一个有些妙的想法，刷新了我对树的直径的一些认知。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个有些妙的想法，刷新了我对树的直径的一些认知。</p>
<!-- more -->
<blockquote>
<p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号店出发遍历每一条路，再回到起点， 可以添加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 条边，问最小的经过边的次数。必须要经过加上的边。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">K \in[1, 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></p>
</blockquote>
<p>考虑加上一条边改变了什么。显然，本来要一个个退回去的现在直达就好了，中间那些边都减掉了，那么减掉的越多越好，把直径俩端点一连完事儿。</p>
<p>重点在如何连第二条。</p>
<ol>
<li>若环不重合，那么直接再来一条新直径就可以了。</li>
<li>若重合，因为新建的是必需要跑的，环上重合的也就必需跑两次，等于对于那些东西，第一条就白连了。</li>
</ol>
<p>怎么解决？</p>
<p>很妙：把第一次直径上的边权改成负的然后直接求直径就可以了。</p>
<p>很妙，想不到，但告诉你了就很好理解了。</p>
<p>注意有负权的直径就不能使用 dfs 了，只能 dp，因为证明中那个交点就不能断开重组了，因为可以能一边负的而另一边有很多正的。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
const int N = 100005, M = 2*N;
int n, k, x, y, S, T, len[M], vet[M], next[M], head[N],
	dis[N], f[N], tmax, num, dep[N];
void add(int x, int y, int c) {
	num++;
	vet[num] = y, len[num] = c;
	next[num] = head[x];
	head[x] = num;
}
void dfs(int u, int fa, int &amp;x) {
	if(dis[u] &gt; dis[x]) x = u;
	f[u] = fa;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(v == fa) continue;
		dis[v] = dis[u] + 1;
		dfs(v, u, x);
	}
}
void change(int u, int v) {
	for(int i = head[u]; i; i = next[i]) {
		int vv = vet[i];
		if(vv == v) { len[i] = -1; break; }
	}
}
void dp(int u, int fa, int &amp;x) {
	int max = -N, sax = -N;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(v == fa) continue;
		dp(v, u, x);
		dep[u] = std::max(dep[u], dep[v] + len[i]);
		if(dep[v]+len[i] &gt; max) sax = max, max = dep[v]+len[i];
		else if(dep[v]+len[i] &gt; sax) sax = dep[v]+len[i];
	}
	// if(u == 5) printf(&quot;*%d %d\n&quot;, max, sax);
	if(sax == -N) sax = 0;
	x = std::max(x, max + sax);
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt; n; i++) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		add(x, y, 1), add(y, x, 1);
	}
	if(k == 1) {
		dfs(1, 0, S);
		memset(dis, 0, sizeof dis);
		dfs(S, 0, T);
		printf(&quot;%d\n&quot;, 2*n - dis[T] - 1);
	}
	else {
		dfs(1, 0, S);
		memset(dis, 0, sizeof dis);
		dfs(S, 0, T);
		int L1 = dis[T], L2 = 0;
		for(int now = T; now != S; now = f[now]) change(now, f[now]), change(f[now], now);
		dp(1, 0, L2);
		// printf(&quot;*%d\n&quot;, L2);
		printf(&quot;%d\n&quot;, n*2 - L1 - L2);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 上帝造题的七分钟2]]></title>
        <id>https://acfboy.pw/shang-di-zao-ti-de-qi-fen-zhong-2/</id>
        <link href="https://acfboy.pw/shang-di-zao-ti-de-qi-fen-zhong-2/">
        </link>
        <updated>2021-04-14T23:33:23.000Z</updated>
        <summary type="html"><![CDATA[<p>这题和上次有一场 CF 的 C 题有那么一些异曲同工之妙。</p>
<p>还巧妙运用了并查集。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这题和上次有一场 CF 的 C 题有那么一些异曲同工之妙。</p>
<p>还巧妙运用了并查集。</p>
<!-- more -->
<blockquote>
<p>输入一个序列，维护两种操作，查询一段区间内数的和 以及 对一段区间内的所有数开方。</p>
</blockquote>
<p>虽然不会支持开方的神奇数据结构，但开方是一个很好的运算，因为开方没几次就会到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 以下，这样就没有继续开方的必要了。</p>
<p>所以考虑怎么跳过这样的一个过程。</p>
<p>大概是要使用一种类似链表的东西，如果变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 了就直接链接到下一个，并且能够把这种下一个的都合起来到最后，那么并查集就非常的合适了，路径压缩的过程就是合起来的过程。</p>
<p>这里还有一个小 trick，那就是如果一个变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 把它之前的连到后面的可能会有更多细节问题要处理，比如说这样的连接交叉的时候。那么其实跳过不用这么严格，头尾都改一下也就两次，所以只需要把这个连接到下一个就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define int long long
const int N = 100005;
int a[N], fa[N], n, q, opt, l, r, t[N];
int Query(int x) {
	int an = 0;
	while(x) {
		an += t[x];
		x -= x &amp; -x;
	}
	return an;
}
void add(int p, int x) {
	while(p &lt;= n) {
		t[p] += x;
		p += p &amp; -p;
	}
}
int find(int x) {
	if(x != fa[x]) fa[x] = find(fa[x]);
	return fa[x];
}
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), fa[i] = i, add(i, a[i]);
	scanf(&quot;%lld&quot;, &amp;q);
	while(q--) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;opt, &amp;l, &amp;r);
		if(l &gt; r) std::swap(l, r);
		if(opt == 1) printf(&quot;%lld\n&quot;, Query(r) - Query(l-1));
		else {
			int i = l;
			while(i &lt;= r) {
				add(i, (int)sqrt(a[i]) - a[i]);
				a[i] = (int)sqrt(a[i]);
				fa[i] = (a[i] &lt;= 1) ? (i+1) : i;
				i = (fa[i] == i) ? (i+1) : find(fa[i]);
			}
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2009]抢掠计划]]></title>
        <id>https://acfboy.pw/apio2019qiangluejihua/</id>
        <link href="https://acfboy.pw/apio2019qiangluejihua/">
        </link>
        <updated>2021-04-14T23:32:18.000Z</updated>
        <summary type="html"><![CDATA[<p>很久很久以前就想学缩点，现在因为这题终于学会了 tarjan 求强联通分量和缩点。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很久很久以前就想学缩点，现在因为这题终于学会了 tarjan 求强联通分量和缩点。</p>
<!-- more -->
<blockquote>
<p>给定一个有向图，每个节点都可以通过无限次，但上面的权值只能加一次，求从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始到一些点结束经过的节点权值和最大。</p>
</blockquote>
<p>如果这是一张有向无环图，那么我们肯定可以利用拓扑排序来愉快地 dp 求出这个答案。</p>
<p>但这不是一张有向无环图，缩点就是这样一种算法，可以将图中互相联通的一坨点缩成一个，使图变成 DAG，让你可以愉快地 dp。</p>
<p>现在来讲一讲 tarjan 算法。</p>
<p>这个算法的主要思想是这样的：</p>
<ol>
<li>dfs 一遍，记录 dfs 序，记作 <code>dfn</code>, 记录当前一个点可以连到最小 dfs 序，记作 <code>low</code></li>
<li>在 dfs 的过程中，先标记当前点被访问，然后将其加入栈中，更新时若连到的点没有 dfs 过，那么就 dfs 下去，然后更新 <code>low</code>, 不然只更新 <code>low</code>。</li>
<li>若 <code>dfn == low</code> 那么现在栈中的点就是一个强联通分量中的点了，把它们弹出做你想要的操作，然后都标记成未访问就可以了。</li>
</ol>
<p>这样的做法为什么是对的？</p>
<p>首先，如果连到了当前 dfs 到这点的路径上的点，那么肯定可以回去再来就是互相到达了，所以我们把点都塞进栈中，并且用 <code>low</code> 来做到识别是否连回去到更早的。</p>
<p>如果不是在 dfs 树上最早被抵达的强联通分量的点肯定 <code>dfn</code> 不和 <code>low</code> 相等，反之肯定相等，我们可以用这个性质来缩点，把其它点的性质都加入到这个最早被访问到的点上。栈就是为了记录这样的一些点。</p>
<p>然后为什么要把强联通分块中的标记成未访问呢？因为搜索树上不是向自己的祖先，而是横叉出去的边肯定不会和其它边构成环，所以把它们都取消可以成为强联通分量的资格，从候选的栈中弹出。</p>
<p>会缩点了一个就是一个拓扑排序和 dp 就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
const int N = 500005, M = N;
int vet[M], uet[M], next[M], head[N], vet2[M], next2[M], head2[N], num, num2,
	low[N], dfn[N], vis[N], c[N], scc[N], n, m, x, y, in[N], sum[N], tim, s, p;
std::queue&lt;int&gt; q;
std::stack&lt;int&gt; st;
void add(int u, int v) {
	vet[++num] = v; uet[num] = u;
	next[num] = head[u];
	head[u] = num;
}
void add2(int u, int v) {
	in[v] ++;
	vet2[++num2] = v; 
	next2[num2] = head2[u];
	head2[u] = num2;
}
void dfs(int u) {
	low[u] = dfn[u] = ++tim;
	st.push(u);
	vis[u] = 1;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(!dfn[v]) {
			dfs(v);
			low[u] = std::min(low[u], low[v]);
		}
		else if(vis[v]) low[u] = std::min(low[u], low[v]);
	}
	if(dfn[u] == low[u]) {
		int now;
		while(!st.empty()) {
			now = st.top();
			st.pop();
			scc[now] = u;
			vis[now] = 0;
			if(now == u) break;
			c[u] += c[now];
		}
	}
}
int topo() {
	q.push(scc[s]);
	sum[scc[s]] = c[scc[s]];
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for(int i = head2[u]; i; i = next2[i]) {
			int v = vet2[i];
			sum[v] = std::max(sum[v], sum[u] + c[v]);
			in[v] --;
			if(in[v] == 0) q.push(v);
		}
	}
	int ans = 0;
	for(int i = 1; i &lt;= p; i++) {
		scanf(&quot;%d&quot;, &amp;x);
		ans = std::max(ans, sum[scc[x]]);
	}
	return ans;
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		add(x, y);
	}
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;c[i]);
	scanf(&quot;%d%d&quot;, &amp;s, &amp;p);
	dfs(s);
	for(int i = 1; i &lt;= n; i++) {
		if(scc[i] == 0) continue;
		for(int j = head[i]; j; j = next[j]) 
			if(scc[vet[j]] &amp;&amp; scc[vet[j]] != scc[i]) add2(scc[i], scc[vet[j]]);
	}
	printf(&quot;%d&quot;, topo());
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>