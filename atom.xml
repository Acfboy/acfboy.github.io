<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的小站</title>
    <updated>2021-04-16T06:31:58.225Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的小站</rights>
    <entry>
        <title type="html"><![CDATA[题解 [AGC037E] Reversing and Concatenating]]></title>
        <id>https://acfboy.pw/agc037e/</id>
        <link href="https://acfboy.pw/agc037e/">
        </link>
        <updated>2021-04-16T06:14:11.000Z</updated>
        <summary type="html"><![CDATA[<p>总算是自己做了一道 AGC，没有浪费 AGC 的妙妙题了。以前看题解把这么好的题目都浪费掉了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>总算是自己做了一道 AGC，没有浪费 AGC 的妙妙题了。以前看题解把这么好的题目都浪费掉了。</p>
<!-- more -->
<blockquote>
<p>操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次，每次将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 复制一份反转一遍拼在其后面，从新字符串中取一个子串作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>。求操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次后字典序最小的字符串。</p>
</blockquote>
<p>首先想到只进行一步这样的操作，显然是要把最小的那个在一起最长的取走，若有相同长度，那么后面的字典序要尽可能的小。</p>
<p>那么要进行更多的步骤怎么做呢，显然每次把最小的放在头上是不合理的，因为只有尾部的会被复制，而一次操作可以把任意一段扔到队尾或放到开头，所以除了开头可结尾，让最小的字母组成的一段放在最末尾肯定是最优的。</p>
<p>但如果存在同样的几组的怎么办呢，模拟几个小的数据观察就会发现，复制后前面的一段就会反过来拼在最小的那段复制完的后面，而这一段是永远不会变的。</p>
<p>比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="sans-serif">twtwa</mtext><mo>→</mo><mrow><mtext mathvariant="sans-serif">t</mtext><munder accentunder="true"><mtext mathvariant="sans-serif">wtwaa</mtext><mo stretchy="true">‾</mo></munder><mtext mathvariant="sans-serif">wtwt</mtext></mrow><mo>→</mo><mrow><mtext mathvariant="sans-serif">wt</mtext><munder accentunder="true"><mtext mathvariant="sans-serif">waaaa</mtext><mo stretchy="true">‾</mo></munder><mtext mathvariant="sans-serif">wtw</mtext></mrow><mo>→</mo><mtext mathvariant="sans-serif">aaaaw</mtext></mrow><annotation encoding="application/x-tex">\textsf{twtwa}\rightarrow  \textsf{t\underline{wtwaa}wtwt}\rightarrow \textsf{wt\underline{waaaa}wtw} \rightarrow \textsf{aaaaw}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.57143em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">twtwa</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7714300000000001em;vertical-align:-0.2em;"></span><span class="mord text"><span class="mord textsf">t</span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.57143em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textsf">w</span><span class="mord textsf">t</span><span class="mord textsf">w</span><span class="mord textsf">a</span><span class="mord textsf">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span><span class="mord textsf">wtwt</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77143em;vertical-align:-0.19999999999999996em;"></span><span class="mord text"><span class="mord textsf">wt</span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.44444000000000006em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textsf">w</span><span class="mord textsf">a</span><span class="mord textsf">a</span><span class="mord textsf">a</span><span class="mord textsf">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19999999999999996em;"><span></span></span></span></span></span><span class="mord textsf">wtw</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">aaaaw</span></span></span></span></span></p>
<p>虽然最后结果中前面的 <code>a</code> 的数量增加了，但最后一直是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="sans-serif">wtwt</mtext></mrow><annotation encoding="application/x-tex">\textsf{wtwt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.57143em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">wtwt</span></span></span></span></span> 后面减少掉了一些，所以若开始时最小的字母组成的一块 <strong>前面一段倒过来</strong> 的字典序是最小的，变换后肯定也是最小的。</p>
<p>所以我们就有了以下做法：</p>
<ol>
<li>使用一步将最小的字母组成的最长的块（相同的取前面一段倒过来字典序最小的）移到最后。</li>
<li>按题目要求进行变换，同时保证最小的字母组成的一块在最后。</li>
<li>使用最后一步将最小的字母组成的移动到字符串最前面。</li>
</ol>
<p>需要注意的是，开始时取的前面一段字典序最小是要在复制后的意义下复制出来的部分前面一段字典序最小，因为那才是我们实际上取的，由于复制意义下才是我们真正取的，所以还要判断最后的几个字符复制以后成为最长的最小字母组成的一块的情况（因为这个调了很久）。</p>
<p>在第二步模拟时如果最小字母组成的那块长度已经大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, 就不用继续了。这条性质保证了时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的。（但第一步处理需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的时候要进行特判，因为没有机会让我们执行前两步了。</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
int n, k;
std::string s;
int main() {
	std::cin &gt;&gt; n &gt;&gt; k;
	std::cin &gt;&gt; s;
	char min = 'z';
	for(int i = 0; i &lt; n; i++) min = std::min(min, s[i]);
	int maxj = 0, maxs = 0;
	std::string minpre;
	for(int i = 0; i &lt; n; i++) minpre += 'z'+1;
	for(int i = n-1; i &gt;= 0; i--) 
		if(s[i] == min) {
			int cnt = 0, j = i;
			for( ; j &gt;= 0 &amp;&amp; s[j] == min; cnt++, j--) ;
			std::string tmp1 = s.substr(j+1, n-1-j-1+1);
			std::string tmp2 = s.substr(n-j-1, n-n+j+1+1);
			std::reverse(tmp2.begin(), tmp2.end());
			std::string twt = tmp1 + tmp2;
			if(cnt &gt; maxs || cnt == maxs &amp;&amp; twt &lt; minpre) 
				maxs = cnt, maxj = j, minpre = twt;
		}	
	int j = n-1, cnt = 0;
	for( ; j &gt;= 0 &amp;&amp; s[j] == min; j--, cnt++) ;
	std::string tm = s.substr(n-j-1, j+1) + s.substr(j+1, n-j-1);
	std::reverse(tm.begin(), tm.end());
	if(cnt*2 &gt; maxs || cnt*2 == maxs &amp;&amp; tm &lt; minpre) maxs = cnt, maxj = j, minpre = tm;
	maxj ++;
	std::string t;
	t = s;
	std::reverse(t.begin(), t.end());
	s = s + t;
	if(k == 1) {
		s = s.substr(maxj, n);
		std::cout &lt;&lt; s;
		return 0;
	}
	if(maxj + maxs != n) {
		s = s.substr(n-maxj, n);
		k -= 1;
	}
	for(int i = 1; i &lt; k; i++) {
		t = s;
		std::reverse(t.begin(), t.end());
		s = s + t;
		s = s.substr(maxs, n);
		maxs &lt;&lt;= 1;
		if(maxs &gt;= n) break; 
	}
	if(maxs &gt; n) maxs = n;
	t = s;
	std::reverse(t.begin(), t.end());
	s = s + t;
	s = s.substr(n-maxs, n);
	std::cout &lt;&lt; s;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC017E] Jigsaw]]></title>
        <id>https://acfboy.pw/agc017e/</id>
        <link href="https://acfboy.pw/agc017e/">
        </link>
        <updated>2021-04-15T06:25:24.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT2668">题目翻译传送门</a></p>
<p>这题其实十分的妙，尽管代码很短，但确实对得起它紫题的难度。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT2668">题目翻译传送门</a></p>
<p>这题其实十分的妙，尽管代码很短，但确实对得起它紫题的难度。</p>
<!-- more -->
<p>看到这样的一道题，首先一个很自然的想法就是按照能拼上的关系建图，然后通过一个神奇的方式找到一条路径。</p>
<p>但这样一来光建图就需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的时间，没有办法满足题目的需要。然后发现虽然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 很大，但是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 是很小的，那么下一个想法是，能不能使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 进行建图。</p>
<p>然后就有一个很妙的转换方式，其它题解里讲了一些转换为负的方法，很妙，其实不用这样，还得去处理负下标的问题，只需要确保两种会被映射到不相交的区间里就可以了，所以这样转化就可以了：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">r = d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>, 否则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">r = b+h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>。</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>c</mi><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">l = c+h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 否则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">l = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。</li>
</ul>
<p>经过这样的转换，右边的若和左边可以相接，它们就会变成一个一样的值，然后就可以用一条边来表示一块积木，这样边数和点数都在一个可接受的范围内。</p>
<p>然后就是要到若干条路径从小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点到大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点并经过所有边的问题了，找到经过每一条边的路径那么直接就可以想到欧拉回路，但这题目中不要求回到原点，也不一定是全部连通的（对应原来的积木中不一定全部是以凹凸的方式拼接的），所以又有了一个很巧妙的构造方式。</p>
<p>建立一个新的点，对于要构造的每一段路径将这个新点和它起点相连，在把终点与新点相连，然后找到一条欧拉回路，在把这新脸上的边和点给去掉就可以了。</p>
<p>所以可以根据欧拉回路要求满足的条件来判断是否能构造成功。有向图有欧拉回路的条件是每个点入度等于出度。</p>
<ol>
<li>对于小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点， 入度要小于等于出度，因为构造的时候还要和新点连边， 但不一定是最多只能小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 因为我们要找出若干条路径而不一定只有一条。</li>
<li>对于大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点同理。</li>
<li>每一块至少得有一个点入度出度不相等，因为全相等了再和新点连边就没有欧拉回路了。</li>
</ol>
<p>满足以上条件的就可以按上面数的构造出来，不满足的就肯定 <code>No</code> 了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
const int H = 405;
int n, h, fa[H], a, b, c, d, l, r, in[H], out[H], ok[H];
int find(int x) {
	if(x != fa[x]) fa[x] = find(fa[x]);
	return fa[x];
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;h);
	for(int i = 1; i &lt;= 2*h; i++) fa[i] = i;
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
		if(d) r = d; else r = b+h;
		if(c) l = c+h; else l = a;
		out[l] ++, in[r] ++;
		int fx = find(l), fy = find(r);
		if(fx == fy) continue;
		fa[fx] = fy;
	}
	for(int i = 1; i &lt;= h; i++) if(in[i] &gt; out[i]) return puts(&quot;NO&quot;), 0;
	for(int i = h+1; i &lt;= 2*h; i++) if(in[i] &lt; out[i]) return puts(&quot;NO&quot;), 0;
	for(int i = 1; i &lt;= 2*h; i++) if(in[i] != out[i] || !in[i] &amp;&amp; !out[i]) ok[find(i)] = 1;
	for(int i = 1; i &lt;= 2*h; i++) if(fa[i] == i &amp;&amp; !ok[i]) return puts(&quot;NO&quot;), 0;
	puts(&quot;YES&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.14 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210414/</id>
        <link href="https://acfboy.pw/20210414/">
        </link>
        <updated>2021-04-15T00:03:30.000Z</updated>
        <summary type="html"><![CDATA[<p>All Killed.</p>
]]></summary>
        <content type="html"><![CDATA[<p>All Killed.</p>
<!-- more -->
<h2 id=""><a href="https://imgtu.com/i/cguzND"><img src="https://z3.ax1x.com/2021/04/15/cguzND.png" alt="cguzND.png" loading="lazy"></a></h2>
<p>题目比较简单，没啥好说。</p>
<p>罚时最小，拿到榜一还是比较开心的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2010]巡逻]]></title>
        <id>https://acfboy.pw/apio2010xunluo/</id>
        <link href="https://acfboy.pw/apio2010xunluo/">
        </link>
        <updated>2021-04-15T00:01:38.000Z</updated>
        <summary type="html"><![CDATA[<p>一个有些妙的想法，刷新了我对树的直径的一些认知。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个有些妙的想法，刷新了我对树的直径的一些认知。</p>
<!-- more -->
<blockquote>
<p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号店出发遍历每一条路，再回到起点， 可以添加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 条边，问最小的经过边的次数。必须要经过加上的边。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">K \in[1, 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></p>
</blockquote>
<p>考虑加上一条边改变了什么。显然，本来要一个个退回去的现在直达就好了，中间那些边都减掉了，那么减掉的越多越好，把直径俩端点一连完事儿。</p>
<p>重点在如何连第二条。</p>
<ol>
<li>若环不重合，那么直接再来一条新直径就可以了。</li>
<li>若重合，因为新建的是必需要跑的，环上重合的也就必需跑两次，等于对于那些东西，第一条就白连了。</li>
</ol>
<p>怎么解决？</p>
<p>很妙：把第一次直径上的边权改成负的然后直接求直径就可以了。</p>
<p>很妙，想不到，但告诉你了就很好理解了。</p>
<p>注意有负权的直径就不能使用 dfs 了，只能 dp，因为证明中那个交点就不能断开重组了，因为可以能一边负的而另一边有很多正的。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
const int N = 100005, M = 2*N;
int n, k, x, y, S, T, len[M], vet[M], next[M], head[N],
	dis[N], f[N], tmax, num, dep[N];
void add(int x, int y, int c) {
	num++;
	vet[num] = y, len[num] = c;
	next[num] = head[x];
	head[x] = num;
}
void dfs(int u, int fa, int &amp;x) {
	if(dis[u] &gt; dis[x]) x = u;
	f[u] = fa;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(v == fa) continue;
		dis[v] = dis[u] + 1;
		dfs(v, u, x);
	}
}
void change(int u, int v) {
	for(int i = head[u]; i; i = next[i]) {
		int vv = vet[i];
		if(vv == v) { len[i] = -1; break; }
	}
}
void dp(int u, int fa, int &amp;x) {
	int max = -N, sax = -N;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(v == fa) continue;
		dp(v, u, x);
		dep[u] = std::max(dep[u], dep[v] + len[i]);
		if(dep[v]+len[i] &gt; max) sax = max, max = dep[v]+len[i];
		else if(dep[v]+len[i] &gt; sax) sax = dep[v]+len[i];
	}
	// if(u == 5) printf(&quot;*%d %d\n&quot;, max, sax);
	if(sax == -N) sax = 0;
	x = std::max(x, max + sax);
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt; n; i++) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		add(x, y, 1), add(y, x, 1);
	}
	if(k == 1) {
		dfs(1, 0, S);
		memset(dis, 0, sizeof dis);
		dfs(S, 0, T);
		printf(&quot;%d\n&quot;, 2*n - dis[T] - 1);
	}
	else {
		dfs(1, 0, S);
		memset(dis, 0, sizeof dis);
		dfs(S, 0, T);
		int L1 = dis[T], L2 = 0;
		for(int now = T; now != S; now = f[now]) change(now, f[now]), change(f[now], now);
		dp(1, 0, L2);
		// printf(&quot;*%d\n&quot;, L2);
		printf(&quot;%d\n&quot;, n*2 - L1 - L2);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 上帝造题的七分钟2]]></title>
        <id>https://acfboy.pw/shang-di-zao-ti-de-qi-fen-zhong-2/</id>
        <link href="https://acfboy.pw/shang-di-zao-ti-de-qi-fen-zhong-2/">
        </link>
        <updated>2021-04-14T23:33:23.000Z</updated>
        <summary type="html"><![CDATA[<p>这题和上次有一场 CF 的 C 题有那么一些异曲同工之妙。</p>
<p>还巧妙运用了并查集。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这题和上次有一场 CF 的 C 题有那么一些异曲同工之妙。</p>
<p>还巧妙运用了并查集。</p>
<!-- more -->
<blockquote>
<p>输入一个序列，维护两种操作，查询一段区间内数的和 以及 对一段区间内的所有数开方。</p>
</blockquote>
<p>虽然不会支持开方的神奇数据结构，但开方是一个很好的运算，因为开方没几次就会到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 以下，这样就没有继续开方的必要了。</p>
<p>所以考虑怎么跳过这样的一个过程。</p>
<p>大概是要使用一种类似链表的东西，如果变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 了就直接链接到下一个，并且能够把这种下一个的都合起来到最后，那么并查集就非常的合适了，路径压缩的过程就是合起来的过程。</p>
<p>这里还有一个小 trick，那就是如果一个变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 把它之前的连到后面的可能会有更多细节问题要处理，比如说这样的连接交叉的时候。那么其实跳过不用这么严格，头尾都改一下也就两次，所以只需要把这个连接到下一个就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define int long long
const int N = 100005;
int a[N], fa[N], n, q, opt, l, r, t[N];
int Query(int x) {
	int an = 0;
	while(x) {
		an += t[x];
		x -= x &amp; -x;
	}
	return an;
}
void add(int p, int x) {
	while(p &lt;= n) {
		t[p] += x;
		p += p &amp; -p;
	}
}
int find(int x) {
	if(x != fa[x]) fa[x] = find(fa[x]);
	return fa[x];
}
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), fa[i] = i, add(i, a[i]);
	scanf(&quot;%lld&quot;, &amp;q);
	while(q--) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;opt, &amp;l, &amp;r);
		if(l &gt; r) std::swap(l, r);
		if(opt == 1) printf(&quot;%lld\n&quot;, Query(r) - Query(l-1));
		else {
			int i = l;
			while(i &lt;= r) {
				add(i, (int)sqrt(a[i]) - a[i]);
				a[i] = (int)sqrt(a[i]);
				fa[i] = (a[i] &lt;= 1) ? (i+1) : i;
				i = (fa[i] == i) ? (i+1) : find(fa[i]);
			}
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2009]抢掠计划]]></title>
        <id>https://acfboy.pw/apio2019qiangluejihua/</id>
        <link href="https://acfboy.pw/apio2019qiangluejihua/">
        </link>
        <updated>2021-04-14T23:32:18.000Z</updated>
        <summary type="html"><![CDATA[<p>很久很久以前就想学缩点，现在因为这题终于学会了 tarjan 求强联通分量和缩点。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很久很久以前就想学缩点，现在因为这题终于学会了 tarjan 求强联通分量和缩点。</p>
<!-- more -->
<blockquote>
<p>给定一个有向图，每个节点都可以通过无限次，但上面的权值只能加一次，求从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始到一些点结束经过的节点权值和最大。</p>
</blockquote>
<p>如果这是一张有向无环图，那么我们肯定可以利用拓扑排序来愉快地 dp 求出这个答案。</p>
<p>但这不是一张有向无环图，缩点就是这样一种算法，可以将图中互相联通的一坨点缩成一个，使图变成 DAG，让你可以愉快地 dp。</p>
<p>现在来讲一讲 tarjan 算法。</p>
<p>这个算法的主要思想是这样的：</p>
<ol>
<li>dfs 一遍，记录 dfs 序，记作 <code>dfn</code>, 记录当前一个点可以连到最小 dfs 序，记作 <code>low</code></li>
<li>在 dfs 的过程中，先标记当前点被访问，然后将其加入栈中，更新时若连到的点没有 dfs 过，那么就 dfs 下去，然后更新 <code>low</code>, 不然只更新 <code>low</code>。</li>
<li>若 <code>dfn == low</code> 那么现在栈中的点就是一个强联通分量中的点了，把它们弹出做你想要的操作，然后都标记成未访问就可以了。</li>
</ol>
<p>这样的做法为什么是对的？</p>
<p>首先，如果连到了当前 dfs 到这点的路径上的点，那么肯定可以回去再来就是互相到达了，所以我们把点都塞进栈中，并且用 <code>low</code> 来做到识别是否连回去到更早的。</p>
<p>如果不是在 dfs 树上最早被抵达的强联通分量的点肯定 <code>dfn</code> 不和 <code>low</code> 相等，反之肯定相等，我们可以用这个性质来缩点，把其它点的性质都加入到这个最早被访问到的点上。栈就是为了记录这样的一些点。</p>
<p>然后为什么要把强联通分块中的标记成未访问呢？因为搜索树上不是向自己的祖先，而是横叉出去的边肯定不会和其它边构成环，所以把它们都取消可以成为强联通分量的资格，从候选的栈中弹出。</p>
<p>会缩点了一个就是一个拓扑排序和 dp 就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
const int N = 500005, M = N;
int vet[M], uet[M], next[M], head[N], vet2[M], next2[M], head2[N], num, num2,
	low[N], dfn[N], vis[N], c[N], scc[N], n, m, x, y, in[N], sum[N], tim, s, p;
std::queue&lt;int&gt; q;
std::stack&lt;int&gt; st;
void add(int u, int v) {
	vet[++num] = v; uet[num] = u;
	next[num] = head[u];
	head[u] = num;
}
void add2(int u, int v) {
	in[v] ++;
	vet2[++num2] = v; 
	next2[num2] = head2[u];
	head2[u] = num2;
}
void dfs(int u) {
	low[u] = dfn[u] = ++tim;
	st.push(u);
	vis[u] = 1;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(!dfn[v]) {
			dfs(v);
			low[u] = std::min(low[u], low[v]);
		}
		else if(vis[v]) low[u] = std::min(low[u], low[v]);
	}
	if(dfn[u] == low[u]) {
		int now;
		while(!st.empty()) {
			now = st.top();
			st.pop();
			scc[now] = u;
			vis[now] = 0;
			if(now == u) break;
			c[u] += c[now];
		}
	}
}
int topo() {
	q.push(scc[s]);
	sum[scc[s]] = c[scc[s]];
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for(int i = head2[u]; i; i = next2[i]) {
			int v = vet2[i];
			sum[v] = std::max(sum[v], sum[u] + c[v]);
			in[v] --;
			if(in[v] == 0) q.push(v);
		}
	}
	int ans = 0;
	for(int i = 1; i &lt;= p; i++) {
		scanf(&quot;%d&quot;, &amp;x);
		ans = std::max(ans, sum[scc[x]]);
	}
	return ans;
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		add(x, y);
	}
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;c[i]);
	scanf(&quot;%d%d&quot;, &amp;s, &amp;p);
	dfs(s);
	for(int i = 1; i &lt;= n; i++) {
		if(scc[i] == 0) continue;
		for(int j = head[i]; j; j = next[j]) 
			if(scc[vet[j]] &amp;&amp; scc[vet[j]] != scc[i]) add2(scc[i], scc[vet[j]]);
	}
	printf(&quot;%d&quot;, topo());
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从头学数论一：算术基本定理]]></title>
        <id>https://acfboy.pw/nt1/</id>
        <link href="https://acfboy.pw/nt1/">
        </link>
        <updated>2021-04-14T23:30:56.000Z</updated>
        <summary type="html"><![CDATA[<p>开坑从头学数论。</p>
<p>教材：《初等数论》</p>
]]></summary>
        <content type="html"><![CDATA[<p>开坑从头学数论。</p>
<p>教材：《初等数论》</p>
<!-- more -->
<p>这本书在算术基本定理之前几乎都在<strong>无比严谨</strong>地证明显而易见的东西，这些等以后再看吧。</p>
<p>算术基本定理：任何一个大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的自然数都可以被唯一地表示成若干个质数的乘积。</p>
<h3 id="肯定可以表示">肯定可以表示</h3>
<p>第一种证明（反证法）：</p>
<ol>
<li>设不能被表示的自然数的集合为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi></mrow><annotation encoding="application/x-tex">\mathbf T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord mathbf">T</span></span></span></span>, 其中肯定有最小值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 必须是合数，不然就被自己给表示了，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub><mo>=</mo><msub><mi>t</mi><mn>1</mn></msub><mo>×</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_0 = t_1 \times t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo>&lt;</mo><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">2 \le t_1, t_2 &lt; t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>它们肯定也不能被表示，与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最小性矛盾。</li>
</ol>
<p>证毕。</p>
<p>第二种证明（第二类数学归纳法）：</p>
<ol>
<li>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 可以表示。</li>
<li>对于合数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, 可以分解为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = x_0x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1 &lt; x_0, x_1 &lt; x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, 它们如果可以表示，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 肯定可以表示。</li>
<li>证毕。</li>
</ol>
<h3 id="表示肯定唯一">表示肯定唯一</h3>
<p>再次使用反证法，设表示不唯一的自然数的集合是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="bold">T</mtext></mrow><annotation encoding="application/x-tex">\textbf{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">T</span></span></span></span></span>，其中同样肯定有最小的元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。</p>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msubsup><mi>p</mi><mn>1</mn><msub><mi>a</mi><mn>1</mn></msub></msubsup><msubsup><mi>p</mi><mn>2</mn><msub><mi>a</mi><mn>2</mn></msub></msubsup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msubsup><mi>p</mi><mi>n</mi><msub><mi>a</mi><mi>n</mi></msub></msubsup><mo>=</mo><msubsup><mi>q</mi><mn>1</mn><msub><mi>b</mi><mn>1</mn></msub></msubsup><msubsup><mi>q</mi><mn>2</mn><msub><mi>b</mi><mn>2</mn></msub></msubsup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msubsup><mi>q</mi><mi>m</mi><msub><mi>b</mi><mi>m</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">x= p_1^{a_1}p_2^{a_2}...p_n^{a_n} = q_1^{b_1}q_2^{b_2}...q_m^{b_m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0126em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1973159999999998em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.931008em;"><span style="top:-2.433692em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.931008em;"><span style="top:-2.433692em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">p_1 | x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">x</span></span></span></span>, 所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msubsup><mi>q</mi><mn>1</mn><mrow><mi>b</mi><mn>1</mn></mrow></msubsup><msubsup><mi>q</mi><mn>2</mn><msub><mi>b</mi><mn>2</mn></msub></msubsup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msubsup><mi>q</mi><mi>m</mi><msub><mi>b</mi><mi>m</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">p_1 | q_1^{b1}q_2^{b_2}...q_m^{b_m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1973159999999998em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.931008em;"><span style="top:-2.433692em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>, 那么把它们同时除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 剩下两个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mi>x</mi><msub><mi>p</mi><mn>1</mn></msub></mfrac><mo separator="true">,</mo><mi>z</mi><mo>=</mo><mfrac><mi>x</mi><mrow><mi>p</mi><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">y = \frac{x}{p_1}, z = \frac{x}{p1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 都不能被唯一表示，不乘上一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就被唯一表示了。而这与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的最小性矛盾。</p>
<p>证毕。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #714 (Div. 2) 游记]]></title>
        <id>https://acfboy.pw/cf1513/</id>
        <link href="https://acfboy.pw/cf1513/">
        </link>
        <updated>2021-04-12T03:13:59.000Z</updated>
        <summary type="html"><![CDATA[<p>题目质量棒极了！！！乍一看很不可做，仔细想想问题就迎刃而解，没有一道是秒杀的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>题目质量棒极了！！！乍一看很不可做，仔细想想问题就迎刃而解，没有一道是秒杀的。</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>求一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的排列使有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个山峰。</p>
</blockquote>
<p>先按 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \rightarrow n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的顺序排好，然后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 交换就可以产生一个山峰，而这种方案肯定能尽可能多的产生山峰。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
int T, n, k, a[105];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        if(k &gt; (n+1)/2-1) {
            puts(&quot;-1&quot;);
            continue;
        }
        for(int i = 1; i &lt;= n; i++) a[i] = i;
        for(int i = 2, cnt = 0; i &lt;= n &amp;&amp; cnt &lt; k; i += 2, cnt += 1)
            std::swap(a[i], a[i+1]);
        for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]);
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="b">B</h2>
<blockquote>
<p>一列数，从任意一点断开，若左边的全部 <code>and</code> 起来和右边的全部 <code>and</code> 起来都一样就说它是好的，问将输入的数列任意打乱有多少个是好的。</p>
</blockquote>
<p>一看是没有什么思路的。</p>
<p>仔细想想可以发现，那些哪一位其它数有一而它这一位是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的都得放在前后，不然的话在它前面断开就会一边有这样一位没有边为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 而另一边变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 了， 不能称为好的序列， 所以这样的选俩放首尾，其它的中间随便排就可以了。</p>
<p>代码还是有些细节的。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 200005, p = 1000000007;
int a[N], T, n;
bool vis[N];
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%lld&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]);
        memset(vis, 0, sizeof vis);
        bool twt = 0, did = 0;
        for(int i = 0; i &lt;= 30; i++) {
            bool flag = 0, tw = 0;
            for(int j = 1; j &lt;= n; j++) 
                if((1ll &lt;&lt; i) &amp; a[j]) tw = 1;
                else flag = 1;
            flag = flag &amp;&amp; tw;
            if(!flag) {
                for(int j = 1; j &lt;= n; j++) 
                    if(did &amp;&amp; vis[j] == 0) vis[j] = 0;
                    else vis[j] = 1;
                continue;
            }
            for(int j = 1; j &lt;= n; j++)
                if(((1ll &lt;&lt; i) &amp; a[j]) == 0ll) {
                    if(did &amp;&amp; vis[j] == 0) vis[j] = 0;
                    else vis[j] = 1;
                }
                else vis[j] = 0;
            did = 1;
            if(twt) break;
        }
        if(twt) {
            puts(&quot;0&quot;);
            continue;
        }
        int cnt = 0;
        for(int j = 1; j &lt;= n; j++) cnt += vis[j];
        int ans = cnt * (cnt-1) % p;
        int tans = 1;
        for(int i = 1; i &lt;= n-2; i++) tans = tans * i % p;
        ans = ans * tans % p;
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<h2 id="c">C</h2>
<blockquote>
<p>把一个整数中每一个位都变为其加上一的数字， <code>9</code> 变为 <code>10</code>, 问变 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次后数字长度是多少。</p>
</blockquote>
<p>可怜的孩子没看清数据范围，看成保证所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 和不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>, 以为这是一个简单 dp, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 次后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 出现了几次，最后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi>f</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum f[m][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 就是答案，然后顺利 T 飞。</p>
<p>不过这样的 DP 还有没有救呢？枚举几个小样例发现每个数都是独立变化的，既然独立变化，那么分开考虑，发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mo>−</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">10-d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 次后都变成 <code>10</code> 继续变换了，那么只要能快速处理出 <code>10</code> 的变化就可以快速得出所有的变化。</p>
<p>一开始我一直想着有啥数学方法可做，后来一看，直接预处理一遍把所有次数以后的变换处理完不就得了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int p = 1000000007;
int T, x, m, f[200005][10];
int get(int x) {
    if(x &lt; 0) return 1;
    int an = 0;
    for(int i = 0; i &lt;= 9; i++) an = (an + f[x][i]) % p;
    return an;
}
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    f[0][1] = f[0][0] = 1;
    for(int i = 1; i &lt;= 200000; i++) {
        for(int j = 9; j &gt;= 1; j--) f[i][j] = f[i-1][j-1];
        f[i][0] = 0;
        f[i][0] = (f[i][0] + f[i-1][9]) % p;
        f[i][1] = (f[i][1] + f[i-1][9]) % p;
    }
    while(T--) {
        scanf(&quot;%lld%lld&quot;, &amp;x, &amp;m);
        int ans = 0;
        while(x) {
            int d = x % 10;
            ans = (ans + get(m - (10-d))) % p;
            x /= 10;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<hr>
<p>本想着上 expert, 结果卡在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#5ac5ac"><mn>1596</mn></mstyle></mrow><annotation encoding="application/x-tex">\color{#5ac5ac}1596</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord" style="color:#5ac5ac;">1</span><span class="mord" style="color:#5ac5ac;">5</span><span class="mord" style="color:#5ac5ac;">9</span><span class="mord" style="color:#5ac5ac;">6</span></span></span></span> ! 太让我失望了，要是看清题目，那 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> 分不扣说不定就上蓝了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AtCoder Beginner Contest 198 游记]]></title>
        <id>https://acfboy.pw/abc198/</id>
        <link href="https://acfboy.pw/abc198/">
        </link>
        <updated>2021-04-12T03:13:20.000Z</updated>
        <summary type="html"><![CDATA[<p>PB 了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>PB 了。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题</p>
<h2 id="b">B</h2>
<p>水题</p>
<h2 id="c">C</h2>
<blockquote>
<p>给定坐标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, 每次只能跳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>, 从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 跳到其要多少？</p>
</blockquote>
<p>稍加观察就可以发现，就是距离除一下然后上取整就好了，因为越过的直接把前面一个弯一下就即可。</p>
<p>然后顺利地 WA 了。</p>
<p>一直以为是精度问题，最后发现是一次就跳到的要特判。</p>
<p>WA 了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 次，罚时吃饱。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
int r, x, y;
int main() {
    scanf(&quot;%d%d%d&quot;, &amp;r, &amp;x, &amp;y);
    double dis = sqrt((double)x*x + (double)y*y);
    double ans = ceil(dis / (double)r);
    if(ans == 1 &amp;&amp; ceil(dis / (double)r) != floor(dis / (double)r)) ans++;
    printf(&quot;%.0lf&quot;, ans);
}
</code></pre>
<h2 id="d">D</h2>
<p>一看数据范围，直接搜索就可以了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#define int long long
char s[4][15];
int len[4], num[256];
bool vis[15];
void dfs(int l, int t, int n1, int n2, int n3) {
    if(l == 3 &amp;&amp; t &gt; len[3]) {
        if(n1 + n2 == n3) {
            printf(&quot;%lld\n%lld\n%lld&quot;, n1, n2, n3);
            exit(0);
        }
        return;
    }
    if(t &gt; len[l]) {
        dfs(l+1, 1, n1, n2, n3);
        return ;
    } 
    if(num[s[l][t]] != -1) {
        if(l == 1) dfs(l, t+1, n1*10+num[s[l][t]], n2, n3);
        if(l == 2) dfs(l, t+1, n1, n2*10+num[s[l][t]], n3);
        if(l == 3) dfs(l, t+1, n1, n2, n3*10+num[s[l][t]]);
        return ;
    }
    for(int i = 0; i &lt;= 9; i++) {
        if(t == 1 &amp;&amp; i == 0) continue;
        if(vis[i]) continue;
        num[s[l][t]] = i;
        vis[i] = 1;
        if(l == 1) dfs(l, t+1, n1*10+i, n2, n3);
        if(l == 2) dfs(l, t+1, n1, n2*10+i, n3);
        if(l == 3) dfs(l, t+1, n1, n2, n3*10+i);
        vis[i] = 0;
        num[s[l][t]] = -1;
    }
}
signed main() {
    scanf(&quot;%s%s%s&quot;, s[1]+1, s[2]+1, s[3]+1);
    for(int i = 1; i &lt;= 3; i++) 
        len[i] = strlen(s[i]+1);
    memset(num, -1, sizeof num);
    dfs(1, 1, 0, 0, 0);
    printf(&quot;UNSOLVABLE&quot;);
    return 0;
}
</code></pre>
<h2 id="e">E</h2>
<p>今天 E 那么水？？？</p>
<p>达成 PB, Rank 575, 本来还可以更高的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #713 (Div. 3) 游记]]></title>
        <id>https://acfboy.pw/cf1512/</id>
        <link href="https://acfboy.pw/cf1512/">
        </link>
        <updated>2021-04-12T03:11:28.000Z</updated>
        <summary type="html"><![CDATA[<p>庆祝上分！<br>
Div.3 果然是信心赛！</p>
]]></summary>
        <content type="html"><![CDATA[<p>庆祝上分！<br>
Div.3 果然是信心赛！</p>
<!-- more -->
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cwvgII"><img src="https://z3.ax1x.com/2021/04/11/cwvgII.png" alt="cwvgII.png" loading="lazy"></a></figure>
<h2 id="a">A</h2>
<blockquote>
<p>找到若干个数中与众不同的一个</p>
</blockquote>
<p>水题。</p>
<p>记个数或者排个序都可以。</p>
<h2 id="b">B</h2>
<blockquote>
<p>输入一个图形，标记了矩形的其中两个端点，求剩下俩端点。</p>
</blockquote>
<p>分类讨论补全，注意细节。</p>
<h2 id="c">C</h2>
<blockquote>
<p>输入一个字符串，用 <code>1</code> 或 <code>0</code> 填充 <code>?</code>, 使回文且恰好 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个 <code>0</code>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个 <code>1</code></p>
</blockquote>
<p>注意得先把确定的都填完，然后能填哪个就填哪个就可以了。</p>
<p>开始没注意要先把确定的都填完， WA 了两次。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int N = 200005;
int T, a, b;
char st[N];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d%d&quot;, &amp;b, &amp;a);
        scanf(&quot;%s&quot;, st+1);
        int n = strlen(st+1);
        for(int i = 1; i &lt;= n; i++)
            if(st[i] == '1') a--;
            else if(st[i] == '0') b--;
        bool flag = 0;
        // printf(&quot;%d %d %d\n&quot;, b, a, flag);
        for(int i = 1; i &lt;= n/2; i++) {
            if(st[i] != '?' &amp;&amp; st[n-i+1] != '?') {
                if(st[i] != st[n-i+1]) {
                    flag = 1;
                    break;
                }
                else continue;
            }
            if(st[i] == '1') a -= 1, st[n-i+1] = '1';
            else if(st[n-i+1] == '1') a -= 1, st[i] = '1';
            else if(st[i] == '0') b -= 1, st[n-i+1] = '0';
            else if(st[n-i+1] == '0') b -= 1, st[i] = '0';
        }
        for(int i = 1; i &lt;= n/2; i++) {
            if(st[i] == '?' &amp;&amp; st[n-i+1] == '?') {
                if(a &gt; 1) a -= 2, st[i] = st[n-i+1] = '1';
                else b -= 2, st[i] = st[n-i+1] = '0';
            }
        }
        if(n % 2 == 1 &amp;&amp; st[n/2+1] == '?')     
            if(a) a--, st[n/2+1] = '1';
            else st[n/2+1] = '0', b--;
        if(flag || a != 0 || b != 0) puts(&quot;-1&quot;);
        else printf(&quot;%s\n&quot;, st+1);
    }
    return 0;
}
</code></pre>
<h2 id="d">D</h2>
<blockquote>
<p>不告诉你 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, 只知道有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>, 前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i = a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 最后俩一个是前面数的和，另一个是随便写的，求一个可能的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。</p>
</blockquote>
<p>和肯定是最大的嘛！所以记一个最大和次大就好了。</p>
<h2 id="e">E</h2>
<blockquote>
<p>求出一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的排列使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>l</mi></mrow><mi>r</mi></msubsup><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">\sum_{i=l}^r p_i = s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></p>
</blockquote>
<p>那么只要求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r-l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的不同数恰好为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>, 然后随便填就可以了。</p>
<p>拼只需要让前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>→</mo><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">1\rightarrow (r-l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>, 然后慢慢调整就可以了。</p>
<p>具体地：</p>
<ol>
<li>排完后若最后一个数比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 小那直接上。</li>
<li>否则，前面 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个能统一加的就加</li>
<li>加完 1 的还有剩下就从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个开始往前一个个加。</li>
<li>若有冲突就不成立。</li>
</ol>
<p>这样的做法保证了倒数俩的距离尽可能大，同时满足条件，如果还得冲突，那肯定不行。</p>
<p>同样要注意细节，以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r = l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 时要特殊处理。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int T, n, l, r, s, flag[505], a[505];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        memset(flag, 0, sizeof flag);
        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;l, &amp;r, &amp;s);
        int len = r - l + 1;
        if(s &lt; (1+len) * len / 2 || (n-len+1+n) * len / 2 &lt; s) { 
            puts(&quot;-1&quot;);
            continue;
        }
        bool twt = 0;
        if(len != 1) {
            int sum = 0;
            for(int i = 1; i &lt; len; i++) a[i] = i, sum += i;
            sum = s - sum - n;
            // printf(&quot;%d\n&quot;, sum);
            int delta = sum / (len - 1);
            if(sum &gt; 0) {
                for(int i = 1; i &lt; len; i++) a[i] += delta;
                sum -= sum / (len-1) * (len-1);
            }
            for(int i = len-1; i &gt;= 1 &amp;&amp; sum &gt; 0; i--, sum--) a[i] ++;
            a[len] = n;
            if(sum &lt; 0) {
                while(sum &lt; 0) a[len]--, sum++;
            }
            for(int i = 1; i &lt;= len; i++) flag[a[i]] ++;
        }
        else if(s &gt; n) twt = 1;
        else flag[s] = 1, a[1] = s;
        for(int i = 1; i &lt;= n; i++)         
            if(flag[i] &gt; 1) twt = 1;
        if(twt) {
            puts(&quot;-1&quot;);
            continue;
        }
        int now = 1;
        for(int i = 1; i &lt; l; i++) {
            while(flag[now]) now++;
            printf(&quot;%d &quot;, now);
            now ++;
        }
        for(int i = 1; i &lt;= len; i++) printf(&quot;%d &quot;, a[i]);
        for(int i = r+1; i &lt;= n; i++) {
            while(flag[now]) now++;
            printf(&quot;%d &quot;, now);
            now ++;
        }
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="f">F</h2>
<blockquote>
<p>开始有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 元，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 级每天可领取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 元或花费 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 升级， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 单调递增。最少几天总钱数大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p>
</blockquote>
<p>那要升级肯定是早升更好，所以直接枚举最后到哪级，算出答案取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span> 就好了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define int long long
const int N = 200005;
int T, n, c, a[N], b[N], ans;
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%lld%lld&quot;, &amp;n, &amp;c);
        ans = 0x3f3f3f3f3f3f3f3fll;
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]);
        for(int i = 1; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;b[i]);
        int now = 0, nd = 0;
        for(int i = 1; i &lt;= n; i++) {
            ans = std::min(ans, nd + (c - now + a[i]-1) / a[i]);
            int d = (b[i] - now + a[i]-1) / a[i];
            // printf(&quot;*%lld %lld %lld %lld\n&quot;, ans, d, now, nd);
            now = now + d * a[i] - b[i], nd += d+1; // 注意升级也要天数。
        }
        printf(&quot;%lld\n&quot;, ans);
    }
}
</code></pre>
<h2 id="g">G</h2>
<p>唯一有真正难度的一题。</p>
<p>数论题。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></msub><mi>k</mi></mrow><annotation encoding="application/x-tex">d(n) = \sum_{k|n} k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 求最小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">d(n) = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p>
</blockquote>
<p>这玩意儿居然有积性。</p>
<p>欧拉筛一遍二分即可。</p>
<p>但赛场上没时间也想不到。</p>
<p>好好看 《初等数论》 吧。</p>
]]></content>
    </entry>
</feed>