<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的博客</title>
    <updated>2021-05-03T07:54:01.514Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的博客</rights>
    <entry>
        <title type="html"><![CDATA[Codeforces Global Round 14 掉分记]]></title>
        <id>https://acfboy.pw/codeforces-global-round-14/</id>
        <link href="https://acfboy.pw/codeforces-global-round-14/">
        </link>
        <updated>2021-05-03T07:46:23.000Z</updated>
        <summary type="html"><![CDATA[<p>顺利地掉回了 specilist。</p>
<p>越到后面脑子越混，直接就弃疗了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>顺利地掉回了 specilist。</p>
<p>越到后面脑子越混，直接就弃疗了。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题。直接若不满足直接前后调换，因为保证数都不同，所以这样是对的。</p>
<h2 id="b">B</h2>
<p>显然只有样例中两种可以组合成其它的。</p>
<h2 id="c">C</h2>
<p>可以证明，如果存在方案，那么每次塞到最小的塔里面是最优的。</p>
<p>使用反证法：如果有两块的差超过了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, 因为单个的块高度不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, 所以肯定相差了超过一块，而我们的方案不会允许超过一块的存在（如果有解的话）。</p>
<p>然后用 <code>priority_queue</code> 搞一搞就好了。</p>
<h2 id="d">D</h2>
<p>这题明明特别简单，赛时有三千多个通过，我居然没有做出来。</p>
<p>大致思路是对的，肯定是要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">n/2 - l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 次变换左右，尽量把相同的数字均匀地分到两边。</p>
<p>但是我犯了一个致命的错误。应该先把匹配的给去掉而不是先分了再去掉，因为这些肯定不参与变换，如果把它们也给所谓均分了就不对了。</p>
<p>赛时脑子糊涂得不得了，没有想到这一点，于是愉快掉分，回到了青。</p>
<p>代码写得特别丑，是老老实实存每一个数的，因为没有想到可以直接记录每一个数字出现的次数。所以不放代码了。</p>
<hr>
<p>距离 APIO 不到 20 天了，然而什么似乎都是一团糟的状态。</p>
<p>翘翘要加油冲鸭。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZONe Energy Programming Contest 游记]]></title>
        <id>https://acfboy.pw/zone-energy-programming-contest/</id>
        <link href="https://acfboy.pw/zone-energy-programming-contest/">
        </link>
        <updated>2021-05-02T07:45:45.000Z</updated>
        <summary type="html"><![CDATA[<p>题目质量还是比较高的——就是数据有点水啊。</p>
]]></summary>
        <content type="html"><![CDATA[<p>题目质量还是比较高的——就是数据有点水啊。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>字符串入门题。</p>
<h2 id="b">B</h2>
<p>初中数学之三角函数。</p>
<h2 id="c-1">C - 1</h2>
<p>为什么要把这题难的放在前面？</p>
<p>开始做的时候觉得是贪心，但很容易找出反例发现不一定要选一位上最大的，所以就没有什么思路了，先去看看 D 再来。</p>
<h2 id="d">D</h2>
<p>看上去高大上，其实仍然是水题，搞个 <code>deque</code> 处理反转和添加，然后用栈处理相邻的会消掉的问题。</p>
<p>C 耽误了一些时间，不然更快地过这题，可能排名会更高。</p>
<h2 id="c-2">C - 2</h2>
<p>现在重新来思考 C 题。有了前面的经验可以知道大概率不会是 dp 了，因为局部最优没有办法得到全局最优，且这些数那么大也不能拿来做状态。</p>
<p>考虑了二分，但是由于没法直接选相似的原因，二分不能验证。</p>
<p>所以回到最初的思路，直接暴力枚举三个，这样的话时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 的，不能接受，但只要优化掉一维就可以通过了。</p>
<p>注意到题目中出现的常数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>, 题目没有设置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个肯定是因为这俩常数是有用的。有抽屉原理可以知道，选择的三行中，至少有一行包含了超过一个最大值。</p>
<p>但是这样还是没有办法做，因为既可能是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>−</mo><mn>1</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">3-1-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的分布，也有可能是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>−</mo><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2-2-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的分布。然后又卡了一会儿恍然大悟，同样抽屉原理可以得到两行肯定包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个以上的最大值啊！</p>
<p>所以只要枚举两行再枚举没有取到最大值的一列给它取上当前列的最大值就可以了。至于那一列的最大值可以直接读入的时候预处理出来。</p>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。代码如下。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
int n, max[3005], a[3005][10], ans;
int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) 
        for(int j = 1; j &lt;= 5; j++) 
            scanf(&quot;%d&quot;, &amp;a[i][j]), max[j] = std::max(max[j], a[i][j]);
    for(int i = 1; i &lt;= n; i++)
        for(int j = i+1; j &lt;= n; j++) {
            int tmax[6] = {0, 0, 0, 0, 0, 0};
            for(int k = 1; k &lt;= 5; k++) tmax[k] = std::max(tmax[k], std::max(a[i][k], a[j][k]));
            for(int k = 1; k &lt;= 5; k++) {
                int tmp = tmax[k], an = 2000000000;
                tmax[k] = max[k];
                for(int k = 1; k &lt;= 5; k++) an = std::min(an, tmax[k]);
                ans = std::max(ans, an);
                tmax[k] = tmp;
            }
        }
    printf(&quot;%d&quot;, ans);
    return 0;
}
</code></pre>
<h2 id="e">E</h2>
<p>乍一看还以为是 Dijkstra 的板子。</p>
<p>抱着暴力出奇迹的信仰 <s>没有分析复杂度</s> 我写了一发 Dijkstra 就直接交了，居然只 T 了一个点，然后卡了卡常，但也没能通过。</p>
<p><s>比赛结束有有人告诉我胡乱剪枝就过了。</s></p>
<p>然后开始尝试构造 hack 数据，不过构造得有些麻烦，因为要让点尽可能多的被重复松弛，最后成功卡掉我自己和其它直接 Dijkstra 的方法是随机一半的概率放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，其它放随机数，这样生成的极限数据 Dijkstra 需要 2.5s 才过。</p>
<p>直接做当然 T, 因为边数可以达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">500^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 条，点数也有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">500^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 个。而 Dijkstra 的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">(n+m) \log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 的。<s>能 hack 的话我就把他们全部叉掉！</s></p>
<p>那么正确做法是怎么样的呢？</p>
<p>如果没有最后一条限制，那么直接 Dijkstra 可以通过，因为边数和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 一个数量级。</p>
<p>那么考虑把最后一种操作转换成向前面一样的常规操作。如果向上的代价是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，那么直接向上连长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的边就可以了。但这里要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 所以用分层图来处理，第二层图向上连长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的边，再用长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的边连到第一层。然后一层到二层再连上长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的边就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 505;
struct twt {
    int x, y, k, d;
    bool operator &lt; (twt b) const {
        return d &gt; b.d;
    }
};
std::priority_queue&lt;twt&gt; que;
int R, C, a[N][N], b[N][N], dis[N][N][2];
void Dijkstra() {
    memset(dis, 0x3f, sizeof dis);
    que.push((twt){1, 1, 0});
    dis[1][1][0] = 0;
    while(!que.empty()) {
        twt now = que.top(); que.pop();
        int x = now.x, y = now.y, d = now.d, k = now.k;
      	if(x == R &amp;&amp; y == C) break;
        if(now.d != dis[x][y][k]) continue;
        if(k == 0) {
            if(y &lt; C &amp;&amp; d + a[x][y] &lt; dis[x][y+1][k]) {
                dis[x][y+1][k] = d + a[x][y];
                que.push((twt){x, y+1, 0, dis[x][y+1][k]});
            }
            if(y &gt; 1 &amp;&amp; d + a[x][y-1] &lt; dis[x][y-1][k]) {
                dis[x][y-1][k] = d + a[x][y-1];
                que.push((twt){x, y-1, 0, dis[x][y-1][k]});
            }
            if(x &lt; R &amp;&amp; d + b[x][y] &lt; dis[x+1][y][k]) {
                dis[x+1][y][k] = d + b[x][y];
                que.push((twt){x+1, y, 0, dis[x+1][y][k]});
            }
            if(d+1 &lt; dis[x][y][1]) {
                dis[x][y][1] = d+1;
                que.push((twt){x, y, 1, dis[x][y][1]});
            }
        }
        else {
            if(x &gt; 1 &amp;&amp; d + 1 &lt; dis[x-1][y][1]) {
                dis[x-1][y][1] = d+1;
                que.push((twt){x-1, y, 1, dis[x-1][y][1]});
            }
            if(d &lt; dis[x][y][0]) {
                dis[x][y][0] = d;
                que.push((twt){x, y, 0, dis[x][y][0]});
            }
        }
    }
}
signed main() {
    scanf(&quot;%lld%lld&quot;, &amp;R, &amp;C);
    for(int i = 1; i &lt;= R; i++)
        for(int j = 1; j &lt; C; j++) scanf(&quot;%lld&quot;, &amp;a[i][j]);
    for(int i = 1; i &lt; R; i++)
        for(int j = 1; j &lt;= C; j++) scanf(&quot;%lld&quot;, &amp;b[i][j]);
    Dijkstra();
    printf(&quot;%lld&quot;, dis[R][C][0]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.4.30 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210430/</id>
        <link href="https://acfboy.pw/20210430/">
        </link>
        <updated>2021-04-30T06:15:43.000Z</updated>
        <summary type="html"><![CDATA[<p>不想说什么了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>不想说什么了。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>说难不难说简单不简单的一道题。</p>
<blockquote>
<p>“说难不？难。说简单！不简单。”的一道题。</p>
</blockquote>
<blockquote>
<p>“说难不难。说简单不？简单。”的一道题。</p>
</blockquote>
<p><s>好了好了不整活了</s></p>
<blockquote>
<p>给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个括号序列，能否将其拼成一个匹配的括号序列。</p>
</blockquote>
<p>这道题其实是考察思维的严谨性。</p>
<p>首先的想法是是否个数相等就行。这显然是不行的。</p>
<p>观察得到肯定要是去除匹配之后全左和全右的在两边。于是我就认为两边有中间匹配就行。</p>
<p>然后 WA 了。</p>
<p>发现了反例，觉得中间要判断一下才行。</p>
<p>然后又 WA 了。</p>
<p>接着又觉得要把右括号少的放前面。</p>
<p>又双叒叕 WA 了。</p>
<p>其实以上的反例都特别好找，而且都没有严谨的理论基础，只是找了几个数据就凭着感觉上的，和直接猜结论没有本质的区别。</p>
<p>所以有了例子还是得从理论出发找到做法。</p>
<ol>
<li>最左边右括号不能没有匹配</li>
<li>保证了前面不会出事的情况下肯定是左括号越多越好，以应对未来的右括号。</li>
</ol>
<p>根据这个排序即可。这个想法似乎也有所特别，和大部分人的不一样。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
std::string s, tmp, stl, str, stn;
char st[1000005];
int numl, numr, n, lenl, lenr;
struct twt {
    std::string st;
    int k;
    bool operator&lt;(twt b) const {
        return (k &lt;= stl.size()) &gt; (b.k &lt;= stl.size()) ||
               ((k &lt;= stl.size()) == (b.k &lt;= stl.size()) &amp;&amp; st.size() - k &gt; b.st.size() - b.k);
    }
};
std::vector&lt;twt&gt; a;
bool checkl(std::string s) {
    if (s.size() == 0)
        return false;
    for (int i = 0; i &lt; (signed)s.size(); i++)
        if (s[i] == ')')
            return false;
    return true;
}
bool checkr(std::string s) {
    if (s.size() == 0)
        return false;
    for (int i = 0; i &lt; (signed)s.size(); i++)
        if (s[i] == '(')
            return false;
    return true;
}
int main() {
    std::ios::sync_with_stdio(false);
    std::cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) {
        std::cin &gt;&gt; tmp;
        s = &quot;&quot;;
        int top = 0;
        for (int j = 0; j &lt; (signed)tmp.size(); j++)
            if (tmp[j] == ')') {
                if (st[top] == '(')
                    top--;
                else
                    st[++top] = ')';
            } else
                st[++top] = '(';
        for (int j = 1; j &lt;= top; j++) s = s + st[j];
        if (checkl(s))
            stl += s;
        else if (checkr(s))
            str += s;
        else {
            int k = 0;
            for (int j = 0; j &lt; (signed)s.size(); j++) k += s[j] == ')';
            a.push_back(twt{ s, k });
        }
    }
    std::sort(a.begin(), a.end());
    std::string an = stl;
    for (int i = 0; i &lt; (signed)a.size(); i++) an += a[i].st;
    an += str;
    // std::cout &lt;&lt; an &lt;&lt; std::endl;
    int now = 0;
    for (int i = 0; i &lt; (signed)an.size(); i++) {
        if (an[i] == '(')
            now++;
        else
            now--;
        if (now &lt; 0)
            return puts(&quot;No&quot;), 0;
    }
    if (now != 0)
        puts(&quot;No&quot;);
    else
        puts(&quot;Yes&quot;);
}
</code></pre>
<p>花了我一小时二十分钟qwq。</p>
<h2 id="b">B</h2>
<p>水题</p>
<h2 id="c">C</h2>
<p>水题</p>
<h2 id="e">E</h2>
<p>有点细节啊，就是要处理一个部分循环的问题，但还是花了好久。</p>
<h2 id="d">D</h2>
<p>不难的组合数学。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个格子填 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 种颜色，使相邻的格子不能有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个以上颜色相同的方案数。</p>
</blockquote>
<p>先插板，然后再乘法原理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>×</mo><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>×</mo><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">m\times(m-1)\times(m-1) \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>。</p>
<p>答案就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></msubsup><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>m</mi><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><msup><mo>)</mo><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{i=0}^k C_{n-1}^{n-i-1}m (m-1)^{n-i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.313647em;vertical-align:-0.324639em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864795em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="最后">最后</h2>
<p>名次全无往日威风了。</p>
<p>感觉状态不增反降，越来越差了。</p>
<p>越是没法静心做题，就越是没法面对自己；越是没法面对自己，就越是没法静心做题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2013]机器人]]></title>
        <id>https://acfboy.pw/apio2013robot/</id>
        <link href="https://acfboy.pw/apio2013robot/">
        </link>
        <updated>2021-04-29T12:10:37.000Z</updated>
        <summary type="html"><![CDATA[<p>这居然也是 dp? 很难想到啊！这个数据范围就只想着搜索了。</p>
<p>这居然还是斯坦纳树？刚做完斯坦纳树模板就不会……神题啊。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这居然也是 dp? 很难想到啊！这个数据范围就只想着搜索了。</p>
<p>这居然还是斯坦纳树？刚做完斯坦纳树模板就不会……神题啊。</p>
<!-- more -->
<p>题目很长，放<a href="https://www.luogu.com.cn/problem/P3638">传送门</a>。</p>
<p>看到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 的数据范围认为应该是道搜索题了，但是直接暴力的复杂度大得不得了，猜想应该预处理出些什么，或者有什么性质。但是什么神奇的性质都没有发现。</p>
<p>其实这题还是隐隐约约有一些图论模型在的，因为并不是在这个网格中随便的走，而是要撞上障碍物。所以容易想到可以处理出每一个点向每一个方向走最后会到达的位置。</p>
<p>然后就考验对斯坦纳树的算法的理解了。</p>
<p>在斯坦纳树中，我们定义了一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 状态的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 为根的最小的权值和，然后先进行了一下常规的转移，即可以用原来结果直接得到的转移，然后通过一次最短路让当前的一些状态去松弛其它的状态。</p>
<p>这道题中也可以用类似的思想在做。</p>
<p>因为题目中要求的是连续区间才能合并成一个新的区间，我们可以用区间 dp 的方式来实现这一点。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 中的合成一块儿到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 号位置的最小代价，然后先直接合并原来的答案，再用 spfa 松弛一遍就好了。<s>这 spfa 被卡需要用玄学优化才能过，但我们不管，直接吸氧</s></p>
<p>这不经让我思考：到底什么样的东西才可以用这样的方法来做的呢？</p>
<p>其实关键在于那个 spfa 的转移，因为前面的常规转移在一般的情况下是很容易被想到的。在这两题中，用 spfa 的转移都有一个性质，那就是可能会构成一个环形的转移，并且能搞那什么三角等式。其实这不就是图上最短路的一个特征吗，我们把 dis 看成是 dp 数组，它就没有办法直接转移，因为不知道顺序是怎样的，而又可以松弛，所以就用到最短路的算法了。</p>
<p>最后放上代码吧。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
const int N = 505;
int f[10][10][N*N], h, w, n, left[5], right[5], id[N][N], cnt, tran[N*N][4], p[N*N],
	ans, nowa, nowb, q[N*N], head, tail;
int dx[4] = {0, 0, 1, -1},
	dy[4] = {1, -1, 0, 0};
bool vis[N*N], vi[N*N][4];
char s[N][N];
bool cmp(int a, int b) { return f[nowa][nowb][a] &lt; f[nowa][nowb][b]; }
bool pd(int i, int j) { return (i &lt; 1 || j &lt; 1 || i &gt; h || j &gt; w || s[i][j] == 'x'); }
void init() {
	left[0] = 3, left[3] = 1, left[1] = 2, left[2] = 0;
	right[0] = 2, right[2] = 1, right[1] = 3, right[3] = 0;
	memset(f, 0x3f, sizeof f);
	memset(tran, -1, sizeof tran);
}
void spfa(int x, int y, int s) {
	head = tail = 1;
	q[tail] = s;
	while(head &lt;= tail) {
		int u = q[head];
		vis[u] = 0;
		head++;
		for(int i = 0; i &lt; 4; i++) {
			int v = tran[u][i];
			if(v &lt;= 0) continue;
			if(f[x][y][v] &gt; f[x][y][u] + 1) {
				f[x][y][v] = f[x][y][u] + 1;
				if(!vis[v]) q[++tail] = v, vis[v] = 1;
			}
		}
	}
}
int dfs(int i, int j, int k) {
	if(tran[id[i][j]][k] != -1) return tran[id[i][j]][k];
	if(vi[id[i][j]][k]) return 0;
	vi[id[i][j]][k] = 1;
	int xx = i + dx[k], yy = j + dy[k];
	if(pd(xx, yy)) {
		vi[id[i][j]][k] = 0, tran[id[i][j]][k] = id[i][j];
		return id[i][j];
	}
	if(s[xx][yy] == 'A') {
		tran[id[i][j]][k] = dfs(xx, yy, left[k]);
		vi[id[i][j]][k] = 0;
		return tran[id[i][j]][k];
	}
	else if(s[xx][yy] == 'C') {
		tran[id[i][j]][k] = dfs(xx, yy, right[k]);
		vi[id[i][j]][k] = 0;
		return tran[id[i][j]][k];
	}
	tran[id[i][j]][k] = dfs(xx, yy, k);
	vi[id[i][j]][k] = 0;
	return tran[id[i][j]][k];
}
int main() {
	init();
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;w, &amp;h);
	for(int i = 1; i &lt;= h; i++) scanf(&quot;%s&quot;, s[i]+1);
	for(int i = 1; i &lt;= h; i++)
		for(int j =  1; j &lt;= w; j++)
			if(!pd(i, j)) {
				id[i][j] = ++cnt;
				if(s[i][j] &gt;= '0' &amp;&amp; s[i][j] &lt;= '9') 
					f[s[i][j]-'0'][s[i][j]-'0'][cnt] = 0;
			}
	for(int i = 1; i &lt;= h; i++)
		for(int j = 1; j &lt;= w; j++) 
			if(!pd(i, j)) {
				for(int k = 0; k &lt; 4; k++) tran[id[i][j]][k] = dfs(i, j, k);
			}
	for(int i = 1; i &lt;= cnt; i++) p[i] = i;
	for(int len = 1; len &lt;= n; len++)
		for(int i = 1; i+len-1 &lt;= n; i++) {
			int j = i + len - 1;
			for(int k = 1; k &lt;= cnt; k++)
				for(int l = i; l &lt; j; l++)
					f[i][j][k] = std::min(f[i][j][k], f[i][l][k] + f[l+1][j][k]);
			nowa = i, nowb = j;
			std::sort(p+1, p+1+cnt, cmp);
			for(int k = 1; k &lt;= cnt; k++) spfa(i, j, p[k]);
		}
	ans = 2000000000;
	for(int i = 1; i &lt;= cnt; i++) ans = std::min(ans, f[1][n][i]);
	if(ans == 0x3f3f3f3f) puts(&quot;-1&quot;);
	else printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [POI2014]HOT-Hotels]]></title>
        <id>https://acfboy.pw/poi2014hothotels/</id>
        <link href="https://acfboy.pw/poi2014hothotels/">
        </link>
        <updated>2021-04-28T12:39:10.000Z</updated>
        <summary type="html"><![CDATA[<p>看了题解发现我的思路并没有走偏，只是遇到重复这类的问题时没有想到解决的办法。大概要获得解决这样问题的能力只能靠多做题积累吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>看了题解发现我的思路并没有走偏，只是遇到重复这类的问题时没有想到解决的办法。大概要获得解决这样问题的能力只能靠多做题积累吧。</p>
<!-- more -->
<blockquote>
<p>给定一棵树，在树上选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个点，要求两两距离相等，求方案数。</p>
</blockquote>
<p>首先有一个显然的性质，那就是只能是三个点从一个点直直的伸出去，即深度较深的两个点距离它们 LCA 的距离相同，也就是说深度要相同了。</p>
<p>那么考虑应该如何统计这样子深度相同的点。直接记录是不行的，因为要保证它们的 LCA 要在当前点，不能产生更深的公共祖先。</p>
<p>既然没法一蹴而就，那么久先来两个的。于是有了两种想法，一个是枚举两个点，再通过什么方式来找到第三个点的个数（倍增似乎可做，但时间上无法接受），另一个是通过神奇的 dp 来解决。<s>然后我就没有想法了</s></p>
<p>平常我们的 dp 都是通过一个数组来解决，最多再来一个辅助计算。可是这里难以在一两个数组内解决问题，所以尝试记录更多的信息。可以枚举一个点，把它当做那两个较深的点的 LCA，再一个个枚举它的子树，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 记录前面的子树中有两个满足条件的深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的点的数量，那么再乘上当前子树中深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的节点数量就肯定满足要求了。</p>
<p>同样的分解还可以继续，令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 是前面子树中深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的点数量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">box[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 是当前子树中深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的点的数量，每次更新的时候让答案先加一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mi>b</mi><mi>o</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i] \times box[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>, 再把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mi>b</mi><mi>o</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i] \times box[i],g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">box[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#define int long long
const int N = 5005;
int x, y, n, f[N], box[N], g[N], ans, lim;
std::vector&lt;int&gt; G[N];
void dfs(int u, int fa, int d) {
	lim = std::max(lim, d);
	box[d] ++;
	for(int i = 0; i &lt; (signed)G[u].size(); i++) {
		int v = G[u][i];
		if(v == fa) continue;
		dfs(v, u, d+1);
	}
}
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt; n; i++) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		G[x].push_back(y), G[y].push_back(x);
	}
	for(int i = 1; i &lt;= n; i++) {
		memset(f, 0, sizeof f), memset(g, 0, sizeof g);
		for(int j = 0; j &lt; (signed)G[i].size(); j++) {
			int v = G[i][j];
			lim = 0;
			memset(box, 0, sizeof box);
			dfs(v, i, 1);
			for(int k = 1; k &lt;= lim; k++) {
				ans += f[k] * box[k];
				f[k] += g[k] * box[k];
				g[k] += box[k];
			}
		}
	}
	printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [SCOI2015]国旗计划]]></title>
        <id>https://acfboy.pw/scoi2015guoqijihua/</id>
        <link href="https://acfboy.pw/scoi2015guoqijihua/">
        </link>
        <updated>2021-04-28T10:52:44.000Z</updated>
        <summary type="html"><![CDATA[<p>难以置信，我居然会被这样一个问题难倒？！</p>
]]></summary>
        <content type="html"><![CDATA[<p>难以置信，我居然会被这样一个问题难倒？！</p>
<!-- more -->
<p>看到题目，排序和贪心很容易就可以看出来，但展开到链上的时候只知道跨越的要加上个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，但居然死活想不到要把每一个都复制一遍！然后就没辙了。</p>
<p>最近状态好像很糟糕的样子，修正了原先极左的错误，但似乎并没有提高什么，还是静不下来写题，过题量降到了很低的水平。</p>
<p>但这样至少是正视了问题，大概比整天做些“体力劳动大于脑力劳动”的题来营造通过数的假象以欺骗自己要好得多。现在没有状态，说得仿佛前面四个月很有状态一样；前面四个月没有状态，说得好像是前几年很有状态一样。</p>
<p>大概翘翘从来不曾可爱过，但又从来就向往“可爱”的样子。虽不能至，心向往之，总好过在打击中沉沦。</p>
<p>加油吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.4.28 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210428/</id>
        <link href="https://acfboy.pw/20210428/">
        </link>
        <updated>2021-04-28T07:14:59.000Z</updated>
        <summary type="html"><![CDATA[<p>水到爆的一场模拟赛，但是因为代码丢失题意不清等奇怪原因就啥也没写出来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>水到爆的一场模拟赛，但是因为代码丢失题意不清等奇怪原因就啥也没写出来。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题，但题目就是不告诉你 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的范围是什么，让你自己猜。</p>
<p>我猜它非常大，于是把二分的边界设置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>60</mn></msup></mrow><annotation encoding="application/x-tex">2^{60}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>, 结果没有注意到中间需要加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次，所以顺利溢出了。</p>
<p>其实是检查单执行不彻底，没有注意到 <code>range</code> 的问题，不然不论怎样也不能让这里溢出啊。</p>
<p>然后发生了 <strong>严重事故征候</strong>。</p>
<p>在进行文件测试的时候突然跳出来弹窗说磁盘上的已经改变，要不要重新加载，被我误操作了确定，然后代码消失的一干二净，哪也找不回来了。</p>
<p><s>NTSB 第一时间展开了调查</s>， 发现极有可能是文件操作中后缀名写成了 cpp 所致，程序直接覆盖了自己的源代码。而且 dev 没有办法撤回这样子的操作，所以代码就丢失了。</p>
<p><s>在最终报告中，NTSB 建议</s>， 以后的代码都得在修改过整个文件夹备份了，这样不仅不怕覆盖丢失的问题，有些题目改炸了还可以整个回滚。</p>
<h2 id="b">B</h2>
<p>这题其实挺好的。</p>
<blockquote>
<p>在一个数组中取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 段，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 段长 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 且必须经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 求最大取出的数字之和。</p>
</blockquote>
<p>开始以为是贪心，因为乍一看会有后效性。但贪心很容易构造出反例，于是又来想 dp, 加了一维以解除后效性。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个，最后的位置在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的最优方案，然后再来个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 以供转移，看上去这不但是三维的，而且每一都是十万级别的，似乎没救了。</p>
<p>但其实不然，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 都有限制，所以总状态数其实是只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个的，同理，转移加起来也只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个，所以这个看似暴力不可过的其实就是正解。</p>
<p>为了实现方便，后来修改了状态， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 代表是距离 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 这个的末尾左边限制的距离。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
const int N = 100005;
std::vector&lt;int&gt; f[N];
int n, m, sum[N], b[N], d[N], L[N], R[N], ans;
int main() {
	freopen(&quot;fish.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;fish.out&quot;, &quot;w&quot;, stdout);
	
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;sum[i]), sum[i] += sum[i-1];
	scanf(&quot;%d&quot;, &amp;m);
	for(int i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;b[i], &amp;d[i]);
	b[m+1] = n+1;
	for(int i = 1; i &lt;= m; i++) 
		L[i] = std::max(L[i-1]+d[i], b[i]), R[i] = std::min(b[i]+d[i]-1, b[i+1]-1);
	f[0].push_back(0); 
	for(int i = 1; i &lt;= m; i++) 
		for(int j = L[i]; j &lt;= R[i]; j++) {
			int k = f[i-1].size()-1;
			while(L[i-1] + k &gt;= j - d[i] + 1) k--;
			f[i].push_back(0); 
			int now = f[i].size()-1;
			for( ; k &gt;= 0; k--) f[i][now] = std::max(f[i][now], f[i-1][k]);
			f[i][now] += sum[j] - sum[j-d[i]];
	}
	for(int i = 0; i &lt; (signed)f[m].size(); i++) ans = std::max(ans, f[m][i]);
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
<h2 id="c">C</h2>
<p>一切都是没有读清题目的锅。</p>
<p>题中啥 “跳到另一个电梯上”， 我还以为是直接电梯不停就过去了呢……好呆啊。</p>
<p>然后赛场上想了好久的做法，进行了一波细致的操作最终使它能过，但好像还是没有考虑向下走的情况，于是样例都没有过。</p>
<p>赛后补题的时候也没发现渔代码里的小问题。</p>
<h2 id="d">D</h2>
<p>水题。</p>
<p>【模板】Floyd 最短路。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [NOI Online #1 入门组] 魔法]]></title>
        <id>https://acfboy.pw/noio1magic/</id>
        <link href="https://acfboy.pw/noio1magic/">
        </link>
        <updated>2021-04-27T11:55:32.000Z</updated>
        <summary type="html"><![CDATA[<p>是一道考察对矩阵理解的好题。</p>
<p>自己做了很久都没有往矩阵上去想。</p>
]]></summary>
        <content type="html"><![CDATA[<p>是一道考察对矩阵理解的好题。</p>
<p>自己做了很久都没有往矩阵上去想。</p>
<!-- more -->
<p><a href="https://www.luogu.com.cn/problem/P6190">传送门</a></p>
<p>DAG 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的情况都很简单，由于 DAG 有做法而往回走了最后还得到终点，所以想到了缩点。</p>
<p>但是发现缩点并没有什么用，因为可以重复绕，而变成负数又有限制，所以强连通分量没有什么用。最多是环有点用处，可以处理出当前点绕环中使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 次魔法的最优情况，但谁说圈一定要绕满？所以也没啥用。</p>
<p>数据范围似乎有些误导性，看到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>90</mn></mrow><annotation encoding="application/x-tex">90</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">0</span></span></span></span> 分那一档就认为是分层图了，一直想着怎么去优化，但最终未果。</p>
<p>其实正解是 dp 的矩阵优化，首先可以想到一个类似弗洛伊德的 dp， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[k][i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次魔法，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的最优答案。至于转移，随便 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[k-1][i][l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[1][l][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 取一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span> 就可以了。时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 的，不能接受。</p>
<p>这个 dp 看上去没有什么优化的空间，但实际上，可以矩阵加速。</p>
<p>矩阵的本质是什么？看过 3b1b 的会说， <strong>矩阵是一种变换</strong>， 而我们的矩阵乘法快速幂的要求就是要满足结合律，所以我们其实可以把加法和乘法用另外的运算替换掉，描述一种变换，然后可以同样是可以搞快速幂的。</p>
<p>在此题中，可以重载成这样的一种运算：</p>
<pre><code class="language-cpp">twt operator * (twt b) {
	twt c;
	for(int k = 1; k &lt;= n; k++)
		for(int i = 1; i &lt;= n; i++)
			for(int j = 1; j &lt;= n; j++)
				c[i][j] = std::min(c[i][j], t[i][k] + b[k][j]);
	return c;
}
</code></pre>
<p>看上去这似乎是一个弗洛伊德，但它的答案不是来源于同一个数组中的，而是来源于运算符两边的 <code>twt</code>。我们回顾那个无法接受的转移，其实不一定必须从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 转移过来，任意一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">k-c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 都是可以的。</p>
<p>所以就有了上面这个运算，它的路径剖开，一边用的是经过了若干次魔法的，另一边用的是经过一些魔法的，合起来就成了使用两边原来使用的魔法次数的和的，而且这个样子是由结合律的（感性理解：用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">3,2,1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span></span></span></span> 次魔法的合并， 最后不管怎么并都是使用了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 次魔法），所以我们就可以使用快速幂。</p>
<p>单位矩阵当然变了，由定义可知，单位矩阵就是不使用魔法的，那么就是直接用弗洛伊德跑一遍的结果了。</p>
<p>完整代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 105, M = 2505;
int n, m, k, x[M], y[M], w[M];
struct twt {
	int t[N][N];
	twt() { memset(t, 0x3f, sizeof t); }
	twt operator * (twt b) {
		twt c;
		for(int k = 1; k &lt;= n; k++)
			for(int i = 1; i &lt;= n; i++)
				for(int j = 1; j &lt;= n; j++)
					c[i][j] = std::min(c[i][j], t[i][k] + b[k][j]);
		return c;
	}
	int* operator [] (int x) { return t[x]; };
} a, f;
twt Pow(twt a, int b) {
	twt an = f;
	while(b) {
		if(b &amp; 1) an = an * a;
		a = a * a;
		b &gt;&gt;= 1;
	}
	return an;
}
signed main() {
	scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= n; i++) f[i][i] = 0;
	for(int i = 1; i &lt;= m; i++) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;x[i], &amp;y[i], &amp;w[i]);
		f[x[i]][y[i]] = w[i];
	}
	for(int k = 1; k &lt;= n; k++)
		for(int i = 1;  i &lt;= n; i++)
			for(int j = 1; j &lt;= n; j++)
				f[i][j] = std::min(f[i][j], f[i][k] + f[k][j]);
	for(int k = 1; k &lt;= m; k++) {
		int u = x[k], v = y[k], c = w[k];
		for(int i = 1; i &lt;= n; i++)
			for(int j = 1; j &lt;= n; j++)
				a[i][j] = std::min(a[i][j], std::min(f[i][j], f[i][u]+f[v][j]-c));	
	}
	if(k == 0) printf(&quot;%lld&quot;, f[1][n]);
	else printf(&quot;%lld&quot;, Pow(a, k)[1][n]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 “数链抙玢”]]></title>
        <id>https://acfboy.pw/shulianfubin/</id>
        <link href="https://acfboy.pw/shulianfubin/">
        </link>
        <updated>2021-04-27T03:19:55.000Z</updated>
        <summary type="html"><![CDATA[<p>让我做了一晚上的题，其它作业一直没做，都攻这道了。过了后觉得其实挺好想到的……<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mtext>Update:</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\text{Update:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text" style="color:red;"><span class="mord" style="color:red;">Update:</span></span></span></span></span> 代码又被叉掉了，修正后更新了代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>让我做了一晚上的题，其它作业一直没做，都攻这道了。过了后觉得其实挺好想到的……<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mtext>Update:</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\text{Update:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text" style="color:red;"><span class="mord" style="color:red;">Update:</span></span></span></span></span> 代码又被叉掉了，修正后更新了代码。</p>
<!-- more -->
<p>先普及一下两个生僻字：</p>
<figure data-type="image" tabindex="1"><img src="https://www.hualigs.cn/image/6087486d91aa0.jpg" alt="" loading="lazy"></figure>
<p>同“捊”，用手捧的意思。</p>
<figure data-type="image" tabindex="2"><img src="https://www.hualigs.cn/image/608748bb1b3fb.jpg" alt="" loading="lazy"></figure>
<p>玻璃纸又称“赛璐玢”。英文词是由“cellulose”（纤维素）和“diaphane”（透明的）二词合成的。</p>
<p>所以，题目意思就是数链用手捧着玻璃纸把它隔开！（要不还是叫“fu bin” 吧，捧玉挺好的）<s>真是非常形象啊</s>。</p>
<hr>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="mspace newline"></span></span></span></span></p>
<blockquote>
<p>在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数的相邻之间插入乘号或加号，求答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的方案有多少种。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>35</mn><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>p</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">n \le 35, 0 \le p \le 10^9, 0 \le a_i \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p>看到这个数据范围，那么大概率就是折半搜索了。可是直接折半会遇上一个问题，那就是如果这个位置填乘号能构成答案，那么这些答案都不会被我们记下，因为把乘号拼在一起的话前后就有关联了，不能折半搜索。</p>
<p>然后我就想到了一个“歪门邪道”的做法，按照加号个数进行折半搜索，把中间的答案都记录下来，再反着跑一遍。噼里啪啦写完发现连样例都过不了。</p>
<p>两个显然的问题：</p>
<ol>
<li>会重复计算，每个答案在每个加号都会计算一次。</li>
<li>时间复杂度是错的，因为把中间的都得记下来。</li>
</ol>
<p>然后就没辙了，一下午就过去了。</p>
<p>后来晚上仔细一想发现其实很早就有的一个很自然的想法其实是对的，枚举向后的最靠中间的那个加号。听上去很没有道理吧，但它是对的，为什么呢？</p>
<ol>
<li>在枚举点在中间的时候会记录下每一个中间是加号的答案。</li>
<li>然后定下中间是乘的，那么枚举右边第一个是加的到中间就一定是乘号，原来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">2^{\frac{n}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84708em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.84708em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span> 种还是那么多种，不会多出来，所以复杂度是对的。</li>
<li>1 记下了中间是加号的所有答案， 2 记下了中间是乘号的所有答案，不重不漏。</li>
</ol>
<p>然后考虑实现上的问题，感觉实现也挺难的。大体的思路就是第一次搜索到中间然后用 vector 记录下所有的<strong>答案</strong>和<strong>该方案最后一段乘起来的</strong>，然后每向后一个就把所有的答案再用乘号连上新的那个，并重新排序，顺便移除已经不可能的。</p>
<p>但是还有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的情况需要考虑，问题就有点多了起来了，我的程序也屡次因为这个出错，甚至过了之后仍然被我做自己给 hack 了，<s>现在说不定还是错的欢迎 hack</s>。</p>
<p>出问题的关键在于我们为了避免高精度而进行判断如果当前的答案已经大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 了就直接退出，而可能当前的一段可能乘上一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就又不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 了。所以处理的时候不能直接退出，而是打一个标记，如果后面没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 了那么这个状态就只能舍弃，如果有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 再把最后一段的乘积变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 然后重新加入到搜索之中。</p>
<p>同理，我们记录下来的答案也必须要都打上这样的一个标记，在每次乘上当前的数的时候也得进行相同的处理。注意排序的时候要把有标记的放到最后，因为它们是不构成答案的。</p>
<p>然后来理性的分析一下复杂度：</p>
<ol>
<li>正向 dfs 时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">2^{\frac{n}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84708em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.84708em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>， 反向 dfs 复杂度还要乘上二分的复杂度，就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">2^{\frac{n}{2}}\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.19208em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.84708em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>往后循环的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的，然后里面需要跑一遍 dfs, 还需要用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的时间更新每一个答案，然后排序需要的时间是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 的，即  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">2^{\frac{n}{2}} \frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.19208em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.84708em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</li>
<li>所以总的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><msup><mrow><mo fence="true">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^{\frac{n}{2}} \left(\frac{n}{2}\right)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.404018em;vertical-align:-0.35001em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.84708em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.054008em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>。</li>
</ol>
<p>算一下是八千多万，可以通过此题。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define int long long
const int N = 40;
int n, p, a[N], an;
struct twt {
	int val, prod;
	bool over;
	bool operator &lt; (twt b) const {
		return over &lt; b.over || (over == b.over &amp;&amp; val &lt; b.val);
	}
};
std::vector&lt;twt&gt; ans;
typedef std::vector&lt;twt&gt;::iterator twtIT;
void dfs(int t, int sum, int prod, bool flag) {
	if(t &gt; n/2) {
		if(!flag) ans.push_back((twt){sum + prod, prod, 0});
		else ans.push_back((twt){sum+prod, prod, 1});
		return;
	}
	if(sum &gt; p) return;
	if(sum+prod &gt; p) flag = 1;
	if(a[t] == 0 &amp;&amp; flag) dfs(t+1, sum, 0, 0); 
	else if(flag) dfs(t+1, sum, prod, 1);
	else {
		dfs(t+1, sum, prod*a[t], 0);
		dfs(t+1, sum+prod, a[t], 0);
	}
}
void dfs2(int t, int lim,int sum, int prod, bool flag) {
	if(t &lt; lim) {
		int l = std::lower_bound(ans.begin(), ans.end(), (twt){p-sum-prod, 0, 0}) - ans.begin(),
			r = std::upper_bound(ans.begin(), ans.end(), (twt){p-sum-prod, 0, 0}) - ans.begin();
		an += r-l;
		return;
	}
	if(sum &gt; p) return;
	if(sum+prod &gt; p) flag = 1;
	if(a[t] == 0 &amp;&amp; flag) dfs2(t-1, lim, sum, 0, 0);
	else if(flag) dfs2(t-1, lim, sum, prod, 1);
	else {
		if(t != n) dfs2(t-1, lim, sum, prod*a[t], 0);
		dfs2(t-1, lim, sum+prod, a[t], 0);
	}
}
signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p);
	for(int i = 1; i &lt;= n; i++)	scanf(&quot;%lld&quot;, &amp;a[i]);
	dfs(2, 0, a[1], false);
	std::sort(ans.begin(), ans.end());	
	for(int i = n/2+1; i &lt;= n; i++) {
		if(ans.empty()) break;
		dfs2(n, i, 0, 0, false);
		for(int j = 0; j &lt; (signed)ans.size(); j++) 
			if(!ans[j].over) {
				ans[j].val -= ans[j].prod, ans[j].prod *= a[i], ans[j].val += ans[j].prod;
				if(ans[j].prod &gt; p) ans[j].over = 1;
			}
			else if(a[i] == 0) ans[j].val -= ans[j].prod, ans[j].prod = 0, ans[j].over = 0;
		std::sort(ans.begin(), ans.end());
		for(twtIT j = ans.end()-1; j != ans.begin(); j--)
			if(!ans.empty() &amp;&amp; j-&gt;val - j-&gt;prod &gt; p) ans.erase(j);
		if(!ans.empty() &amp;&amp; ans.begin()-&gt;val - ans.begin()-&gt;prod &gt; p) ans.erase(ans.begin());
	}
	dfs2(n, n+1, 0, 0, 0);
	printf(&quot;%lld&quot;, an);
	return 0;
}
</code></pre>
<p>能为了一题不断研究，过了之后仍能找出并修正错误，这才是我心中的 OI !</p>
<p>另外建议加强数据，<s>防止别人和我一样水过</s>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [NOI Online #1 入门组] 跑步]]></title>
        <id>https://acfboy.pw/noio1running/</id>
        <link href="https://acfboy.pw/noio1running/">
        </link>
        <updated>2021-04-26T04:22:07.000Z</updated>
        <summary type="html"><![CDATA[<p>这个解法太妙了，在一堆生成函数中简直是一股清流！</p>
<p>这题其实考察了对 dp 及分块的理解。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这个解法太妙了，在一堆生成函数中简直是一股清流！</p>
<p>这题其实考察了对 dp 及分块的理解。</p>
<!-- more -->
<blockquote>
<p>求将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 分解成若干个<strong>非严格</strong>递增的整数的和的方案数。</p>
</blockquote>
<p>很容易想到一个完全背包的做法，时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的。2020  年 3 月 8 日，我就写了这个做法，<s>而且居然还是二维的。</s></p>
<p>然后有一个绝妙的想法：分块。</p>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mo>⌈</mo><msqrt><mi>n</mi></msqrt><mo>⌉</mo></mrow><annotation encoding="application/x-tex">m=\lceil \sqrt n \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">⌉</span></span></span></span>, 然后把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \ge m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的分开进行处理，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 一定可以达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>（要上取整），所以两边拼出来一定可以有答案。</p>
<p>然后考虑怎么进行处理。</p>
<p>可以令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的数拼出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的方案数。那么这个东西如何进行转移呢？	这里需要考察对动规的理解了，我们推导出一个状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 只需要把它转换成一个不重不漏构造出这个状态的方式的前一步就可以了。</p>
<p>比如完全背包，构造方式一是这一种只取一个，二是这一种再取一个，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 次这样的构造方式可以构造出所有的状态，所以我们就取这种构造方式的上一步转移过来。</p>
<p>这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 有一种很妙的构造方式，那就是每次要么每一个都加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 要么加入一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，因为题目要求是递增的，所以这样子能构造出所有的状态。那么我们只要从这种构造方式的上一个步骤转移过来就可以了。即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][j] = g[i][j-i] + g[i-1][j-m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span>。</p>
<p>然后就把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 一一搭配就可以了，同样因为递增的保证，不需要考虑怎么组合的问题，组合方式是唯一的。枚举小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的和是多少就可以了。即答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><mrow><mo fence="true">(</mo><msub><mi>f</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>×</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></msubsup><msub><mi>g</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i=0}^n \left( f_{m-1,i} \times \sum_{j=0}^m g_{j,n-i} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span>。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define int long long
const int N = 100005, M = 400;
int n, p, g[M][N], f[N], ans;
signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p);
	int m = sqrt(n) + 1;
	f[0] = 1;
	for(int i = 1; i &lt; m; i++) 
		for(int j = i; j &lt;= n; j++) f[j] = (f[j] + f[j-i]) % p;
	g[0][0] = 1;
	for(int i = 1; i &lt; m; i++)
		for(int j = i; j &lt;= n; j++) {
			g[i][j] = g[i][j-i];
			if(j &gt;= m) g[i][j] = (g[i][j] + g[i-1][j-m]) % p;
		}
	int ans = 0;
	for(int i = 0; i &lt;= n; i++) {
		int sum = 0;
		for(int j = 0; j &lt; m; j++) sum = (sum + g[j][n-i]) % p;
		ans = (ans + f[i] * sum) % p;
	}
	printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>