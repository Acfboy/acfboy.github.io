<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的小站</title>
    <updated>2021-04-12T03:14:56.921Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的小站</rights>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #714 (Div. 2) 游记]]></title>
        <id>https://acfboy.pw/cf1513/</id>
        <link href="https://acfboy.pw/cf1513/">
        </link>
        <updated>2021-04-12T03:13:59.000Z</updated>
        <summary type="html"><![CDATA[<p>题目质量棒极了！！！乍一看很不可做，仔细想想问题就迎刃而解，没有一道是秒杀的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>题目质量棒极了！！！乍一看很不可做，仔细想想问题就迎刃而解，没有一道是秒杀的。</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>求一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的排列使有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个山峰。</p>
</blockquote>
<p>先按 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \rightarrow n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的顺序排好，然后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 交换就可以产生一个山峰，而这种方案肯定能尽可能多的产生山峰。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
int T, n, k, a[105];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        if(k &gt; (n+1)/2-1) {
            puts(&quot;-1&quot;);
            continue;
        }
        for(int i = 1; i &lt;= n; i++) a[i] = i;
        for(int i = 2, cnt = 0; i &lt;= n &amp;&amp; cnt &lt; k; i += 2, cnt += 1)
            std::swap(a[i], a[i+1]);
        for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]);
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="b">B</h2>
<blockquote>
<p>一列数，从任意一点断开，若左边的全部 <code>and</code> 起来和右边的全部 <code>and</code> 起来都一样就说它是好的，问将输入的数列任意打乱有多少个是好的。</p>
</blockquote>
<p>一看是没有什么思路的。</p>
<p>仔细想想可以发现，那些哪一位其它数有一而它这一位是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的都得放在前后，不然的话在它前面断开就会一边有这样一位没有边为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 而另一边变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 了， 不能称为好的序列， 所以这样的选俩放首尾，其它的中间随便排就可以了。</p>
<p>代码还是有些细节的。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 200005, p = 1000000007;
int a[N], T, n;
bool vis[N];
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%lld&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]);
        memset(vis, 0, sizeof vis);
        bool twt = 0, did = 0;
        for(int i = 0; i &lt;= 30; i++) {
            bool flag = 0, tw = 0;
            for(int j = 1; j &lt;= n; j++) 
                if((1ll &lt;&lt; i) &amp; a[j]) tw = 1;
                else flag = 1;
            flag = flag &amp;&amp; tw;
            if(!flag) {
                for(int j = 1; j &lt;= n; j++) 
                    if(did &amp;&amp; vis[j] == 0) vis[j] = 0;
                    else vis[j] = 1;
                continue;
            }
            for(int j = 1; j &lt;= n; j++)
                if(((1ll &lt;&lt; i) &amp; a[j]) == 0ll) {
                    if(did &amp;&amp; vis[j] == 0) vis[j] = 0;
                    else vis[j] = 1;
                }
                else vis[j] = 0;
            did = 1;
            if(twt) break;
        }
        if(twt) {
            puts(&quot;0&quot;);
            continue;
        }
        int cnt = 0;
        for(int j = 1; j &lt;= n; j++) cnt += vis[j];
        int ans = cnt * (cnt-1) % p;
        int tans = 1;
        for(int i = 1; i &lt;= n-2; i++) tans = tans * i % p;
        ans = ans * tans % p;
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<h2 id="c">C</h2>
<blockquote>
<p>把一个整数中每一个位都变为其加上一的数字， <code>9</code> 变为 <code>10</code>, 问变 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次后数字长度是多少。</p>
</blockquote>
<p>可怜的孩子没看清数据范围，看成保证所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 和不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>, 以为这是一个简单 dp, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 次后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 出现了几次，最后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi>f</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum f[m][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 就是答案，然后顺利 T 飞。</p>
<p>不过这样的 DP 还有没有救呢？枚举几个小样例发现每个数都是独立变化的，既然独立变化，那么分开考虑，发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mo>−</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">10-d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 次后都变成 <code>10</code> 继续变换了，那么只要能快速处理出 <code>10</code> 的变化就可以快速得出所有的变化。</p>
<p>一开始我一直想着有啥数学方法可做，后来一看，直接预处理一遍把所有次数以后的变换处理完不就得了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int p = 1000000007;
int T, x, m, f[200005][10];
int get(int x) {
    if(x &lt; 0) return 1;
    int an = 0;
    for(int i = 0; i &lt;= 9; i++) an = (an + f[x][i]) % p;
    return an;
}
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    f[0][1] = f[0][0] = 1;
    for(int i = 1; i &lt;= 200000; i++) {
        for(int j = 9; j &gt;= 1; j--) f[i][j] = f[i-1][j-1];
        f[i][0] = 0;
        f[i][0] = (f[i][0] + f[i-1][9]) % p;
        f[i][1] = (f[i][1] + f[i-1][9]) % p;
    }
    while(T--) {
        scanf(&quot;%lld%lld&quot;, &amp;x, &amp;m);
        int ans = 0;
        while(x) {
            int d = x % 10;
            ans = (ans + get(m - (10-d))) % p;
            x /= 10;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<hr>
<p>本想着上 expert, 结果卡在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#5ac5ac"><mn>1596</mn></mstyle></mrow><annotation encoding="application/x-tex">\color{#5ac5ac}1596</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord" style="color:#5ac5ac;">1</span><span class="mord" style="color:#5ac5ac;">5</span><span class="mord" style="color:#5ac5ac;">9</span><span class="mord" style="color:#5ac5ac;">6</span></span></span></span> ! 太让我失望了，要是看清题目，那 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> 分不扣说不定就上蓝了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AtCoder Beginner Contest 198 游记]]></title>
        <id>https://acfboy.pw/abc198/</id>
        <link href="https://acfboy.pw/abc198/">
        </link>
        <updated>2021-04-12T03:13:20.000Z</updated>
        <summary type="html"><![CDATA[<p>PB 了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>PB 了。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题</p>
<h2 id="b">B</h2>
<p>水题</p>
<h2 id="c">C</h2>
<blockquote>
<p>给定坐标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, 每次只能跳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>, 从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 跳到其要多少？</p>
</blockquote>
<p>稍加观察就可以发现，就是距离除一下然后上取整就好了，因为越过的直接把前面一个弯一下就即可。</p>
<p>然后顺利地 WA 了。</p>
<p>一直以为是精度问题，最后发现是一次就跳到的要特判。</p>
<p>WA 了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 次，罚时吃饱。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
int r, x, y;
int main() {
    scanf(&quot;%d%d%d&quot;, &amp;r, &amp;x, &amp;y);
    double dis = sqrt((double)x*x + (double)y*y);
    double ans = ceil(dis / (double)r);
    if(ans == 1 &amp;&amp; ceil(dis / (double)r) != floor(dis / (double)r)) ans++;
    printf(&quot;%.0lf&quot;, ans);
}
</code></pre>
<h2 id="d">D</h2>
<p>一看数据范围，直接搜索就可以了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#define int long long
char s[4][15];
int len[4], num[256];
bool vis[15];
void dfs(int l, int t, int n1, int n2, int n3) {
    if(l == 3 &amp;&amp; t &gt; len[3]) {
        if(n1 + n2 == n3) {
            printf(&quot;%lld\n%lld\n%lld&quot;, n1, n2, n3);
            exit(0);
        }
        return;
    }
    if(t &gt; len[l]) {
        dfs(l+1, 1, n1, n2, n3);
        return ;
    } 
    if(num[s[l][t]] != -1) {
        if(l == 1) dfs(l, t+1, n1*10+num[s[l][t]], n2, n3);
        if(l == 2) dfs(l, t+1, n1, n2*10+num[s[l][t]], n3);
        if(l == 3) dfs(l, t+1, n1, n2, n3*10+num[s[l][t]]);
        return ;
    }
    for(int i = 0; i &lt;= 9; i++) {
        if(t == 1 &amp;&amp; i == 0) continue;
        if(vis[i]) continue;
        num[s[l][t]] = i;
        vis[i] = 1;
        if(l == 1) dfs(l, t+1, n1*10+i, n2, n3);
        if(l == 2) dfs(l, t+1, n1, n2*10+i, n3);
        if(l == 3) dfs(l, t+1, n1, n2, n3*10+i);
        vis[i] = 0;
        num[s[l][t]] = -1;
    }
}
signed main() {
    scanf(&quot;%s%s%s&quot;, s[1]+1, s[2]+1, s[3]+1);
    for(int i = 1; i &lt;= 3; i++) 
        len[i] = strlen(s[i]+1);
    memset(num, -1, sizeof num);
    dfs(1, 1, 0, 0, 0);
    printf(&quot;UNSOLVABLE&quot;);
    return 0;
}
</code></pre>
<h2 id="e">E</h2>
<p>今天 E 那么水？？？</p>
<p>达成 PB, Rank 575, 本来还可以更高的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #713 (Div. 3) 游记]]></title>
        <id>https://acfboy.pw/cf1512/</id>
        <link href="https://acfboy.pw/cf1512/">
        </link>
        <updated>2021-04-12T03:11:28.000Z</updated>
        <summary type="html"><![CDATA[<p>庆祝上分！<br>
Div.3 果然是信心赛！</p>
]]></summary>
        <content type="html"><![CDATA[<p>庆祝上分！<br>
Div.3 果然是信心赛！</p>
<!-- more -->
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cwvgII"><img src="https://z3.ax1x.com/2021/04/11/cwvgII.png" alt="cwvgII.png" loading="lazy"></a></figure>
<h2 id="a">A</h2>
<blockquote>
<p>找到若干个数中与众不同的一个</p>
</blockquote>
<p>水题。</p>
<p>记个数或者排个序都可以。</p>
<h2 id="b">B</h2>
<blockquote>
<p>输入一个图形，标记了矩形的其中两个端点，求剩下俩端点。</p>
</blockquote>
<p>分类讨论补全，注意细节。</p>
<h2 id="c">C</h2>
<blockquote>
<p>输入一个字符串，用 <code>1</code> 或 <code>0</code> 填充 <code>?</code>, 使回文且恰好 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个 <code>0</code>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个 <code>1</code></p>
</blockquote>
<p>注意得先把确定的都填完，然后能填哪个就填哪个就可以了。</p>
<p>开始没注意要先把确定的都填完， WA 了两次。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int N = 200005;
int T, a, b;
char st[N];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d%d&quot;, &amp;b, &amp;a);
        scanf(&quot;%s&quot;, st+1);
        int n = strlen(st+1);
        for(int i = 1; i &lt;= n; i++)
            if(st[i] == '1') a--;
            else if(st[i] == '0') b--;
        bool flag = 0;
        // printf(&quot;%d %d %d\n&quot;, b, a, flag);
        for(int i = 1; i &lt;= n/2; i++) {
            if(st[i] != '?' &amp;&amp; st[n-i+1] != '?') {
                if(st[i] != st[n-i+1]) {
                    flag = 1;
                    break;
                }
                else continue;
            }
            if(st[i] == '1') a -= 1, st[n-i+1] = '1';
            else if(st[n-i+1] == '1') a -= 1, st[i] = '1';
            else if(st[i] == '0') b -= 1, st[n-i+1] = '0';
            else if(st[n-i+1] == '0') b -= 1, st[i] = '0';
        }
        for(int i = 1; i &lt;= n/2; i++) {
            if(st[i] == '?' &amp;&amp; st[n-i+1] == '?') {
                if(a &gt; 1) a -= 2, st[i] = st[n-i+1] = '1';
                else b -= 2, st[i] = st[n-i+1] = '0';
            }
        }
        if(n % 2 == 1 &amp;&amp; st[n/2+1] == '?')     
            if(a) a--, st[n/2+1] = '1';
            else st[n/2+1] = '0', b--;
        if(flag || a != 0 || b != 0) puts(&quot;-1&quot;);
        else printf(&quot;%s\n&quot;, st+1);
    }
    return 0;
}
</code></pre>
<h2 id="d">D</h2>
<blockquote>
<p>不告诉你 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, 只知道有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>, 前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i = a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 最后俩一个是前面数的和，另一个是随便写的，求一个可能的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。</p>
</blockquote>
<p>和肯定是最大的嘛！所以记一个最大和次大就好了。</p>
<h2 id="e">E</h2>
<blockquote>
<p>求出一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的排列使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>l</mi></mrow><mi>r</mi></msubsup><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">\sum_{i=l}^r p_i = s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></p>
</blockquote>
<p>那么只要求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r-l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的不同数恰好为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>, 然后随便填就可以了。</p>
<p>拼只需要让前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>→</mo><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">1\rightarrow (r-l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>, 然后慢慢调整就可以了。</p>
<p>具体地：</p>
<ol>
<li>排完后若最后一个数比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 小那直接上。</li>
<li>否则，前面 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个能统一加的就加</li>
<li>加完 1 的还有剩下就从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个开始往前一个个加。</li>
<li>若有冲突就不成立。</li>
</ol>
<p>这样的做法保证了倒数俩的距离尽可能大，同时满足条件，如果还得冲突，那肯定不行。</p>
<p>同样要注意细节，以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r = l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 时要特殊处理。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int T, n, l, r, s, flag[505], a[505];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        memset(flag, 0, sizeof flag);
        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;l, &amp;r, &amp;s);
        int len = r - l + 1;
        if(s &lt; (1+len) * len / 2 || (n-len+1+n) * len / 2 &lt; s) { 
            puts(&quot;-1&quot;);
            continue;
        }
        bool twt = 0;
        if(len != 1) {
            int sum = 0;
            for(int i = 1; i &lt; len; i++) a[i] = i, sum += i;
            sum = s - sum - n;
            // printf(&quot;%d\n&quot;, sum);
            int delta = sum / (len - 1);
            if(sum &gt; 0) {
                for(int i = 1; i &lt; len; i++) a[i] += delta;
                sum -= sum / (len-1) * (len-1);
            }
            for(int i = len-1; i &gt;= 1 &amp;&amp; sum &gt; 0; i--, sum--) a[i] ++;
            a[len] = n;
            if(sum &lt; 0) {
                while(sum &lt; 0) a[len]--, sum++;
            }
            for(int i = 1; i &lt;= len; i++) flag[a[i]] ++;
        }
        else if(s &gt; n) twt = 1;
        else flag[s] = 1, a[1] = s;
        for(int i = 1; i &lt;= n; i++)         
            if(flag[i] &gt; 1) twt = 1;
        if(twt) {
            puts(&quot;-1&quot;);
            continue;
        }
        int now = 1;
        for(int i = 1; i &lt; l; i++) {
            while(flag[now]) now++;
            printf(&quot;%d &quot;, now);
            now ++;
        }
        for(int i = 1; i &lt;= len; i++) printf(&quot;%d &quot;, a[i]);
        for(int i = r+1; i &lt;= n; i++) {
            while(flag[now]) now++;
            printf(&quot;%d &quot;, now);
            now ++;
        }
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="f">F</h2>
<blockquote>
<p>开始有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 元，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 级每天可领取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 元或花费 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 升级， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 单调递增。最少几天总钱数大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p>
</blockquote>
<p>那要升级肯定是早升更好，所以直接枚举最后到哪级，算出答案取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span> 就好了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define int long long
const int N = 200005;
int T, n, c, a[N], b[N], ans;
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%lld%lld&quot;, &amp;n, &amp;c);
        ans = 0x3f3f3f3f3f3f3f3fll;
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]);
        for(int i = 1; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;b[i]);
        int now = 0, nd = 0;
        for(int i = 1; i &lt;= n; i++) {
            ans = std::min(ans, nd + (c - now + a[i]-1) / a[i]);
            int d = (b[i] - now + a[i]-1) / a[i];
            // printf(&quot;*%lld %lld %lld %lld\n&quot;, ans, d, now, nd);
            now = now + d * a[i] - b[i], nd += d+1; // 注意升级也要天数。
        }
        printf(&quot;%lld\n&quot;, ans);
    }
}
</code></pre>
<h2 id="g">G</h2>
<p>唯一有真正难度的一题。</p>
<p>数论题。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></msub><mi>k</mi></mrow><annotation encoding="application/x-tex">d(n) = \sum_{k|n} k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 求最小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">d(n) = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p>
</blockquote>
<p>这玩意儿居然有积性。</p>
<p>欧拉筛一遍二分即可。</p>
<p>但赛场上没时间也想不到。</p>
<p>好好看 《初等数论》 吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.4.7 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210407/</id>
        <link href="https://acfboy.pw/20210407/">
        </link>
        <updated>2021-04-07T06:50:55.000Z</updated>
        <summary type="html"><![CDATA[<p>似乎全是水题，但我还是没有做出来......</p>
]]></summary>
        <content type="html"><![CDATA[<p>似乎全是水题，但我还是没有做出来......</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>求将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 分解为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个不同质数的和的方案数</p>
</blockquote>
<p>考虑 dp, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 分解为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个的方案，但因为要求不同，所以没有办法确定枚举范围，开始时我傻乎乎的以为只要枚举的质数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>p</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">i-pr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 就可以了，但这样显然是错的。反例是 <code>15 3</code>。</p>
<p>于是加一个维度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 表示用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个质数，最后一个是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>, 拼出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的方案数，转移的时候再枚举上个最后一个就好了，这样子要三维状态加一维转移，实在太慢，无法忍受。观察发现转移时需要的都是从头开始的一段的和，答案是所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>K</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[n][j][K]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">]</span></span></span></span> 的和，所以直接把这玩意儿做成前缀和就好了。</p>
<p>代码。(把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 放到了最后一个维度，为了方便。)</p>
<pre><code class="language-cpp">Seive(n);
for(int i = 1; i &lt;= nump; i++) 
	for(int j = i; j &lt;= nump; j++) f[pr[i]][1][j] = 1;
for(int i = 1; i &lt;= n; i++)
	for(int j = 2; j &lt;= k; j++)
		for(int k = 1; k &lt;= nump; k++) {
			f[i][j][k] = f[i][j][k-1];
			if(i - pr[k] &gt;= 0) f[i][j][k] += f[i-pr[k]][j-1][k-1];
		}
printf(&quot;%lld\n&quot;, f[n][k][nump]); 
</code></pre>
<h2 id="b">B</h2>
<p>bfs 基础题，没有技术含量。</p>
<h2 id="c">C</h2>
<blockquote>
<p>给定一个矩阵，只能向下和向右走，求路径上数的乘积最后的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的最少数量。</p>
</blockquote>
<p>最少的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就是经过的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 因子个数和 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 因子个数和中最小的那个，所以题目要求就是最小的最小，最小的最小不就是最小吗！直接分开跑一遍取最小就可以了。</p>
<p>可是我比赛的时候很呆的没想到，只想着若确定了一个最小，则另一个数字最小的状态是最优的，于是还记了经过的具体 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的数量，写出来的代码复杂得多， 浪费了一些时间来调试。</p>
<p>代码也放着留作纪念吧。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt; 
const int N = 1005, INF = 100000000;
int n, x, num2[N][N], num5[N][N];
struct twt2 {
	int sum2, sum5;
	bool operator &lt; (twt2 b) const {
		return sum2 &lt; b.sum2 ||
			  (sum2 == b.sum2 &amp;&amp; sum5 &lt; b.sum5);
	}
} f2[N][N];
struct twt5 {
	int sum2, sum5;
	bool operator &lt; (twt5 b) const {
		return sum5 &lt; b.sum5 ||
			  (sum5 == b.sum5 &amp;&amp; sum2 &lt; b.sum2);
	}
} f5[N][N];
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) 
		for(int j = 1; j &lt;= n; j++) {
			scanf(&quot;%d&quot;, &amp;x);
			if(x == 0) { num2[i][j] = -1; continue; }
			while(x % 2 == 0) num2[i][j] ++, x /= 2;
			while(x % 5 == 0) num5[i][j] ++, x /= 5;
		}
	for(int i = 1; i &lt;= n; i++) 
		f2[0][i].sum2 = INF, f5[0][i].sum5 = INF,
		f2[i][0].sum2 = INF, f5[i][0].sum5 = INF;
	f2[1][1].sum2 = num2[1][1], f2[1][1].sum5 = num5[1][1];
	f5[1][1].sum2 = num2[1][1], f5[1][1].sum5 = num5[1][1];	
	for(int i = 1; i &lt;= n; i++)	
		for(int j = 1; j &lt;= n; j++) {
			if(i == 1 &amp;&amp; j == 1) continue; 
			if(num2[i][j] == -1) {
				f2[i][j].sum2 = INF;
				continue;
			}
			f2[i][j] = std::min(f2[i-1][j], f2[i][j-1]);
			f2[i][j].sum2 += num2[i][j], f2[i][j].sum5 += num5[i][j];
		}
	for(int i = 1; i &lt;= n; i++)	
		for(int j = 1; j &lt;= n; j++) {
			if(i == 1 &amp;&amp; j == 1) continue; 
			if(num2[i][j] == -1) {
				f5[i][j].sum5 = INF;
				continue;
			}
			f5[i][j] = std::min(f5[i-1][j], f5[i][j-1]);
			f5[i][j].sum2 += num2[i][j], f5[i][j].sum5 += num5[i][j];
		} 
	return 0;
} 
</code></pre>
<h2 id="d">D</h2>
<p>题目未修改全文如下。</p>
<blockquote>
<p>恭喜你，成为了牛牛航空公司的老板。<br>
公司中有N个飞行员，有N/2架飞机。每架飞机需要配置两个飞行员，一个是机长，一个是助手。</p>
<p>现在你了解到了一些信息，比如每个飞行员当机长时希望获得的工资，和当助手时希望获得的工资。且每个飞行员都只愿意为比自己年纪大的人当助手。</p>
<p>现在需要你安排着N个人，到指定的飞机工作。如何做才能使得你需要支付的工资总数最小呢？</p>
</blockquote>
<p>刚看到这个题目的时候就很奇怪这是什么年代的题目，为什么不是副驾驶 (co-polit/first officer) 而是助手？难道和 &quot;Berd and his man&quot; 是同一个年代的？</p>
<p>那么有没有具体规定应该怎么叫呢？</p>
<p>找了行情资料汇编并没有找到，看了民航法也没有规定具体的称呼，不过 ICAO 有一个 Q&amp;A 中提到了</p>
<blockquote>
<p>What is the MPL?</p>
<p>The MPL allows a pilot to exercise the privileges of a co-pilot in a commercial air transportation on multi-crew aeroplanes. It provides the aviation community with an opportunity to train pilots directly for co-pilot duties.</p>
</blockquote>
<p>其中说了一个是机长，另一个是 co-polit 或 first officer。</p>
<p>在 CAAC 的网站能搜索到很多关于副驾驶的资料，如 <a href="http://www.caac.gov.cn/XXGK/XXGK/ZCJD/202006/t20200609_203001.html">这个</a></p>
<p><strong>好了，接下来才是正经事。</strong></p>
<p>其实这题就是要每组两个数选一个，只不过有一些限制。</p>
<p>如果没有限制，直接 dp 很简单，但有限制后有后效性。一般解决后效性的办法是改变转移顺序，对于这题，从后往前就好了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 1e4 + 10;
int n, f[2][N], a[N], b[N];
signed main() {
    memset(f, 0x7f, sizeof(f));
    scanf(&quot;%lld&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld%lld&quot;, &amp;a[i], &amp;b[i]);
    f[0][0] = a[n];
    for (int i = n - 1; i &gt;= 1; i--) {
        f[i &amp; 1][0] = f[i &amp; 1 ^ 1][0] + a[i];
        for (int j = 1; j &lt;= (n - i + 1) / 2; j++)
            f[i &amp; 1][j] = std::min(f[i &amp; 1 ^ 1][j] + a[i], f[i &amp; 1 ^ 1][j - 1] + b[i]);
    }
    printf(&quot;%lld&quot;, f[1][n / 2]);
}
</code></pre>
<p>比赛时一直在想着匹配的问题，没有想到 dp, 一直纠结于匹配了，最后搞了一个显然错的贪心，用 FTT（Fast Tanweitan Transform,快速谭炜谭变换）后获得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 分。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2007]动物园]]></title>
        <id>https://acfboy.pw/apio2007dongwuyuan/</id>
        <link href="https://acfboy.pw/apio2007dongwuyuan/">
        </link>
        <updated>2021-04-04T23:29:46.000Z</updated>
        <summary type="html"><![CDATA[<p>感觉对这类在环上的状压问题很不熟悉（其实也不是环的原因），来记录一下心得。</p>
<p>其实，这不是一篇题解。</p>
]]></summary>
        <content type="html"><![CDATA[<p>感觉对这类在环上的状压问题很不熟悉（其实也不是环的原因），来记录一下心得。</p>
<p>其实，这不是一篇题解。</p>
<!-- more -->
<p>题面……难以概括。</p>
<p>这题的第一篇题解写的非常清楚，只是令我不太理解的是为什么这样的一个仅有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 为状压的状态能代表最后的结果。</p>
<p>展示一下方程。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>S</mi></mrow></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>{</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>(</mo><mi>S</mi><mi mathvariant="normal">&amp;</mi><mn>15</mn><mo>)</mo><mo>×</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mo>(</mo><mi>S</mi><mi mathvariant="normal">&amp;</mi><mn>15</mn><mo>)</mo><mo>×</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow></msub><mo>}</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f_{i,S} = \max\{f_{i-1, (S\&amp;15) \times2}, f_{(S\&amp; 15) \times 2 + 1}\} + num[i][S]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">&amp;</span><span class="mord mtight">1</span><span class="mord mtight">5</span><span class="mclose mtight">)</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">&amp;</span><span class="mord mtight">1</span><span class="mord mtight">5</span><span class="mclose mtight">)</span><span class="mbin mtight">×</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span></span></p>
<p>写出这个方程的精髓就在于，记录了当前之前的 若干个有用状态，并能从前面的状态继承答案，又能利于推出下面的状态。</p>
<p>意思是说，虽然只记录了五个东西的状态，但是记录的是到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 为止的答案，因为无后效性，使得这样子继承前面的答案并转移可以得到到当前这一位的答案，感觉很神奇的样子。</p>
<p>其实和 [NOI2001] 炮兵阵地 是同理的，只记录当前两行的状态，却能得到前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行的答案，状压说白了就是将有后效性的部分状压掉放进状态里，使剩下的没有后效性。</p>
<p>另一个使我注意的地方在于，一类问题是形成环的，即开始的状态和结尾的状态时一模一样的。如这道题和 [SCOI2009]围豆豆。</p>
<p>处理这个问题的方法在这道题中表现为将除了初始状态的其它状态都设置为负无穷，并在最外层枚举起始/终结点，这是要求起始和结束状态完全一样的情况。</p>
<p>但在豆豆那题中，起始和结尾状态时可以不一样的，也可以一样，所以直接看做不同的点按照原来的 bfs 处理就可以了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #712 (Div. 2) 游记]]></title>
        <id>https://acfboy.pw/cf1504/</id>
        <link href="https://acfboy.pw/cf1504/">
        </link>
        <updated>2021-04-04T01:21:28.000Z</updated>
        <summary type="html"><![CDATA[<p>掉分。</p>
<p>本想着破釜沉舟成 expert, 结果差点掉成 pupil。</p>
]]></summary>
        <content type="html"><![CDATA[<p>掉分。</p>
<p>本想着破釜沉舟成 expert, 结果差点掉成 pupil。</p>
<!-- more -->
<p>因为上次打得比较好，所以感觉离蓝名不远了，所以直接开了 C 题，希望能通过 CBAD 的做题顺序获得更高的分数。</p>
<p>然后 C 题就翻车了，一开始想了一个复杂而错误的解法，WA 了两发才发觉做法不对。</p>
<p>后来发现是我想难了，这其实是一道很简单的题。</p>
<h2 id="c">C</h2>
<p>看题，观察了一下样例和自己的小数据，发现了一个似乎显而易见的结论，如果原串可以被分成几个长度为偶数的，一开头的回文，那么上面类似 <code>()()</code> 的结构，下面用根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 串来做就可以了。</p>
<p>判断回文我选择了字符串哈希。</p>
<p>想到这个用的时间就比较的久，写得也比较慢，哈希最开始也写错了。然后到快一个小时才交第一发，当然，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">Wrong</mtext><mtext> </mtext><mtext mathvariant="monospace">answer</mtext><mtext> </mtext><mtext mathvariant="monospace">on</mtext><mtext> </mtext><mtext mathvariant="monospace">pretest</mtext><mtext> </mtext><mtext mathvariant="monospace">2</mtext></mrow><annotation encoding="application/x-tex">\texttt{Wrong answer on pretest 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Wrong answer on pretest 2</span></span></span></span></span>。</p>
<p>然后还抱着这个想法不肯放手，发现了一个小问题，但改完继续 WA, 代码也放一放吧，纪念。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 200005, p = 998244353;
std::vector&lt;char&gt; ans1, ans2;
char st[N];
int hashb[N], hashf[N], pow[N], T, n;
void init() {
    memset(hashb, 0, sizeof hashb);
    memset(hashf, 0, sizeof hashf);
    ans1.clear();
    ans2.clear();
}
bool check(int l, int r) {
    int mid = l + (r-l)/2;
    int hf = (hashf[mid] - hashf[l-1] + p) % p, hb = (hashb[mid+1] - hashb[r+1] + p) % p;
    int len0f = l-1, len0b = n-r;
    if(len0f &gt; len0b) hb = hb * pow[len0f - len0b] % p;
    else hf = hf * pow[len0b - len0f] % p;
    if(hf == hb) return true;
    else return false;
}
void getans(int l, int r) {
    for(int i = l; i &lt;= r; i++) ans1.push_back(((i-l) % 2 == 0) ? '(' : ')');
    for(int i = l; i &lt;= r; i++) 
        if(st[i] == '1') ans2.push_back(((i-l) % 2 == 0) ? '(' : ')');
        else ans2.push_back(((i-l) % 2 == 0) ? ')' : '(');
}
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%lld&quot;, &amp;n);
        scanf(&quot;%s&quot;, st+1);
        init();
        pow[0] = 1;
        for(int i = 1; i &lt;= n; i++) pow[i] = pow[i-1] * 2 % p;
        for(int i = n; i &gt;= 1; i--) hashb[i] = (hashb[i+1]  + (st[i] - '0' + p) % p * pow[n-i] % p) % p;
        for(int i = 1; i &lt;= n; i++) hashf[i] = (hashf[i-1]  + (st[i] - '0' + p) % p * pow[i-1] % p) % p;
        int now = 0;
        st[n+1] = '1';
        for(int i = 1; i &lt;= n; i++) 
            if((i - now) % 2 == 0 &amp;&amp; st[now+1] == '1' &amp;&amp; check(now+1, i) ) {
                getans(now+1, i);
                now = i;
            }
        if((signed)ans1.size() &lt; n) puts(&quot;NO&quot;);
        else {
            puts(&quot;YES&quot;);
            for(int i = 0; i &lt; (signed)ans1.size(); i++) printf(&quot;%c&quot;, ans1[i]);
            puts(&quot;&quot;);
            for(int i = 0; i &lt; (signed)ans2.size(); i++) printf(&quot;%c&quot;, ans2[i]);
            puts(&quot;&quot;);
        }
    }
}
</code></pre>
<p>哈希来判这样的回文倒是挺棒的想法，但是 hack 数据很显然。</p>
<pre><code class="language-plain">11110011
</code></pre>
<p>虽然仍然是可以划分，但是我们的程序并不知道正确的划分位置，而且就算正确划分了，也不能得到正确答案。</p>
<p>写了那么多的代码，当然不肯放弃，觉得可能就是个小问题，所以一直想改改解决。</p>
<p>然后发现解决不了，终于放弃。</p>
<p>接着发现有很简单的做法。</p>
<p>即中间的 <code>0</code> 的部分反转后都是可以匹配的，只需要左右有多出来的就可以了，但是左右仍然要匹配。</p>
<p>所以找左右 <code>0</code> 之前较少的 <code>1</code> 的个数，括号向中间靠拢，其它的 <code>0</code> 和 <code>1</code> 分开正常匹配就可以了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
const int N = 200005;
int T, n;
char st[N], ans1[N];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d&quot;, &amp;n);
        scanf(&quot;%s&quot;, st+1);
        int num1f = 0, num1b = 0;
        for(int i = 1; i &lt;= n; i++) {
            if(st[i] == '0') break;
            num1f ++;
        }
        for(int i = n; i &gt;= 1; i--) {
            if(st[i] == '0') break;
            num1b ++;
        }
        if(num1f == 0 || num1b == 0) {
            puts(&quot;NO&quot;);
            continue;
        }
        int k = 0, flag1 = 0, flag0 = 0;
        if(num1b != n) k = std::min(num1f, num1b);
        for(int i = 1; i &lt;= k; i++) ans1[i] = '(';
        for(int i = n; i &gt;= n-k+1; i--) ans1[i] = ')';
        for(int i = k+1; i &lt;= n-k; i++) 
            if(st[i] == '1') {
                if(flag1) ans1[i] = ')';
                else ans1[i] = '(';
                flag1 = 1^flag1;
            }
            else {
                if(flag0) ans1[i] = ')';
                else ans1[i] = '(';
                flag0 = 1^flag0;
            }
        if(flag1 || flag0) puts(&quot;NO&quot;);
        else {
            puts(&quot;YES&quot;);
            for(int i = 1; i &lt;= n; i++) printf(&quot;%c&quot;, ans1[i]);
            puts(&quot;&quot;);
            for(int i = 1; i &lt;= n; i++) 
                if(st[i] == '1') printf(&quot;%c&quot;, ans1[i]);
                else printf(&quot;%c&quot;, (ans1[i] == '(') ? ')' : '(');
            puts(&quot;&quot;);
        }
    }
}
</code></pre>
<p>A 题是道有些细节的题，也花了我一定的时间，最后没有机会做 B 了，于是惨痛掉分。</p>
<p>所以题目开始写代码之前一定要想清楚，一定要验证好正确性，不然只会浪费大量的时间。</p>
<hr>
<p>虽然陷入了一个低谷，但不可被此打倒而整天郁郁寡欢，振作起来，去完成目标，去实现梦想！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC009B] Tournament]]></title>
        <id>https://acfboy.pw/agc009b/</id>
        <link href="https://acfboy.pw/agc009b/">
        </link>
        <updated>2021-04-03T09:23:55.000Z</updated>
        <summary type="html"><![CDATA[<p>我记得 CF 也有一题是这个名字，当时做到感觉从题意到做法都很难懂，有些阴影，所以又做了这题。</p>
<p>这题代码非常短，但一看题面还是觉得一副不可做的样子，<s>所以叫这名字的没一个好东西</s>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我记得 CF 也有一题是这个名字，当时做到感觉从题意到做法都很难懂，有些阴影，所以又做了这题。</p>
<p>这题代码非常短，但一看题面还是觉得一副不可做的样子，<s>所以叫这名字的没一个好东西</s>。</p>
<!-- more -->
<blockquote>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个选手进行淘汰赛，每场比赛后输的一方就会立刻被淘汰。现在比赛已经结束，我们已知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号是最后的胜者，而第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>(</mo><mi>i</mi><mo>&gt;</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">i(i&gt;1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 号是被 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 号淘汰的。求获得胜利需要比赛最多的人最少的比赛次数。</p>
</blockquote>
<p>考虑建出题目中的那一棵树，那这棵树是什么意义呢？即父亲淘汰了它的一堆儿子。</p>
<p>由于淘汰以后和比赛无关，没有后效性，又显然有最优子结构性质，所以考虑进行树形 dp. 令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">f_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 这个点的答案，那么由于它被它父亲给淘汰，所以和父亲比试要么父亲的答案要增加一场，但如果儿子的答案更大的话，那么得看作儿子多比一场，所以只要确定一个顺序来比赛即可。</p>
<p>显然，儿子答案小的来最优。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
const int N = 100005;
int n, x, f[N];
std::vector&lt;int&gt; g[N];
bool cmp(int x, int y) {return f[x] &lt; f[y];}
void dfs(int u) {
    for(int i = 0; i &lt; g[u].size(); i++) dfs(g[u][i]);
    std::sort(g[u].begin(), g[u].end(), cmp);
    for(int i = 0; i &lt; g[u].size(); i++) f[u] = std::max(f[u], f[g[u][i]]) + 1;
}
int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 2; i &lt;= n; i++) {
        scanf(&quot;%d&quot;, &amp;x);
        g[x].push_back(i);
    }
    dfs(1);
    printf(&quot;%d&quot;, f[1]);
    return 0;
}
</code></pre>
<p>是一道好题，讲起来简单，但思路有点难以想到，也不是很好理解这个转移，不愧是 AGC.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [BalticOI 2004]Sequence 数字序列]]></title>
        <id>https://acfboy.pw/balticoi2004sequence/</id>
        <link href="https://acfboy.pw/balticoi2004sequence/">
        </link>
        <updated>2021-04-03T03:56:38.000Z</updated>
        <summary type="html"><![CDATA[<p>感觉是很有意思的一道题，巧妙运用了可并堆来动态维护中位数，还有改严格递增为非严格的 trick, 感觉都挺妙的，不是那么容易想到。</p>
]]></summary>
        <content type="html"><![CDATA[<p>感觉是很有意思的一道题，巧妙运用了可并堆来动态维护中位数，还有改严格递增为非严格的 trick, 感觉都挺妙的，不是那么容易想到。</p>
<!-- more -->
<blockquote>
<p>给出序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 求严格单调递增序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，使得  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mi>i</mi></msub><mo>−</mo><msub><mi>B</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\sum |A_i-B_i|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> 最小</p>
</blockquote>
<p>考虑以下结论:</p>
<ol>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 递增则令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B = A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 即可</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 递减则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 中所有数都相同且是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的中位数最优。</li>
</ol>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 递增了反而拉开更大距离，没用，所以每一个数都相同；然后就变成了初中数学题，显然取中位数最优。</p>
<p>可是题目要求严格，那么我们可以把每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>， 最后再补上去，这样差不会有变化而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 就可以不严格了，因为若相同，最后差还是会有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 而差不能为负，所以加上后肯定不会相同。感觉挺妙的。</p>
<p>然后我们可以把每个数都单独作为一份，取的都是它自己。合并时按照原来的原则，如果下降了就用新的中位数，上升了那直接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B = A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 就可以了。</p>
<p>怎么维护能合并的中位数呢？原来动态维护中位数用堆，我们这里可以使用可并堆，每次维护当前区间最大的几个就可以了。</p>
<p>最后计算答案并把每一块中的答案都输出就好了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define int long long
const int N = 1000005;
int n, a[N], val[N], L[N], R[N], rt[N], size[N], cnt,
    ls[N], rs[N], dis[N], ans;
int merge(int x, int y) {
    if(x == 0 || y == 0) return x+y;
    if(val[x] &lt; val[y]) std::swap(x, y);
    rs[x] = merge(rs[x], y);
    if(dis[ls[x]] &lt; dis[rs[x]]) std::swap(ls[x], rs[x]);
    dis[x] = dis[rs[x]] + 1;
    return x;
}
void pop(int x) {
    size[x] --;
    rt[x] = merge(ls[rt[x]], rs[rt[x]]);
}
signed main() {
    dis[0] = -1;
    scanf(&quot;%lld&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), a[i] -= i;
    for(int i = 1; i &lt;= n; i++) {
        size[++cnt] = 1, val[i] = a[i];
        rt[cnt] = i;
        L[cnt] = R[cnt] = i;
        while(cnt &gt; 1 &amp;&amp; val[rt[cnt-1]] &gt; val[rt[cnt]]) {
            cnt--;
            size[cnt] += size[cnt+1], R[cnt] = R[cnt+1];
            rt[cnt] = merge(rt[cnt], rt[cnt+1]);
            while(size[cnt] &gt; (R[cnt] - L[cnt])/2+1) pop(cnt);
        }
    }
    for(int i = 1; i &lt;= cnt; i++)
        for(int j = L[i]; j &lt;= R[i]; j++)
            ans += abs(a[j] - val[rt[i]]);
    printf(&quot;%lld\n&quot;, ans);
    for(int i = 1; i &lt;= cnt; i++)
        for(int j = L[i]; j &lt;= R[i]; j++) printf(&quot;%lld &quot;, val[rt[i]] + j);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2012]派遣 & [JLOI2015]城池攻占]]></title>
        <id>https://acfboy.pw/apio2012paiqian/</id>
        <link href="https://acfboy.pw/apio2012paiqian/">
        </link>
        <updated>2021-04-02T11:51:33.000Z</updated>
        <summary type="html"><![CDATA[<p>左偏树的基本运用加上一点点的树形 dp。</p>
<p>堆里也可以懒标记。</p>
]]></summary>
        <content type="html"><![CDATA[<p>左偏树的基本运用加上一点点的树形 dp。</p>
<p>堆里也可以懒标记。</p>
<!-- more -->
<h2 id="apio2012派遣">[APIO2012]派遣</h2>
<blockquote>
<p>给定一棵数，每个点有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 值和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, 选定一棵子树，在其中选一些根节点，记子树的根为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>, 求满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi>c</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\sum c \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的情况瞎 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>u</mi></msub><mo>×</mo></mrow><annotation encoding="application/x-tex">l_u \times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">×</span></span></span></span> 选中点个数 的最大值。</p>
</blockquote>
<p>我们要选的点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 肯定要尽可能的小，因为这样才能选用更多的点，于是可以利用堆。</p>
<p>但是对于每个子树重新建堆太慢了，需要快速地合并两个堆，所以介绍左偏树(可并堆)。</p>
<p>左偏树是这样的一棵树:</p>
<ol>
<li>满足堆的性质</li>
<li>任意一点左儿子到儿子不全的点的距离(简称“距离”)大于右儿子的</li>
</ol>
<p>显然对于合并两棵左偏树(根为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>)，可以这样(假设小根)：</p>
<ol>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>x</mi></msub><mo>&gt;</mo><msub><mi>v</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">v_x &gt; v_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></li>
<li>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 并到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的右儿子</li>
<li>递归求解</li>
<li>若不满足左偏性质就交换左右儿子。</li>
<li>返回新的根 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></li>
</ol>
<p>就是这样, <code>dis</code> 就是前文所说距离。</p>
<pre><code class="language-cpp">int merge(int x, int y) {
	if(x == 0 || y == 0) return x+y;
	if(c[x] &lt; c[y]) std::swap(x, y);
	rs[x] = merge(rs[x], y);
	if(dis[ls[x]] &lt; dis[rs[x]]) std::swap(ls[x], rs[x]);
	dis[x] = dis[rs[x]] + 1;
	return x;
}
</code></pre>
<p>其实这样确保树 ”左偏“ 以及在右边合并都是为了确保个堆在整个过程中尽可能平衡，避免退化成链的情况，又用了动态的儿子分配方式，方便合并，又好写，感觉完胜原来的堆啊。</p>
<p>但这题还需要记录一个堆中的元素的和，怎么办，记在堆顶上是不行的，因为这个被删掉了就完了。</p>
<p>这里采用类似树形 dp 的方式，直接用 <code>size</code> 和 <code>sum</code> 标记在一个节点上来表示以其为根当前的堆大小和元素和。</p>
<p>这题由于保证了边一定从小连到大，所以 dfs 都不需要，直接从后往前扫描一遍来建树就可以了。</p>
<p>注意我们每次直接更新了父亲，所以只选叶子节点的答案没有被算进，需要先计算。</p>
<p>代码</p>
<pre><code class="language-cpp">signed main() {
	dis[0] = -1; // 空节点
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;fa[i], &amp;c[i], &amp;l[i]);
		rt[i] = i, sum[i] = c[i], size[i] = 1;
		ans = std::max(ans, l[i]);
	}
	for(int i = n; i &gt; 1; i--) {
		rt[fa[i]] = merge(rt[fa[i]], rt[i]);
		size[fa[i]] += size[i], sum[fa[i]] += sum[i];
		while(sum[fa[i]] &gt; m) {
			sum[fa[i]] -= c[rt[fa[i]]];
			rt[fa[i]] = merge(ls[rt[fa[i]]], rs[rt[fa[i]]]);
			size[fa[i]] --;
		}
		ans = std::max(ans, l[fa[i]] * size[fa[i]]);
	}
	printf(&quot;%lld&quot;, ans);
}
</code></pre>
<h2 id="jloi2015城池攻占">[JLOI2015]城池攻占</h2>
<p>其实也是维护树上每一个点都开一个堆，然后进行合并，这里是小根堆，每次把不符合要求的就弹出。</p>
<p>但是对于攻击力的值怎么变化呢？更新所有会超时。每个堆的中数的变化方式是一样的，可如果记录下来变化方式的话，又记录在哪里呢？</p>
<p>这时就可以用到我们的老朋友，懒惰标记。对于堆，同样也是只要用到的进行处理就可以了啊，为什么每次要更新所有？只要在根节点打个懒标记，要删了时，直接把懒标记下传再合并两个就可以了。</p>
<p>注意，合并的时候也先给把懒标记下传， 因为合来合去的要依靠当前的根，而且树形会发生变化，所以处理之前得先把标记给儿子。</p>
<p>同时乘和加相同的数，不会改变元素间大小关系，所以这样子是对的。</p>
<p>带懒标记的代码。</p>
<pre><code class="language-cpp">void cov(int x, int mu, int ad) {
    if(x == 0) return;
    s[x] *= mu, s[x] += ad;
    mul[x] *= mu, add[x] *= mu, add[x] += ad;
}
void pushdown(int x) {
    // printf(&quot;*%lld\n&quot;, x);
    cov(ls[x], mul[x], add[x]);
    cov(rs[x], mul[x], add[x]);
    mul[x] = 1, add[x] = 0;
}
int merge(int x, int y) {
    if(x == 0 || y == 0) return x + y;
    pushdown(x); pushdown(y);
    if(s[x] &gt; s[y]) std::swap(x, y);
    rs[x] = merge(rs[x], y);
    if(dis[ls[x]] &lt; dis[rs[x]]) std::swap(ls[x], rs[x]);
    dis[x] = dis[rs[x]] + 1;
    return x;
}
</code></pre>
<p>删除操作：</p>
<pre><code class="language-cpp">pushdown(rt[u]);
rt[u] = merge(ls[rt[u]], rs[rt[u]]);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.2 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210422/</id>
        <link href="https://acfboy.pw/20210422/">
        </link>
        <updated>2021-04-02T03:37:47.000Z</updated>
        <summary type="html"><![CDATA[<p>其实正解都想得挺快的，但是 D 题细节有些恶心，最终调了很久，没空做最后一题了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>其实正解都想得挺快的，但是 D 题细节有些恶心，最终调了很久，没空做最后一题了。</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>一个字符串，若干个操作，每次翻转或在开头/结尾插入，输出最后结果。</p>
</blockquote>
<p>水题，<code>deque</code> 解决。</p>
<h2 id="b">B</h2>
<blockquote>
<p>一个字符串，维护区间内不同的字符个数，支持单点修改。</p>
</blockquote>
<p>线段树裸题。</p>
<h2 id="c">C</h2>
<p>水题，题目都不想打了。</p>
<h2 id="d">D</h2>
<p>随便来个样例，把所有的列出来。</p>
<pre><code class="language-plain">3
35
354
3543
 5
 54 
 543
  43
   3
</code></pre>
<p>中间显然有很多重复。</p>
<p>若只维护第一组，那么每次每个要减去的数不一样，所以从后面开始。</p>
<pre><code class="language-plain">   3
  43
 543
3543
  4
 54
354
 5
35
3
</code></pre>
<p>这样对于每一组，就是把第一个去掉，然后剩下的每一个减去最后一个位再除以十就可以了。</p>
<p>因为对于所有数的处理都一样，所以直接把取模完每一个答案有几个给记下来，然后维护一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, 满足经过了哪些操作原来答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的答案会变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 然后加上这个就可以了。</p>
<p>具体地，比如有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 个数，我现在要求倒数第二组的答案，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 需要满足(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">inv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的逆元)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mi>k</mi><mo>−</mo><msub><mi>s</mi><mn>5</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>)</mo><mo>−</mo><msub><mi>s</mi><mn>4</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>)</mo><mo>−</mo><msub><mi>s</mi><mn>3</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="1em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">((((((k-s_5)\times inv) - s_4) \times inv) - s_3) \times inv \equiv 0 \pmod p
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p>化简一下就是每次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>p</mi><mi>o</mi><mi>w</mi></mrow></msup></mrow><annotation encoding="application/x-tex">s_i \times 10^{pow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></span> 。</p>
<p>然后你就可以交了。</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#define int long long
int n, m, p, ans, f[10005];
char s[200005];
signed main() {
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p);
    scanf(&quot;%s&quot;, s + 1);
    for (int i = n, pow = 1, now = 0; i &gt;= 1; i--, pow = pow * 10 % p) {
        now = (now + (s[i] - '0' + p) * pow % p) % p;
        f[now]++;
    }
    for (int i = n, pow = 1, now = 0; i &gt;= 1; i--, pow = pow * 10 % p) {
        ans = ans + f[now];
        now = (now + (s[i] - '0') * pow % p) % p;
        f[now]--;
    }
    printf(&quot;%lld&quot;, ans);
}

</code></pre>
<p>交了以后会发现：WA 了</p>
<p>细细一想，发现若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的约数时连个逆元都没有，你乘个锤子！</p>
<p>所以特判一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的情况。</p>
<pre><code class="language-cpp">    if (p == 2 || p == 5) {
        for (int i = 1; i &lt;= n; i++)
            if ((s[i] - '0') % p == 0)
                ans += i;
        printf(&quot;%lld&quot;, ans);
        return 0;
    }
</code></pre>
<p>现在真的过了。这错误我调了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span> 分钟</p>
<h2 id="e">E</h2>
<p>原题是 ABC158F。</p>
<p><s>看了题解</s> 觉得 dp 还是比较显然的，肯定得排一个序，然后倒着。因为我们能唯一能确定的状态就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这个编号，根本没有机器人，方案只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个的方案数。显然可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_i = f_{i+1} + f_{next}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span> 是后面不受影响的。</p>
<p>问题在于后面那个怎么求。 <code>next</code> 即后面第一个大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x + d - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的，那不就是单调栈吗？</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
const int N = 200005, p = 998244353;
int n, f[N];
std::pair&lt;int, int&gt; a[N];
std::stack&lt;std::pair&lt;int, int&gt; &gt; st;
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i].first, &amp;a[i].second);
	std::sort(a+1, a+1+n);
	f[n+1] = 1;
	for(int i = n; i &gt;= 1; i--) {
		int t = a[i].first + a[i].second, next = i+1;
		while(!st.empty() &amp;&amp; t &gt; a[st.top().first].first) {
			next = st.top().second;
			st.pop();
		}
		st.push({i, next});
		f[i] = (f[i+1] + f[next]) % p;
	}
	printf(&quot;%d&quot;, f[1]);
}
</code></pre>
]]></content>
    </entry>
</feed>