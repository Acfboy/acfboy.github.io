<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的小站</title>
    <updated>2021-03-24T00:58:16.238Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的小站</rights>
    <entry>
        <title type="html"><![CDATA[题解 [SDOI2013]城市规划]]></title>
        <id>https://acfboy.pw/sdoi2013city/</id>
        <link href="https://acfboy.pw/sdoi2013city/">
        </link>
        <updated>2021-03-24T00:53:52.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3300">传送门</a></p>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 非常的小，很容易维护，所以可以按行建立一颗线段树，维护其中联通块的数量。处理联通块的时候用并查集记录上下两个边界的联通状况以及是否有建筑物。</p>
<p>难点在于如何合并，即 <code>pushup</code>。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3300">传送门</a></p>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 非常的小，很容易维护，所以可以按行建立一颗线段树，维护其中联通块的数量。处理联通块的时候用并查集记录上下两个边界的联通状况以及是否有建筑物。</p>
<p>难点在于如何合并，即 <code>pushup</code>。</p>
<!-- more -->
<ol>
<li>将两边块的 <code>ans</code> 合起来。</li>
<li>将新的左端点设为左边的左端点，右端点设为右边的右端点。</li>
<li>现在合并并查集
<ol>
<li>左边的并查集复制一份，存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, 2m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span>, 将右边复制一份，存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mi>m</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[2m+1, 4m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span>。</li>
<li>枚举两块交界处的，若可以合并，则将其合并，若两边都有建筑物，则 <code>ans--</code>。</li>
<li>经过上面的操作，并查集被合并成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,4m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 的并查集，但是我们只要存上面的边界和下面的边界的联通性。</li>
<li>建立一个新数组，将上下边界的 <code>fa</code> 都连向它们。</li>
<li>然后将每一个的 <code>fa</code> 都改为它的 <code>fa</code> 所指向的。</li>
<li>经过这些操作，所有点集合的根都在上边界和下边界了，可以直接返回。</li>
</ol>
</li>
</ol>
<p>其实思路清晰的话也没有很多难写的细节，代码也不至于长达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>200</mn></mrow><annotation encoding="application/x-tex">200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 行。</p>
<p>代码如下。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int N = 100005, M = 8;
int n, m, q, l, r, x, y, tmpfa[M*4], tmpflag[M*4], v[M*4];
char opt[5], z[5], map[N][M];
struct node {
	int l, r, ans;
	int fa[2*M], flag[2*M];
	node() {
		for(int i = 1; i &lt;= m; i++) fa[i] = fa[i+i] = 0, flag[i] = 0; 
	}
	void init() {
		ans = 0;
		for(int i = 1; i &lt;= m; i++) fa[i] = fa[i+m] = i;
		for(int i = 1; i &lt;= m; i++) flag[i] = (map[l][i] == 'O') ? 1 : 0;
	}
	int find(int x) {
		if(fa[x] != x) fa[x] = find(fa[x]);
		return fa[x]; 
	}
	void merge(int x, int y) {
		int fx = find(x), fy = find(y);
		if(fx == fy) return;
		fa[fy] = fx;
		flag[fx] |= flag[fy];
	}
	void makeNode() { // 构造线段树的叶子
		init();
		for(int i = 1; i &lt; m; i++) {
			char now = map[l][i], next = map[l][i+1];
			if(now != '|' &amp;&amp; now != '.' &amp;&amp; next != '|' &amp;&amp; next != '.') merge(i, i+1);
		}
		for(int i = 1; i &lt;= m; i++) find(i+m);
		for(int i = 1; i &lt;= m; i++) 
			if(fa[i] == i &amp;&amp; flag[i]) ans++;			
	}
} tree[N &lt;&lt; 2];
int findTmp(int x) {
	if(x != tmpfa[x]) tmpfa[x] = findTmp(tmpfa[x]);
	return tmpfa[x];
}
node mergeAns(node x, node y) { // 合并过程上面写得很详细了
	node an;
	an.l = x.l, an.r = y.r;
	an.ans = x.ans + y.ans;
	for(int i = 1; i &lt;= 2*m; i++) tmpfa[i] = x.fa[i], tmpflag[i] = x.flag[i];
	for(int i = 1; i &lt;= 2*m; i++) tmpfa[i+2*m] = y.fa[i]+2*m, tmpflag[i+2*m] = y.flag[i];
	for(int i = 1; i &lt;= m; i++) {
		char lval = map[x.r][i], rval = map[y.l][i];
		if(lval != '.' &amp;&amp; lval != '-' &amp;&amp; rval != '.' &amp;&amp; rval != '-') {
			int fx = findTmp(i+m), fy = findTmp(i+2*m);
			if(fx == fy) continue;
			if(tmpflag[fx] &amp;&amp; tmpflag[fy]) an.ans--;
			tmpfa[fy] = fx;
			tmpflag[fx] |= tmpflag[fy];
		}
	}
	memset(v, 0, sizeof v);
	for(int i = 1; i &lt;= m; i++) {
		int fi = findTmp(i);
		if(!v[fi]) v[fi] = i, an.flag[i] = tmpflag[fi];
		fi = findTmp(i+3*m);
		if(!v[fi]) v[fi] = i+m, an.flag[i+m] = tmpflag[fi];
	}
	for(int i = 1; i &lt;= m; i++) an.fa[i] = v[findTmp(i)], an.fa[i+m] = v[findTmp(i+3*m)];
	return an;
}
void pushUp(int p) { tree[p] = mergeAns(tree[p+p], tree[p+p+1]); }
void build(int p = 1, int l = 1, int r = n) {
	tree[p].l = l, tree[p].r = r;
	if(l == r) return tree[p].makeNode();
	int mid = l + (r-l) / 2;
	build(p+p, l, mid);
	build(p+p+1, mid+1, r);
	pushUp(p);
}
void Change(int p, int x, int y, char z) {
	if(tree[p].l == tree[p].r) {
		map[tree[p].l][y] = z;
		return tree[p].makeNode(); // 修改的时候重新构造即可
	}
	int mid = tree[p].l + (tree[p].r - tree[p].l) / 2;
	if(x &lt;= mid) Change(p+p, x, y, z);
	else Change(p+p+1, x, y, z);
	pushUp(p);
}
node Query(int p, int l, int r) {
	if(l == tree[p].l &amp;&amp; r == tree[p].r) return tree[p];
	int mid = tree[p].l + (tree[p].r - tree[p].l) / 2;
	if(l &gt; mid) return Query(p+p+1, l, r);
	else if(r &lt;= mid) return Query(p+p, l, r);
	else return mergeAns(Query(p+p, l, mid), Query(p+p+1, mid+1, r));
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; i++)
		scanf(&quot;%s&quot;, map[i]+1);
	build();
	scanf(&quot;%d&quot;, &amp;q);
	while(q--) {
		scanf(&quot;%s&quot;, opt);
		if(opt[0] == 'Q') {
			scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
			printf(&quot;%d\n&quot;, Query(1, l, r).ans);
		}
		else {
			scanf(&quot;%d%d%s&quot;, &amp;x, &amp;y, z);
			Change(1, x, y, z[0]);
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF1149C Tree Generator™]]></title>
        <id>https://acfboy.pw/cf1149c/</id>
        <link href="https://acfboy.pw/cf1149c/">
        </link>
        <updated>2021-03-22T23:17:35.000Z</updated>
        <summary type="html"><![CDATA[<p><s>这不但打了 TM 而且还是世界知名商标，可能受法律保护哦</s></p>
<p>一道非常惊喜的线段树题。</p>
]]></summary>
        <content type="html"><![CDATA[<p><s>这不但打了 TM 而且还是世界知名商标，可能受法律保护哦</s></p>
<p>一道非常惊喜的线段树题。</p>
<!-- more -->
<blockquote>
<p>给定一颗树, 用 <code>(</code> 表示下一层， <code>)</code> 表示上一层，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 次询问，每次交换两个括号，求每次的直径。</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/6Tpzff"><img src="https://z3.ax1x.com/2021/03/22/6Tpzff.png" alt="6Tpzff.png" loading="lazy"></a></figure>
</blockquote>
<p>从上面的图我们可以得到一个结论：</p>
<p><strong>链是由形如 <code>))))(((((</code> 的字符串构成的</strong></p>
<p>因为肯定是退上来再深入到另一边，而且链只能一上一下，所以原题目其实等价于要求维护去掉所有匹配括号后长度最长的子串。</p>
<p>令人惊喜的是，可以用线段树来维护。</p>
<ol>
<li>
<p>将在 <code>(</code> 的权设为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>， <code>)</code> 设为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>, 这样一段区间内数字的和就是多出来的左括号个数，而如果是右括号多出来，则这个值时负的，所以统计个数只需要用连续且靠后的一段减前面一段最大就可以了。</p>
</li>
<li>
<p>但这个东西直接用线段树维护似乎没有办法做，所以多记录一些信息来尝试合并，记录这两个区间一边顶到头的非常好合并，只需要一边的和再 加/减 另一边顶到这一边的答案就可以了。</p>
</li>
<li>
<p>所以考虑如何用一边顶到头的答案合并除最后的答案。</p>
<ol>
<li>可能是左边或右边原有的答案</li>
<li>可能是右边最大前缀和加上左边顶到右端点的答案</li>
<li>可能是右边顶到左端点的答案减去左边最小的后缀</li>
</ol>
</li>
</ol>
<p><code>pushup</code> 函数如下</p>
<pre><code class="language-cpp">void pushup(int p) {
	tree[p].sum = tree[p+p].sum + tree[p+p+1].sum;
	tree[p].lmax = std::max(tree[p+p].lmax, tree[p+p].sum + tree[p+p+1].lmax);
	tree[p].rmax = std::max(tree[p+p+1].rmax, tree[p+p+1].sum + tree[p+p].rmax);
	tree[p].lmin = std::min(tree[p+p].lmin, tree[p+p].sum + tree[p+p+1].lmin);
	tree[p].rmin = std::min(tree[p+p+1].rmin, tree[p+p+1].sum + tree[p+p].rmin);
	
	tree[p].max1 = std::max(tree[p+p].max1, std::max(tree[p+p+1].max1 - tree[p+p].sum,
				   tree[p+p+1].lmax + tree[p+p].rmax - (tree[p+p].sum - tree[p+p].rmax)));
	tree[p].max2 = std::max(tree[p+p+1].max2, std::max(tree[p+p+1].sum + tree[p+p].max2,
				   tree[p+p+1].sum - tree[p+p+1].lmin - (tree[p+p+1].lmin + tree[p+p].rmin)));
	tree[p].ans = std::max(std::max(tree[p+p].ans, tree[p+p+1].ans), std::max(
				  tree[p+p].max2 + tree[p+p+1].lmax, tree[p+p+1].max1 - tree[p+p].rmin));			   
}
</code></pre>
<p>重点解释 <code>max1</code> 的合并， <code>max2</code> 同理</p>
<pre><code class="language-cpp">tree[p].max1 = std::max(tree[p+p].max1,   // 可能是左边顶到左端点的答案
	           std::max(tree[p+p+1].max1 - tree[p+p].sum, // 左边全部被当成 ) 的一段，右边靠左最大的减去左边的和
			            tree[p+p+1].lmax + tree[p+p].rmax - (tree[p+p].sum - tree[p+p].rmax)));
		       // 中间一段最大的接起来减去左边剩下的，即 ( 的一段跨越了分界线
</code></pre>
<p>如果不是把匹配的都去掉，答案一定会更小，会被更大的答案覆盖，所以不需要特殊判断。</p>
<p>修改和建树都比较常规。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF Round 709(div 2) 游记]]></title>
        <id>https://acfboy.pw/cf709/</id>
        <link href="https://acfboy.pw/cf709/">
        </link>
        <updated>2021-03-22T06:22:50.000Z</updated>
        <summary type="html"><![CDATA[<p>拿到了我在 CF 历史上的最高排名。</p>
<p>非常惊险刺激。</p>
]]></summary>
        <content type="html"><![CDATA[<p>拿到了我在 CF 历史上的最高排名。</p>
<p>非常惊险刺激。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/6Iwk7Q"><img src="https://z3.ax1x.com/2021/03/22/6Iwk7Q.png" alt="6Iwk7Q.png" loading="lazy"></a></figure>
<p>非常惊的经历，开局 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 分钟过了第一题，第二题一个神奇的细节题，交了一发 WA 掉，交第二发继续 WA 掉。想着细节题也不太好调，于是跳过直接去做第三题，似乎是一个简单贪心，交了一发 WA 掉，发现了贪心的错误，修改后又 WA 掉。</p>
<p>当时排名已经掉到三千五了，这样肯定要掉分掉成 Pupil 了，真的要 WA 的一声哭出来。调了很久的第三题又没有结果，找不出任何的数据来 hack 我的程序。于是一边想着放弃一边喊着“翘翘加油”逼着自己去调题。</p>
<p>本来觉得 C 题会更好调，但很久后未果，又去看 B 题。终于，转机出现了，我找到了一个使我错误的数据，是一个判断错了，具体的下面题解里会讲。看到 <code>Pretests Passed</code> 的那一刻我真的叫出来了。</p>
<p>最后十五分钟，调 C 题还有希望吗？当然要奋战到最后一刻！最后五分钟，终于找出了 hack 数据，最后三分钟的时候通过了 <code>Pretests</code>。</p>
<p>极限改出成功，翘翘真棒！</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/6I0Q2t"><img src="https://z3.ax1x.com/2021/03/22/6I0Q2t.png" alt="6I0Q2t.png" loading="lazy"></a></figure>
<p>所以任何时候都不要丧失奋斗的勇气，转机总在不经意间出现。</p>
<h2 id="a">A</h2>
<blockquote>
<p>xhf 违反了隔离规定，被关起来了，他被关在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的网格中，最少需要打通几面墙，才能让每一件囚室都有通向外面的通道？</p>
</blockquote>
<p>易得，答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。</p>
<p><strong>证明：</strong></p>
<p>将囚室们看成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个块，外部空间看成一个块，题目要求就是要让所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \times m + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个联通块并成一个。</p>
<p>因为至少要打掉一面墙才可以让两个联通块并成一个，且打掉一面墙总能让联通块个数减少一个，所以至少需要联通块个数减去一次操作，即答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m + 1- 1 = n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></p>
<h2 id="b">B</h2>
<blockquote>
<p>输入一个序列，请通过下面的方式构造它： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mi>s</mi><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">a_1 = s \mod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span> 且对于任意 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 &lt; i \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>c</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">a_i = (a_{i-1} + c) \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>, 求最大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 并输出一个合适的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, 若没有答案输出 <code>-1</code>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 可以无限大输出 <code>0</code>.</p>
</blockquote>
<p>首先考虑一些显而易见的 <code>-1</code> 的情况。</p>
<p>因为每次都对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 取模了，所以每次要么没有减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，要么加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> ，所以每组增加的相邻两个的增加量必须相同，减少的减少量也必须相同，不然就是 <code>-1</code>。</p>
<p>然后考虑显而易见的 <code>0</code> 的情况，只有增加的和只有减少的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 肯定可以无限大了，增加的则一直不取模即可，减少的设每次减少的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">rec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span>, 则只要满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>−</mo><mi>m</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">c-m = rec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span> 就可以， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 也可以无限大。</p>
<p>然后可以考虑正常情况了，显然，每次增加的就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> , 而这个条件也可以完美地限制住 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>, 若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_i &lt; a_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 只能是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>c</mi><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_{i-1} + c - a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 了，因为其中所有数都是小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的，所以这种情况只能是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>c</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a_i = a_{i-1} + c - m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>, 移项可得。</p>
<p>这样的做法真的对吗，增加也有可能取模过了啊！但这样子显然可以把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 调的更大而满足所有条件，不可能称为最大解。</p>
<p>记得还要判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 是否有冲突和是否有数大于等于了求得的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。</p>
<p>考场代码如下。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#define int long long
const int N = 100005;
int T, n, m, c, rec, a[N];
signed main() {
    scanf(&quot;%lld&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%lld&quot;, &amp;n);
        c = -1, rec = -1, m = -1;
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]);
        bool flag1 = false, flag2 = false, flag3 = false, flag4 = false;
        for(int i = 2; i &lt;= n; i++) {
            if(c == -1 &amp;&amp; a[i] &gt;= a[i-1]) c = a[i] - a[i-1];
            else if(a[i] &gt;= a[i-1] &amp;&amp; a[i] - a[i-1] != c) {flag1 = true; break;}
            if(rec == -1 &amp;&amp; a[i] &lt; a[i-1])  rec = a[i-1] - a[i];
            else if(a[i] &lt; a[i-1] &amp;&amp; a[i-1] - a[i] != rec) flag2 = true;
        }
        if(flag1 || flag2) { puts(&quot;-1&quot;); continue; }
        if(c == -1 &amp;&amp; !flag2 || rec == -1 &amp;&amp; !flag1) {puts(&quot;0&quot;); continue; }
        for(int i = 2; i &lt;= n; i++) 
            if(m == -1 &amp;&amp; a[i] &lt; a[i-1]) m = a[i-1] + c - a[i];
            else if(a[i] &lt; a[i-1] &amp;&amp; a[i-1] + c - a[i] != m) { flag3 = true; break;}
        if(flag3) { puts(&quot;-1&quot;); continue; }
        for(int i = 1; i &lt;= n; i++) 
            if(a[i] &gt;= m) flag4 = true;
        if(flag4) puts(&quot;-1&quot;);
        else printf(&quot;%lld %lld\n&quot;, m, c);
    }
}
</code></pre>
<p>赛时的两次 WA 一次是因为没有判断数都小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的情况，一次是因为判断只上升出错了，认为 <code>rec == -1</code> 时只有 <code>c == 0</code> 才输出 <code>0</code>,且下降不均匀判 <code>-1</code> 需要只下降。 而实际上，只下降不均匀就可以判断 <code>-1</code>, 仅上升均匀无下降就可以判断 <code>0</code>。</p>
<h2 id="c">C</h2>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 天， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数，每天只有一些数能取，每个数取的次数不能超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mi>m</mi><mn>2</mn></mfrac><mo>⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{m}{2} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span> 次，有方案输出任意一种，没有方案输出 <code>NO</code></p>
</blockquote>
<p>很容易想到一个贪心，就是尽可能先满足出现次数少的，且已经选取次数小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mi>m</mi><mn>2</mn></mfrac><mo>⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{m}{2} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span> 的，但这样显然是错的。</p>
<p>可以被这样的数据卡掉: 有很多出现次数相等的，但一个是在最后唯一能取的，这样用贪心做就会把有解的情况判成 <code>NO</code>。</p>
<p>比如下面这组数据:</p>
<pre><code class="language-plain">3 5 
1 1
2 1 3
2 1 3
2 1 3
1 3

</code></pre>
<p>如果你找最小时等号也更新，那么就会因为前面用了三次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 导致后面没得用而输出 <code>NO</code>。</p>
<p>怎么解决这个问题呢？</p>
<p>换一个处理顺序，先满足能取的个数少的再满足能取的多的，因为能取的多的能满足的希望肯定比能取的少的要大，所以这样的顺序只会变得更优而不会变得更差。</p>
<p>考虑怎么实现。</p>
<p>我的做法是写一个结构体，里面有一个 <code>vector</code> 用来存每一个可以取的，另用 <code>id</code> 记录这一个原来的编号，直接 <code>sort</code> 就可以了。这样的时间复杂度是不会有问题的，因为题目中保证了所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的和不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>200000</mn></mrow><annotation encoding="application/x-tex">200000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> , 所以排序中交换所需时间和遍历所需时间段的积不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2000000</mn></mrow><annotation encoding="application/x-tex">2000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>, 以快排的复杂度可以通过。</p>
<p>代码如下。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
const int N = 100005;
int T, n, m, num[N], in[N], x, k, ans[N];
bool flag;
struct twt {
    std::vector&lt;int&gt; a;
    int id;
    bool operator &lt; (twt b) const {
        return a.size() &lt; b.a.size();
    }
} f[N];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

        for(int i = 1; i &lt;= m; i++) f[i].a.clear(), ans[i] = 0;
        for(int i = 1; i &lt;= n; i++) in[i] = 0, num[i] = 0;
        flag = 0;

        for(int i = 1; i &lt;= m; i++) {
            scanf(&quot;%d&quot;, &amp;k);
            f[i].id = i;
            for(int j = 1; j &lt;= k; j++)
                scanf(&quot;%d&quot;, &amp;x), f[i].a.push_back(x), num[x] ++;
        }
        std::sort(f+1, f+1+m);
        for(int i = 1; i &lt;= m; i++) {
            int minj = -1, min = m+1;
            for(int j = 0; j &lt; (signed)f[i].a.size(); j++) 
                if(num[f[i].a[j]] &lt; min &amp;&amp; in[f[i].a[j]] &lt; (m+1)/2)  {
                    minj = f[i].a[j];
                    min = num[f[i].a[j]];
                }
            if(minj == -1) {flag = 1; break;}
            in[minj] ++;
            ans[f[i].id] = minj;
        }
        if(flag) puts(&quot;NO&quot;);
        else {
            puts(&quot;YES&quot;);
            for(int i = 1; i &lt;= m; i++) printf(&quot;%d &quot;, ans[i]);
            puts(&quot;&quot;);
        }
    }
    return 0;
}
</code></pre>
<p>第二次 WA 的原因我原来 <code>min</code> 直接赋值为 <code>f[i].a[0]</code>, 但这个实际上可能是不能取的。</p>
<hr>
<p>真是非常惊险的比赛体验。希望我以后的学习中能静下心来，想清楚每一个问题再去写代码，不要再这样自己给自己倒扣 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>200</mn></mrow><annotation encoding="application/x-tex">200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 分了。</p>
<p>加油。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重启]]></title>
        <id>https://acfboy.pw/helloworld/</id>
        <link href="https://acfboy.pw/helloworld/">
        </link>
        <updated>2021-03-21T11:04:21.000Z</updated>
        <summary type="html"><![CDATA[<p>清理了从前的博客，开始新的征程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>清理了从前的博客，开始新的征程。</p>
<!-- more -->
<p>这是我的第三个博客了。</p>
<p>我的第一个博客在 2018 年初的时候用 Hexo 搭建起来，本是用来记录一下每周所学的算法和数据结构，但最终因为自身的懒散废弃了那项工程，经历了重装系统等事情后也丢失了几乎全部的内容。在换用 Ubuntu 后开始使用 Gridea，然后零零散散写了一些没啥意义的内容也放弃了，现在再重启博客计划。</p>
<p>博客用来记录一些个人的感想和做题的记录，这次清理，去除了原来的博文，只保留了 <a href="https://acfboy.pw/ta-shan-zhi-shi-ke-yi-gong-yu/">CSP2020</a> 和 <a href="https://acfboy.pw/noip2018">NOIP2018</a> 的两篇游记，它们不仅是两次比赛，也是我初中学习状态的缩影。</p>
<p>希望将来我能写出优秀的博客帮我巩固和记录所学，也希望我能不忘初心，坚守自己的梦想，努力奋斗，做可爱的翘翘，成为自己喜欢的样子。</p>
]]></content>
    </entry>
</feed>