<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的博客</title>
    <updated>2021-05-05T00:15:22.182Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的博客</rights>
    <entry>
        <title type="html"><![CDATA[题解 CF576D Flights for Regular Customers]]></title>
        <id>https://acfboy.pw/cf576d/</id>
        <link href="https://acfboy.pw/cf576d/">
        </link>
        <updated>2021-05-05T00:00:43.000Z</updated>
        <summary type="html"><![CDATA[<p>这类的题目据说很常见，但是我几乎从来没有遇到过。</p>
<p>是很神奇的一道题呢！</p>
]]></summary>
        <content type="html"><![CDATA[<p>这类的题目据说很常见，但是我几乎从来没有遇到过。</p>
<p>是很神奇的一道题呢！</p>
<!-- more -->
<blockquote>
<p>必须要经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 条边才能走第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 条边，求从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>  的最少经过的边的数量。</p>
</blockquote>
<h3 id="图论中的矩阵优化">图论中的矩阵优化</h3>
<p>先上一个预备知识，就是图论中的矩阵优化。</p>
<p>众所周知，矩阵描述的是一种变换，而只要满足结合律，就可以进行快速幂，所以可以用快速幂来快速的求出一些变换以后的结果。</p>
<p>如这样一道题：</p>
<blockquote>
<p>求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 条边的最短路。</p>
</blockquote>
<p>我们可以用矩阵来描述原来的边，然后重新定义一下矩阵乘法成下面的样子，这样就相当于用走一次一个矩阵所代表的边，另一个矩阵新的最短路情况。</p>
<pre><code class="language-cpp">twt operator * (twt b) {
	twt c;
	for(int i = 1; i &lt;= n; i++)
		for(int j = 1; j &lt;= n; j++)
			for(int k = 1; k &lt;= n; k++)
				c[i][j] = std::min(a[i][k] + b[k][j], c[i][j]);
	return c;
}
</code></pre>
<p>这样的话，自己乘上自己就相当于当前这个图每个点走一次的多源最短路情况，所以在这题中，我们只需要将它乘 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次就可以了。</p>
<h3 id="回到本题">回到本题</h3>
<p>然后再回到这一题中来。</p>
<p>首先为了消除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 的影响，我们可以按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 从小到大去遍历所有的边。</p>
<p>然后先把原来图的连通性进行若干次变换，相当于走了当前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 这一边了。然后就可以走这条边了，所以接着将这条边加入到描述连通性的矩阵中去，通过一个多源 bfs 找到现在的最短路(因为边权都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 所以不需要 Dijkstra)。</p>
<p>然后更新一次答案，继续重复直到当前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 还大就可以退出了。</p>
<p>此题需要 <code>bitset</code> 优化。然后代码里实现有一个小的细节，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的矩阵和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的矩阵相乘的时候把 <code>bitset</code> 竖起来不方便，所以直接把连通性反着存进去，这样就不需要处理这个情况了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;bitset&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#define int long long
const int N = 155, M = N, INF = 2000000000;
typedef std::bitset&lt;N&gt; bitset;
bitset v;
int n, m, ans = INF, d[N];
struct cmf {
	int u, v, d;
	bool operator &lt; (cmf b) const {
		return d &lt; b.d;
	}
} e[M];
struct twt {
	bitset a[N];
	friend bitset operator * (bitset x, twt y) {
		bitset z;
		for(int i = 1; i &lt;= n; i++) z[i] = (x&amp;y[i]).any();
		return z;
	}
	friend twt operator * (twt x, twt y) {
		twt z;
		for(int i = 1; i &lt;= n; i++)
			for(int j = 1; j &lt;= n; j++)
				if(x[i][j]) z[i] |= y[j];
		return z;
	}
	bitset&amp; operator [] (int x) { return a[x]; }
} a;
void Pow(bitset &amp;z, twt x, int y) {
	while(y) {
		if(y &amp; 1) z = z * x;
		x = x * x;
		y &gt;&gt;= 1;
	}
}
signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; i++) scanf(&quot;%lld%lld%lld&quot;, &amp;e[i].u, &amp;e[i].v, &amp;e[i].d);
	std::sort(e+1, e+1+m);
	v[1] = 1;
	for(int i = 1, t = 0; i &lt;= m; i++) {
		if(e[i].d &gt;= ans) break;
		int o = e[i].d - t;
		Pow(v, a, o);
		a[e[i].v][e[i].u] = 1;
		t = e[i].d;
		std::queue&lt;int&gt; q;
		for(int x = 1; x &lt;= n; x++)
			if(v[x]) q.push(x), d[x] = 0;
			else d[x] = INF;
		while(!q.empty()) {
			int u = q.front(); q.pop();
			for(int v = 1; v &lt;= n; v++) 
				if(a[v][u] &amp;&amp; d[v] == INF)
					d[v] = d[u] + 1, q.push(v);
		}	
		ans = std::min(ans, t + d[n]);
	}
	if(ans == INF) puts(&quot;Impossible&quot;);
	else printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [CSP-S2019] Emiya 家今天的饭]]></title>
        <id>https://acfboy.pw/csp-s2019-emiya-jia-jin-tian-de-fan/</id>
        <link href="https://acfboy.pw/csp-s2019-emiya-jia-jin-tian-de-fan/">
        </link>
        <updated>2021-05-04T23:59:46.000Z</updated>
        <summary type="html"><![CDATA[<p>很久以前就做过未果的一道题。现在终于给它过了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很久以前就做过未果的一道题。现在终于给它过了。</p>
<!-- more -->
<p>直接做由于有一列选择的不能超过所有选择的一半的限制，所以不太好做。但直接计算所有的方案非常好做，直接乘法原理即可，因此可以考虑容斥。先计算出没有这一条限制的所有情况，再计算包含了超过一半的方案数。</p>
<p>超过一半的列显然只有一列，所以可以枚举这一列。记它为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行该列取了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个，而其它列取了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个。考虑最后一个放进了哪里就可以得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>×</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>c</mi><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>×</mo><mo>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo>−</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>c</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[i][j][k] = f[i-1][j][k] + f[i-1][j-1][k] \times a[i][c] + f[i-1][j][k-1] \times (s_i - a[i][c])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p>
<p>但是这样是过不了的，需要继续优化。</p>
<p>其实不需要记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的具体数值，只需要它们之间的差就可以了，这样就可以通过此题了。这样为什么是对的呢？它相当于把所有的状态揉在了一起，但揉在一起的原来要分别转移到的揉在一起仍然是这个状态要转移到的地方，所以它是对的。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 105, M = 2005, p = 998244353;
int n, m, a[N][M], s[N], g[N][N], f[N][N*2], d, ans;
signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; i++) 
		for(int j = 1; j &lt;= m; j++) {
			scanf(&quot;%lld&quot;, &amp;a[i][j]); a[i][j] %= p;
			s[i] += a[i][j], s[i] %= p;
		}
	g[0][0] = 1;
	for(int i = 1; i &lt;= n; i++)
		for(int j = 0; j &lt;= n; j++) 
			g[i][j] = (g[i-1][j] + s[i] * ((j &gt; 0) ? g[i-1][j-1] : 0) % p) % p;
	for(int i = 1; i &lt;= n; i++) ans = (ans + g[n][i]) % p;
	for(int c = 1; c &lt;= m; c++) {
		memset(f, 0, sizeof f);
		f[0][n] = 1;
		for(int i = 1; i &lt;= n; i++)
			for(int j = n-i; j &lt;= n+i; j++)
				f[i][j] = (f[i-1][j] + a[i][c] * f[i-1][j-1] % p + (s[i]-a[i][c]+p) % p * f[i-1][j+1] % p) % p;		
		for(int i = 1; i &lt;= n; i++) ans = (ans - f[n][n+i] + p) % p;
	}
	printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.5.4 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210504/</id>
        <link href="https://acfboy.pw/20210504/">
        </link>
        <updated>2021-05-04T11:28:09.000Z</updated>
        <summary type="html"><![CDATA[<p><s>《比赛赛严重事故征候调查报告：2021 年 5 月 4 日校内模拟赛》</s></p>
]]></summary>
        <content type="html"><![CDATA[<p><s>《比赛赛严重事故征候调查报告：2021 年 5 月 4 日校内模拟赛》</s></p>
<!-- more -->
<h2 id="概述">概述</h2>
<p>做完一题就一直搞第二题，而且还想歪了，最终在模拟赛中取得了糟糕的成绩。</p>
<h2 id="事实情况">事实情况</h2>
<h3 id="a">A</h3>
<blockquote>
<p>输入张图两两间的最短路，求最少要几条边。</p>
</blockquote>
<p>其实原题描述的还是有点不清楚的，不过读懂了题目就很好做了。</p>
<p>首先给它当做完全图全部连上，然后看看哪些是能够去掉的。如果两点之间有一条路径和两点直连的边长度一样，那么这条边肯定没用了。</p>
<p>参照弗洛伊德算法，三重循环即可解决。</p>
<p>去重的部分有点 low 了，居然真的是全部记下来去重，其实只需要打个标记就可以了，不过写代码前没有想到重复这一点，所以写出了下面这段代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
const int N = 305;
int n, f[N][N];
struct kkk { 
	int u, v; 
	bool operator &lt; (kkk b) const {
		return u &lt; b.u || (u == b.u &amp;&amp; v &lt; b.v);
	}
	bool operator == (kkk b) const {
		return u == b.u &amp;&amp; v == b.v;
	}
};
struct twt {
	std::vector&lt;kkk&gt; a;
	int s;
	twt() { a.clear(); s = 0; }
	void push(int u, int v) {
		if(u &gt; v) std::swap(u, v);
		a.push_back((kkk){u, v});
	}
	void unique() {
		std::sort(a.begin(), a.end());
		s = std::unique(a.begin(), a.end()) - a.begin();
	}
	int size() { return s; }
} e;
int main() {
	freopen(&quot;road.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;road.out&quot;, &quot;w&quot;, stdout);
	
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++)
		for(int j = 1; j &lt;= n; j++) 
			scanf(&quot;%d&quot;, &amp;f[i][j]);
	for(int k = 1; k &lt;= n; k++)
		for(int i = 1; i &lt;= n; i++)
			for(int j = 1; j &lt;= n; j++)
				if(i != j &amp;&amp; i != k &amp;&amp; j != k &amp;&amp; f[i][k] + f[k][j] == f[i][j])
					e.push(i, j);
	e.unique();
	printf(&quot;%d&quot;, n * (n-1) / 2 - e.size());
	return 0;
}
</code></pre>
<h3 id="b">B</h3>
<p>大约半个小时完成了第一题之后就开始做第二题了。</p>
<blockquote>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>→</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \rightarrow 2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的二进制数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 有一个参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>, 求最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>, 使在保持 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个二进制位不变的情况下，其它位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding="application/x-tex">01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span></span></span></span> 任意取，所产生的数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(y) = f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>.</p>
</blockquote>
<p>同样是题意非常难理解的题目。</p>
<p>首先想到的当然是暴力做法，直接枚举，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mrow><mn>3</mn><mi>n</mi></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^{3n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 无法接受，所以考虑能否去掉一层枚举。</p>
<p>赛场上想到了一种做法，就是枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 并且将它的参数记录到其最大的和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 相同的部分中。但由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 位相同其它的也可以相同，所以再来一次记忆化搜索，更新这些状态使它们成为最后的答案。</p>
<p>赛场上以为时间是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^{2n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的， 便认为可以过，然后又因为一些细节原因调了好久的代码，最后一测发现超时，分数还没有暴力高。</p>
<p>其实这个做法时间复杂度是仍然是暴力，因为虽然经过的状态只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 级别，但转移很多，如果建成图的话，就是这个样子，边特别多，导致了超时。</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/guivH1"><img src="https://z3.ax1x.com/2021/05/04/guivH1.png" alt="guivH1.png" loading="lazy"></a></figure>
<h2 id="c">C</h2>
<p>赛时没有时间做。</p>
<h2 id="分析">分析</h2>
<h3 id="题目分析">题目分析</h3>
<h4 id="a-2">A</h4>
<p>在 A 题中，开始没有考虑好整个算法就贸然去写，然后要解决重复问题，没有仔细思考就采用了较为暴力的写法，耽误了一些时间。</p>
<h4 id="b-2">B</h4>
<p>在 B 题种使用了错误的时间复杂度分析。其实这个就和传递闭包的分析是一样的，虽然点只有这么一些，但是边时要全部遍历到的，时间复杂度就大大上升了。</p>
<p>而 B 题的正确做法其实并不难。只需要换一种思路去暴力就可以了。直接枚举所有的有太多的重复和不必要。</p>
<p>可以先枚举要定死的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个，然后再分开枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个之间的和之外的，这样就没有了重复，然后一分析时间复杂度，每一个仅有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个之内 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个之内 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个之外 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个之外 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 四种可能，时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">4^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 可以通过此题了。</p>
<h4 id="c-2">C</h4>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 段区间选若干，令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 为选中的个数， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 为选中的都覆盖的长度，求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>{</mo><mi>t</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mi>x</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\min\{tot, x\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">{</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">}</span></span></span></span> 的最大值。</p>
</blockquote>
<p>这个其实也属于最小值最大，应该考虑二分。</p>
<p>首先确认一下单调性，小的肯定比大的更容易获得，而且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 增大了， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 肯定会减小（或者不变），那么我们就可以只枚举一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 再判断是否有更大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 了。因为如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 更小，而此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是可以的，那么我们在让二分的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 变小的时候同样可以满足取原先的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 个，所以不需要再判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 了，直接二分 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 即可以了。</p>
<p>感觉这个二分还是有点不一样的，略微有些只可意会不可言传的感觉。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int N = 300005;
struct twt { int l, r; } r[N];
int n, sumr[N], suml[N];
bool check(int x) {
    memset(sumr, 0, sizeof(sumr));
    memset(suml, 0, sizeof(suml));
    int cnt = 0;
    for (int i = 1; i &lt;= n; i++)
        if (x &lt;= r[i].r - r[i].l + 1) cnt++, sumr[r[i].r]++, suml[r[i].l]++;
    for (int i = 2; i &lt;= n; i++) sumr[i] += sumr[i - 1];
    for (int i = n - 1; i &gt;= 1; i--) suml[i] += suml[i + 1];
    for (int i = x; i &lt;= n; i++) {
        int l = i - x + 1;
        if (x &lt;= cnt - sumr[i - 1] - suml[l + 1]) return true;
    }
    return false;
}
int main() {
    freopen(&quot;interval.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;interval.out&quot;, &quot;w&quot;, stdout);
    
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;r[i].l, &amp;r[i].r);
    int l = 2, r = n, ans = 1;
    while (l &lt;= r) {
        int mid = (l + r) / 2;
        if (check(mid)) ans = mid, l = mid + 1;
        else r = mid - 1;
    }
    printf(&quot;%d&quot;, ans);
    return 0;
}
</code></pre>
<h3 id="决策分析">决策分析</h3>
<p>我在进行这场比赛时，没有思考透彻和分析透彻便贸然写题，未遵循 SOP 要求，且 C 题调了很久后仍然死磕，未执行相关检查单。</p>
<p>根据 CVR 记录，我在 <s>一万英尺以下</s> 全程都未遵循 SCR, 没能静下心来冷静思考。</p>
<p>最终才导致了没能做出 B 题或获得 C 题的部分分/正解。</p>
<h2 id="结论">结论</h2>
<p>本次模拟赛由于我未按照 SOP 和 SCR 要求放弃 B 题和冷静思考，导致构成构成严重事故征候。</p>
<p>建议：</p>
<ol>
<li>比赛时严格遵照 SOP 做题，若一题超过一小时未果先完成后面部分分内容。</li>
<li>严格遵守 SCR 规定，独立冷静思考。</li>
<li><strong>考虑暴力程序时应考虑不同的写法及重复和不必要尽可能少的写法。</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解  [APIO2013]道路费用]]></title>
        <id>https://acfboy.pw/apio2013daolufeiyong/</id>
        <link href="https://acfboy.pw/apio2013daolufeiyong/">
        </link>
        <updated>2021-05-03T23:01:11.000Z</updated>
        <summary type="html"><![CDATA[<p>涨见识了。神奇的缩点和最小生成树的套路。</p>
]]></summary>
        <content type="html"><![CDATA[<p>涨见识了。神奇的缩点和最小生成树的套路。</p>
<!-- more -->
<p>拿到题目首先得发现并不是一定要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 条全部放进最小生成树里才是最优的，然后一看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的范围只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>, 那么久可以枚举哪些放进去了。</p>
<p>可这样的复杂度就已经一百多万了，再跑最小生成树的复杂度肯定无法接受。发现最小生成树的边中有大量是重复的。于是可以先把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 条边都加入最小生成树里面，然后再跑一遍 Kruscal, 就可以得到一定在最小生成树里面的边，把这些边进行缩点，然后就得到了一张点数仅 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 的图。</p>
<p>但边可能由很多，所以我们再对缩点后的原图跑一个最小生成树，就可以得到可能在最小生成树里的边了。这样边数也被限制在了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的附近。</p>
<p>然后我们就可以枚举取的边了，但是边权限制最大是多少呢？可以用最小生成树的性质来优化边权，即加入一条边所构成的环里面不能有不在最小生成树上的边比在里面的更小。这样就可以约束边权了。因为范围小，不用倍增，直接爬树就行了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#define int long long
const int N = 100005, M = 400005, INF = 0x3f3f3f3f;
int n, m, k, max[N], fae[N], p[N], sum[N], tot, ans, st, id[N], fa[N],
	d[N];
bool in[M];
std::vector&lt;int&gt; g[N], nods;
struct twt {
	int u, v, w;
	bool operator &lt; (twt b) const {
		return w &lt; b.w;
	}
} e[M], T[M];
int find(int x) {
	if(x != id[x]) id[x] = find(id[x]);
	return id[x];
}
void merge(int x, int y) { id[find(x)] = find(y); }
void add(int u, int v) {
	g[u].push_back(v);
	g[v].push_back(u);
}
void Kruscal() {
	for(int i = 1; i &lt;= m; i++) in[i] = 0;
	std::sort(e+1, e+m+1);
	for(int i = 1; i &lt;= m; i++) {
		int fx = find(e[i].u), fy = find(e[i].v);
		in[i] = (fx != fy), merge(fx, fy);
	}
}
void dfs(int u, int f) {
	sum[u] = p[u], fa[u] = f, d[u] = d[f] + 1;
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == f) continue;
		dfs(v, u);
		sum[u] += sum[v];
	}
}
void upd(int u, int v, int w) {
	if(d[u] &lt; d[v]) std::swap(u, v);
	while(d[u] &gt; d[v]) max[fae[u]] = std::min(max[fae[u]], w), u = fa[u];
	while(u != v) max[fae[u]] = std::min(max[fae[u]], w), max[fae[v]] = std::min(max[fae[v]], w),
				  u = fa[u], v = fa[v];
}
signed main() {
	scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= m; i++) scanf(&quot;%lld%lld%lld&quot;, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);
	for(int i = 1; i &lt;= k; i++) scanf(&quot;%lld%lld&quot;, &amp;e[m+i].u, &amp;e[m+i].v);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;p[i]);
	for(int i = 1; i &lt;= n; i++) id[i] = i;
	for(int i = m+1; i &lt;= m+k; i++) merge(e[i].u, e[i].v);
	Kruscal();
	for(int i = 1; i &lt;= n; i++) id[i] = i;
	for(int i = 1; i &lt;= m; i++)
		if(in[i]) merge(e[i].u, e[i].v);
	for(int i = 1; i &lt;= n; i++) 
		if(find(i) == i) nods.push_back(i);
		else p[id[i]] += p[i];
	st = find(1);
	for(int i = 1; i &lt;= m+k; i++) e[i].u = find(e[i].u), e[i].v = find(e[i].v);
	Kruscal();
	for(int i = 1; i &lt;= m; i++) 
		if(in[i]) T[++tot] = (twt){e[i].u, e[i].v, e[i].w};
	for(int i = 1; i &lt;= tot; i++) e[i] = T[i];
	for(int i = 1; i &lt;= k; i++) e[i+tot] = e[i+m];
	m = tot;
	// printf(&quot;%lld %lld\n&quot;, m, k);
		// for(int i = 1; i &lt;= m+k; i++) printf(&quot;%lld %lld\n&quot;, e[i].u, e[i].v); //puts(&quot;&quot;);
	for(int S = 0; S &lt; (1 &lt;&lt; k); S++) {
		for(int i = 0; i &lt; (signed)nods.size(); i++) id[nods[i]] = nods[i], g[nods[i]].clear();
		for(int i = 1; i &lt;= k; i++)
			if((1 &lt;&lt; (i-1)) &amp; S) merge(e[i+m].u, e[i+m].v);
		Kruscal();
		for(int i = 1; i &lt;= k; i++) 
			if((1 &lt;&lt; (i-1)) &amp; S) add(e[i+m].u, e[i+m].v), in[i+m] = 1;
			else in[i+m] = 0;
		int ecnt = 0;
		for(int i = 1; i &lt;= m+k; i++) ecnt += in[i];
		if(ecnt &gt; (signed)nods.size()-1) continue;
		for(int i = 1; i &lt;= m; i++) if(in[i]) add(e[i].u, e[i].v);
		dfs(st, 0);
		for(int i = 1; i &lt;= m+k; i++) 
			if(in[i]) {
				int u = e[i].u, v = e[i].v;
				if(fa[u] == v) fae[u] = i;
				else fae[v] = i;
				max[i] = (i &lt;= m) ? 0 : INF;	
			}
		int an = 0;
		for(int i = 1; i &lt;= m; i++)
			if(!in[i]) upd(e[i].u, e[i].v, e[i].w);
		for(int i = m+1; i &lt;= m+k; i++)
			if(in[i]) an += sum[(fa[e[i].u] == e[i].v) ? e[i].u : e[i].v] * max[i];
		ans = std::max(ans, an);
		// printf(&quot;%lld\n&quot;, S);
	}
	printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
<p>去磕这样的题感觉没有什么提高而又很大程度降低了做题效率，所以今天开始改一下 SOP 吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Global Round 14 掉分记]]></title>
        <id>https://acfboy.pw/codeforces-global-round-14/</id>
        <link href="https://acfboy.pw/codeforces-global-round-14/">
        </link>
        <updated>2021-05-03T07:46:23.000Z</updated>
        <summary type="html"><![CDATA[<p>顺利地掉回了 specilist。</p>
<p>越到后面脑子越混，直接就弃疗了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>顺利地掉回了 specilist。</p>
<p>越到后面脑子越混，直接就弃疗了。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题。直接若不满足直接前后调换，因为保证数都不同，所以这样是对的。</p>
<h2 id="b">B</h2>
<p>显然只有样例中两种可以组合成其它的。</p>
<h2 id="c">C</h2>
<p>可以证明，如果存在方案，那么每次塞到最小的塔里面是最优的。</p>
<p>使用反证法：如果有两块的差超过了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, 因为单个的块高度不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, 所以肯定相差了超过一块，而我们的方案不会允许超过一块的存在（如果有解的话）。</p>
<p>然后用 <code>priority_queue</code> 搞一搞就好了。</p>
<h2 id="d">D</h2>
<p>这题明明特别简单，赛时有三千多个通过，我居然没有做出来。</p>
<p>大致思路是对的，肯定是要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">n/2 - l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 次变换左右，尽量把相同的数字均匀地分到两边。</p>
<p>但是我犯了一个致命的错误。应该先把匹配的给去掉而不是先分了再去掉，因为这些肯定不参与变换，如果把它们也给所谓均分了就不对了。</p>
<p>赛时脑子糊涂得不得了，没有想到这一点，于是愉快掉分，回到了青。</p>
<p>代码写得特别丑，是老老实实存每一个数的，因为没有想到可以直接记录每一个数字出现的次数。所以不放代码了。</p>
<hr>
<p>距离 APIO 不到 20 天了，然而什么似乎都是一团糟的状态。</p>
<p>翘翘要加油冲鸭。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZONe Energy Programming Contest 游记]]></title>
        <id>https://acfboy.pw/zone-energy-programming-contest/</id>
        <link href="https://acfboy.pw/zone-energy-programming-contest/">
        </link>
        <updated>2021-05-02T07:45:45.000Z</updated>
        <summary type="html"><![CDATA[<p>题目质量还是比较高的——就是数据有点水啊。</p>
]]></summary>
        <content type="html"><![CDATA[<p>题目质量还是比较高的——就是数据有点水啊。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>字符串入门题。</p>
<h2 id="b">B</h2>
<p>初中数学之三角函数。</p>
<h2 id="c-1">C - 1</h2>
<p>为什么要把这题难的放在前面？</p>
<p>开始做的时候觉得是贪心，但很容易找出反例发现不一定要选一位上最大的，所以就没有什么思路了，先去看看 D 再来。</p>
<h2 id="d">D</h2>
<p>看上去高大上，其实仍然是水题，搞个 <code>deque</code> 处理反转和添加，然后用栈处理相邻的会消掉的问题。</p>
<p>C 耽误了一些时间，不然更快地过这题，可能排名会更高。</p>
<h2 id="c-2">C - 2</h2>
<p>现在重新来思考 C 题。有了前面的经验可以知道大概率不会是 dp 了，因为局部最优没有办法得到全局最优，且这些数那么大也不能拿来做状态。</p>
<p>考虑了二分，但是由于没法直接选相似的原因，二分不能验证。</p>
<p>所以回到最初的思路，直接暴力枚举三个，这样的话时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 的，不能接受，但只要优化掉一维就可以通过了。</p>
<p>注意到题目中出现的常数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>, 题目没有设置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个肯定是因为这俩常数是有用的。有抽屉原理可以知道，选择的三行中，至少有一行包含了超过一个最大值。</p>
<p>但是这样还是没有办法做，因为既可能是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>−</mo><mn>1</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">3-1-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的分布，也有可能是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>−</mo><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2-2-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的分布。然后又卡了一会儿恍然大悟，同样抽屉原理可以得到两行肯定包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个以上的最大值啊！</p>
<p>所以只要枚举两行再枚举没有取到最大值的一列给它取上当前列的最大值就可以了。至于那一列的最大值可以直接读入的时候预处理出来。</p>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。代码如下。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
int n, max[3005], a[3005][10], ans;
int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) 
        for(int j = 1; j &lt;= 5; j++) 
            scanf(&quot;%d&quot;, &amp;a[i][j]), max[j] = std::max(max[j], a[i][j]);
    for(int i = 1; i &lt;= n; i++)
        for(int j = i+1; j &lt;= n; j++) {
            int tmax[6] = {0, 0, 0, 0, 0, 0};
            for(int k = 1; k &lt;= 5; k++) tmax[k] = std::max(tmax[k], std::max(a[i][k], a[j][k]));
            for(int k = 1; k &lt;= 5; k++) {
                int tmp = tmax[k], an = 2000000000;
                tmax[k] = max[k];
                for(int k = 1; k &lt;= 5; k++) an = std::min(an, tmax[k]);
                ans = std::max(ans, an);
                tmax[k] = tmp;
            }
        }
    printf(&quot;%d&quot;, ans);
    return 0;
}
</code></pre>
<h2 id="e">E</h2>
<p>乍一看还以为是 Dijkstra 的板子。</p>
<p>抱着暴力出奇迹的信仰 <s>没有分析复杂度</s> 我写了一发 Dijkstra 就直接交了，居然只 T 了一个点，然后卡了卡常，但也没能通过。</p>
<p><s>比赛结束有有人告诉我胡乱剪枝就过了。</s></p>
<p>然后开始尝试构造 hack 数据，不过构造得有些麻烦，因为要让点尽可能多的被重复松弛，最后成功卡掉我自己和其它直接 Dijkstra 的方法是随机一半的概率放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，其它放随机数，这样生成的极限数据 Dijkstra 需要 2.5s 才过。</p>
<p>直接做当然 T, 因为边数可以达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">500^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 条，点数也有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">500^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 个。而 Dijkstra 的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">(n+m) \log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 的。<s>能 hack 的话我就把他们全部叉掉！</s></p>
<p>那么正确做法是怎么样的呢？</p>
<p>如果没有最后一条限制，那么直接 Dijkstra 可以通过，因为边数和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 一个数量级。</p>
<p>那么考虑把最后一种操作转换成向前面一样的常规操作。如果向上的代价是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，那么直接向上连长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的边就可以了。但这里要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 所以用分层图来处理，第二层图向上连长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的边，再用长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的边连到第一层。然后一层到二层再连上长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的边就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 505;
struct twt {
    int x, y, k, d;
    bool operator &lt; (twt b) const {
        return d &gt; b.d;
    }
};
std::priority_queue&lt;twt&gt; que;
int R, C, a[N][N], b[N][N], dis[N][N][2];
void Dijkstra() {
    memset(dis, 0x3f, sizeof dis);
    que.push((twt){1, 1, 0});
    dis[1][1][0] = 0;
    while(!que.empty()) {
        twt now = que.top(); que.pop();
        int x = now.x, y = now.y, d = now.d, k = now.k;
      	if(x == R &amp;&amp; y == C) break;
        if(now.d != dis[x][y][k]) continue;
        if(k == 0) {
            if(y &lt; C &amp;&amp; d + a[x][y] &lt; dis[x][y+1][k]) {
                dis[x][y+1][k] = d + a[x][y];
                que.push((twt){x, y+1, 0, dis[x][y+1][k]});
            }
            if(y &gt; 1 &amp;&amp; d + a[x][y-1] &lt; dis[x][y-1][k]) {
                dis[x][y-1][k] = d + a[x][y-1];
                que.push((twt){x, y-1, 0, dis[x][y-1][k]});
            }
            if(x &lt; R &amp;&amp; d + b[x][y] &lt; dis[x+1][y][k]) {
                dis[x+1][y][k] = d + b[x][y];
                que.push((twt){x+1, y, 0, dis[x+1][y][k]});
            }
            if(d+1 &lt; dis[x][y][1]) {
                dis[x][y][1] = d+1;
                que.push((twt){x, y, 1, dis[x][y][1]});
            }
        }
        else {
            if(x &gt; 1 &amp;&amp; d + 1 &lt; dis[x-1][y][1]) {
                dis[x-1][y][1] = d+1;
                que.push((twt){x-1, y, 1, dis[x-1][y][1]});
            }
            if(d &lt; dis[x][y][0]) {
                dis[x][y][0] = d;
                que.push((twt){x, y, 0, dis[x][y][0]});
            }
        }
    }
}
signed main() {
    scanf(&quot;%lld%lld&quot;, &amp;R, &amp;C);
    for(int i = 1; i &lt;= R; i++)
        for(int j = 1; j &lt; C; j++) scanf(&quot;%lld&quot;, &amp;a[i][j]);
    for(int i = 1; i &lt; R; i++)
        for(int j = 1; j &lt;= C; j++) scanf(&quot;%lld&quot;, &amp;b[i][j]);
    Dijkstra();
    printf(&quot;%lld&quot;, dis[R][C][0]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.4.30 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210430/</id>
        <link href="https://acfboy.pw/20210430/">
        </link>
        <updated>2021-04-30T06:15:43.000Z</updated>
        <summary type="html"><![CDATA[<p>不想说什么了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>不想说什么了。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>说难不难说简单不简单的一道题。</p>
<blockquote>
<p>“说难不？难。说简单！不简单。”的一道题。</p>
</blockquote>
<blockquote>
<p>“说难不难。说简单不？简单。”的一道题。</p>
</blockquote>
<p><s>好了好了不整活了</s></p>
<blockquote>
<p>给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个括号序列，能否将其拼成一个匹配的括号序列。</p>
</blockquote>
<p>这道题其实是考察思维的严谨性。</p>
<p>首先的想法是是否个数相等就行。这显然是不行的。</p>
<p>观察得到肯定要是去除匹配之后全左和全右的在两边。于是我就认为两边有中间匹配就行。</p>
<p>然后 WA 了。</p>
<p>发现了反例，觉得中间要判断一下才行。</p>
<p>然后又 WA 了。</p>
<p>接着又觉得要把右括号少的放前面。</p>
<p>又双叒叕 WA 了。</p>
<p>其实以上的反例都特别好找，而且都没有严谨的理论基础，只是找了几个数据就凭着感觉上的，和直接猜结论没有本质的区别。</p>
<p>所以有了例子还是得从理论出发找到做法。</p>
<ol>
<li>最左边右括号不能没有匹配</li>
<li>保证了前面不会出事的情况下肯定是左括号越多越好，以应对未来的右括号。</li>
</ol>
<p>根据这个排序即可。这个想法似乎也有所特别，和大部分人的不一样。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
std::string s, tmp, stl, str, stn;
char st[1000005];
int numl, numr, n, lenl, lenr;
struct twt {
    std::string st;
    int k;
    bool operator&lt;(twt b) const {
        return (k &lt;= stl.size()) &gt; (b.k &lt;= stl.size()) ||
               ((k &lt;= stl.size()) == (b.k &lt;= stl.size()) &amp;&amp; st.size() - k &gt; b.st.size() - b.k);
    }
};
std::vector&lt;twt&gt; a;
bool checkl(std::string s) {
    if (s.size() == 0)
        return false;
    for (int i = 0; i &lt; (signed)s.size(); i++)
        if (s[i] == ')')
            return false;
    return true;
}
bool checkr(std::string s) {
    if (s.size() == 0)
        return false;
    for (int i = 0; i &lt; (signed)s.size(); i++)
        if (s[i] == '(')
            return false;
    return true;
}
int main() {
    std::ios::sync_with_stdio(false);
    std::cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) {
        std::cin &gt;&gt; tmp;
        s = &quot;&quot;;
        int top = 0;
        for (int j = 0; j &lt; (signed)tmp.size(); j++)
            if (tmp[j] == ')') {
                if (st[top] == '(')
                    top--;
                else
                    st[++top] = ')';
            } else
                st[++top] = '(';
        for (int j = 1; j &lt;= top; j++) s = s + st[j];
        if (checkl(s))
            stl += s;
        else if (checkr(s))
            str += s;
        else {
            int k = 0;
            for (int j = 0; j &lt; (signed)s.size(); j++) k += s[j] == ')';
            a.push_back(twt{ s, k });
        }
    }
    std::sort(a.begin(), a.end());
    std::string an = stl;
    for (int i = 0; i &lt; (signed)a.size(); i++) an += a[i].st;
    an += str;
    // std::cout &lt;&lt; an &lt;&lt; std::endl;
    int now = 0;
    for (int i = 0; i &lt; (signed)an.size(); i++) {
        if (an[i] == '(')
            now++;
        else
            now--;
        if (now &lt; 0)
            return puts(&quot;No&quot;), 0;
    }
    if (now != 0)
        puts(&quot;No&quot;);
    else
        puts(&quot;Yes&quot;);
}
</code></pre>
<p>花了我一小时二十分钟qwq。</p>
<h2 id="b">B</h2>
<p>水题</p>
<h2 id="c">C</h2>
<p>水题</p>
<h2 id="e">E</h2>
<p>有点细节啊，就是要处理一个部分循环的问题，但还是花了好久。</p>
<h2 id="d">D</h2>
<p>不难的组合数学。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个格子填 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 种颜色，使相邻的格子不能有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个以上颜色相同的方案数。</p>
</blockquote>
<p>先插板，然后再乘法原理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>×</mo><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>×</mo><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">m\times(m-1)\times(m-1) \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>。</p>
<p>答案就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></msubsup><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>m</mi><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><msup><mo>)</mo><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{i=0}^k C_{n-1}^{n-i-1}m (m-1)^{n-i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.313647em;vertical-align:-0.324639em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864795em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="最后">最后</h2>
<p>名次全无往日威风了。</p>
<p>感觉状态不增反降，越来越差了。</p>
<p>越是没法静心做题，就越是没法面对自己；越是没法面对自己，就越是没法静心做题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2013]机器人]]></title>
        <id>https://acfboy.pw/apio2013robot/</id>
        <link href="https://acfboy.pw/apio2013robot/">
        </link>
        <updated>2021-04-29T12:10:37.000Z</updated>
        <summary type="html"><![CDATA[<p>这居然也是 dp? 很难想到啊！这个数据范围就只想着搜索了。</p>
<p>这居然还是斯坦纳树？刚做完斯坦纳树模板就不会……神题啊。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这居然也是 dp? 很难想到啊！这个数据范围就只想着搜索了。</p>
<p>这居然还是斯坦纳树？刚做完斯坦纳树模板就不会……神题啊。</p>
<!-- more -->
<p>题目很长，放<a href="https://www.luogu.com.cn/problem/P3638">传送门</a>。</p>
<p>看到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 的数据范围认为应该是道搜索题了，但是直接暴力的复杂度大得不得了，猜想应该预处理出些什么，或者有什么性质。但是什么神奇的性质都没有发现。</p>
<p>其实这题还是隐隐约约有一些图论模型在的，因为并不是在这个网格中随便的走，而是要撞上障碍物。所以容易想到可以处理出每一个点向每一个方向走最后会到达的位置。</p>
<p>然后就考验对斯坦纳树的算法的理解了。</p>
<p>在斯坦纳树中，我们定义了一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 状态的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 为根的最小的权值和，然后先进行了一下常规的转移，即可以用原来结果直接得到的转移，然后通过一次最短路让当前的一些状态去松弛其它的状态。</p>
<p>这道题中也可以用类似的思想在做。</p>
<p>因为题目中要求的是连续区间才能合并成一个新的区间，我们可以用区间 dp 的方式来实现这一点。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 中的合成一块儿到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 号位置的最小代价，然后先直接合并原来的答案，再用 spfa 松弛一遍就好了。<s>这 spfa 被卡需要用玄学优化才能过，但我们不管，直接吸氧</s></p>
<p>这不经让我思考：到底什么样的东西才可以用这样的方法来做的呢？</p>
<p>其实关键在于那个 spfa 的转移，因为前面的常规转移在一般的情况下是很容易被想到的。在这两题中，用 spfa 的转移都有一个性质，那就是可能会构成一个环形的转移，并且能搞那什么三角等式。其实这不就是图上最短路的一个特征吗，我们把 dis 看成是 dp 数组，它就没有办法直接转移，因为不知道顺序是怎样的，而又可以松弛，所以就用到最短路的算法了。</p>
<p>最后放上代码吧。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
const int N = 505;
int f[10][10][N*N], h, w, n, left[5], right[5], id[N][N], cnt, tran[N*N][4], p[N*N],
	ans, nowa, nowb, q[N*N], head, tail;
int dx[4] = {0, 0, 1, -1},
	dy[4] = {1, -1, 0, 0};
bool vis[N*N], vi[N*N][4];
char s[N][N];
bool cmp(int a, int b) { return f[nowa][nowb][a] &lt; f[nowa][nowb][b]; }
bool pd(int i, int j) { return (i &lt; 1 || j &lt; 1 || i &gt; h || j &gt; w || s[i][j] == 'x'); }
void init() {
	left[0] = 3, left[3] = 1, left[1] = 2, left[2] = 0;
	right[0] = 2, right[2] = 1, right[1] = 3, right[3] = 0;
	memset(f, 0x3f, sizeof f);
	memset(tran, -1, sizeof tran);
}
void spfa(int x, int y, int s) {
	head = tail = 1;
	q[tail] = s;
	while(head &lt;= tail) {
		int u = q[head];
		vis[u] = 0;
		head++;
		for(int i = 0; i &lt; 4; i++) {
			int v = tran[u][i];
			if(v &lt;= 0) continue;
			if(f[x][y][v] &gt; f[x][y][u] + 1) {
				f[x][y][v] = f[x][y][u] + 1;
				if(!vis[v]) q[++tail] = v, vis[v] = 1;
			}
		}
	}
}
int dfs(int i, int j, int k) {
	if(tran[id[i][j]][k] != -1) return tran[id[i][j]][k];
	if(vi[id[i][j]][k]) return 0;
	vi[id[i][j]][k] = 1;
	int xx = i + dx[k], yy = j + dy[k];
	if(pd(xx, yy)) {
		vi[id[i][j]][k] = 0, tran[id[i][j]][k] = id[i][j];
		return id[i][j];
	}
	if(s[xx][yy] == 'A') {
		tran[id[i][j]][k] = dfs(xx, yy, left[k]);
		vi[id[i][j]][k] = 0;
		return tran[id[i][j]][k];
	}
	else if(s[xx][yy] == 'C') {
		tran[id[i][j]][k] = dfs(xx, yy, right[k]);
		vi[id[i][j]][k] = 0;
		return tran[id[i][j]][k];
	}
	tran[id[i][j]][k] = dfs(xx, yy, k);
	vi[id[i][j]][k] = 0;
	return tran[id[i][j]][k];
}
int main() {
	init();
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;w, &amp;h);
	for(int i = 1; i &lt;= h; i++) scanf(&quot;%s&quot;, s[i]+1);
	for(int i = 1; i &lt;= h; i++)
		for(int j =  1; j &lt;= w; j++)
			if(!pd(i, j)) {
				id[i][j] = ++cnt;
				if(s[i][j] &gt;= '0' &amp;&amp; s[i][j] &lt;= '9') 
					f[s[i][j]-'0'][s[i][j]-'0'][cnt] = 0;
			}
	for(int i = 1; i &lt;= h; i++)
		for(int j = 1; j &lt;= w; j++) 
			if(!pd(i, j)) {
				for(int k = 0; k &lt; 4; k++) tran[id[i][j]][k] = dfs(i, j, k);
			}
	for(int i = 1; i &lt;= cnt; i++) p[i] = i;
	for(int len = 1; len &lt;= n; len++)
		for(int i = 1; i+len-1 &lt;= n; i++) {
			int j = i + len - 1;
			for(int k = 1; k &lt;= cnt; k++)
				for(int l = i; l &lt; j; l++)
					f[i][j][k] = std::min(f[i][j][k], f[i][l][k] + f[l+1][j][k]);
			nowa = i, nowb = j;
			std::sort(p+1, p+1+cnt, cmp);
			for(int k = 1; k &lt;= cnt; k++) spfa(i, j, p[k]);
		}
	ans = 2000000000;
	for(int i = 1; i &lt;= cnt; i++) ans = std::min(ans, f[1][n][i]);
	if(ans == 0x3f3f3f3f) puts(&quot;-1&quot;);
	else printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [POI2014]HOT-Hotels]]></title>
        <id>https://acfboy.pw/poi2014hothotels/</id>
        <link href="https://acfboy.pw/poi2014hothotels/">
        </link>
        <updated>2021-04-28T12:39:10.000Z</updated>
        <summary type="html"><![CDATA[<p>看了题解发现我的思路并没有走偏，只是遇到重复这类的问题时没有想到解决的办法。大概要获得解决这样问题的能力只能靠多做题积累吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>看了题解发现我的思路并没有走偏，只是遇到重复这类的问题时没有想到解决的办法。大概要获得解决这样问题的能力只能靠多做题积累吧。</p>
<!-- more -->
<blockquote>
<p>给定一棵树，在树上选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个点，要求两两距离相等，求方案数。</p>
</blockquote>
<p>首先有一个显然的性质，那就是只能是三个点从一个点直直的伸出去，即深度较深的两个点距离它们 LCA 的距离相同，也就是说深度要相同了。</p>
<p>那么考虑应该如何统计这样子深度相同的点。直接记录是不行的，因为要保证它们的 LCA 要在当前点，不能产生更深的公共祖先。</p>
<p>既然没法一蹴而就，那么久先来两个的。于是有了两种想法，一个是枚举两个点，再通过什么方式来找到第三个点的个数（倍增似乎可做，但时间上无法接受），另一个是通过神奇的 dp 来解决。<s>然后我就没有想法了</s></p>
<p>平常我们的 dp 都是通过一个数组来解决，最多再来一个辅助计算。可是这里难以在一两个数组内解决问题，所以尝试记录更多的信息。可以枚举一个点，把它当做那两个较深的点的 LCA，再一个个枚举它的子树，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 记录前面的子树中有两个满足条件的深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的点的数量，那么再乘上当前子树中深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的节点数量就肯定满足要求了。</p>
<p>同样的分解还可以继续，令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 是前面子树中深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的点数量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">box[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 是当前子树中深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的点的数量，每次更新的时候让答案先加一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mi>b</mi><mi>o</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i] \times box[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>, 再把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mi>b</mi><mi>o</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i] \times box[i],g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">box[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#define int long long
const int N = 5005;
int x, y, n, f[N], box[N], g[N], ans, lim;
std::vector&lt;int&gt; G[N];
void dfs(int u, int fa, int d) {
	lim = std::max(lim, d);
	box[d] ++;
	for(int i = 0; i &lt; (signed)G[u].size(); i++) {
		int v = G[u][i];
		if(v == fa) continue;
		dfs(v, u, d+1);
	}
}
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt; n; i++) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		G[x].push_back(y), G[y].push_back(x);
	}
	for(int i = 1; i &lt;= n; i++) {
		memset(f, 0, sizeof f), memset(g, 0, sizeof g);
		for(int j = 0; j &lt; (signed)G[i].size(); j++) {
			int v = G[i][j];
			lim = 0;
			memset(box, 0, sizeof box);
			dfs(v, i, 1);
			for(int k = 1; k &lt;= lim; k++) {
				ans += f[k] * box[k];
				f[k] += g[k] * box[k];
				g[k] += box[k];
			}
		}
	}
	printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [SCOI2015]国旗计划]]></title>
        <id>https://acfboy.pw/scoi2015guoqijihua/</id>
        <link href="https://acfboy.pw/scoi2015guoqijihua/">
        </link>
        <updated>2021-04-28T10:52:44.000Z</updated>
        <summary type="html"><![CDATA[<p>难以置信，我居然会被这样一个问题难倒？！</p>
]]></summary>
        <content type="html"><![CDATA[<p>难以置信，我居然会被这样一个问题难倒？！</p>
<!-- more -->
<p>看到题目，排序和贪心很容易就可以看出来，但展开到链上的时候只知道跨越的要加上个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，但居然死活想不到要把每一个都复制一遍！然后就没辙了。</p>
<p>最近状态好像很糟糕的样子，修正了原先极左的错误，但似乎并没有提高什么，还是静不下来写题，过题量降到了很低的水平。</p>
<p>但这样至少是正视了问题，大概比整天做些“体力劳动大于脑力劳动”的题来营造通过数的假象以欺骗自己要好得多。现在没有状态，说得仿佛前面四个月很有状态一样；前面四个月没有状态，说得好像是前几年很有状态一样。</p>
<p>大概翘翘从来不曾可爱过，但又从来就向往“可爱”的样子。虽不能至，心向往之，总好过在打击中沉沦。</p>
<p>加油吧。</p>
]]></content>
    </entry>
</feed>