<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的博客</title>
    <updated>2021-04-25T12:32:16.553Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的博客</rights>
    <entry>
        <title type="html"><![CDATA[题解 [SHOI2007]书柜的尺寸]]></title>
        <id>https://acfboy.pw/shoi2007shuguidechicun/</id>
        <link href="https://acfboy.pw/shoi2007shuguidechicun/">
        </link>
        <updated>2021-04-25T12:30:05.000Z</updated>
        <summary type="html"><![CDATA[<p>被我想歪掉的 dp。</p>
]]></summary>
        <content type="html"><![CDATA[<p>被我想歪掉的 dp。</p>
<!-- more -->
<blockquote>
<p>给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个元素，每一个有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 把它们分成三组，使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 最大值的和 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 和的最大值的乘积最大。</p>
</blockquote>
<p>一看数据范围只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>70</mn></mrow><annotation encoding="application/x-tex">n \le 70</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">0</span></span></span></span> 胆子就大了起来，直接就 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mn>3</mn></msubsup></mrow><annotation encoding="application/x-tex">C_n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span> 取出当做最大值的三个，然后先当作按照顺序从这三个断点划分，这样唯一能进行的调整就是把后面的换到前面。然后再来一个 dp, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 表示能变的前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个变动后第一组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>, 第二组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是否可行，然后转移一波再验证就好了。顺利成章，马上要开始写了——不对，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msubsup><mi>C</mi><mi>n</mi><mn>3</mn></msubsup><mi>n</mi><msup><mi>s</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(C_n^3n s^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度没法接受啊……</p>
<p>等等！既然我排了序再搞这些名堂，为什么不直接排了序以后 dp? 这向上调换不就等于后面的能取到前面去吗？至于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>, 当作 dp 的值然后转移时若是从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 转移出去的就加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 不就完了吗？</p>
<p>滚动一下，控制好空间。时限 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">5s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord mathdefault">s</span></span></span></span>, 可以通过此题。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define int long long
const int N = 75, S = 2105, INF = 0x3f3f3f3fll;
struct twt {
	int h, t;
	bool operator &lt; (twt b) const {
		return h &gt; b.h;
	}
} a[N];
int n, sum[N], f[2][S][S], ans;
void ckmin(int &amp;x, int y) { x = std::min(x, y); }
int max(int x, int y, int z) { return std::max(x, std::max(y, z)); }
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld%lld&quot;, &amp;a[i].h, &amp;a[i].t);
	std::sort(a+1, a+1+n);
	for(int i = 1; i &lt;= n; i++) sum[i] = sum[i-1] + a[i].t;
	for(int i = 0; i &lt; S; i++)
		for(int j = 0; j &lt; S; j++) f[0][i][j] = f[1][i][j] = 0x3f3f3f3f;
	f[1][0][0] = f[0][0][0] = 0;
	int now, pre;
	for(int i = 1; i &lt;= n; i++) {
		now = i &amp; 1, pre = now ^ 1;
		for(int j = 0; j &lt; S; j++)
			for(int k = 0; k &lt; S; k++) f[now][j][k] = 0x3f3f3f3f;
		for(int j = 0; j &lt;= sum[i]; j++)
			for(int k = 0; k &lt;= sum[i]; k++) {
				if(f[pre][j][k] == INF) continue;
				if(j == 0) ckmin(f[now][j+a[i].t][k], f[pre][j][k] + a[i].h);
				else ckmin(f[now][j+a[i].t][k], f[pre][j][k]);
				if(k == 0) ckmin(f[now][j][k+a[i].t], f[pre][j][k] + a[i].h);
				else ckmin(f[now][j][k+a[i].t], f[pre][j][k]);
				if(sum[i-1]-j-k == 0)ckmin(f[now][j][k], f[pre][j][k] + a[i].h);
				else ckmin(f[now][j][k], f[pre][j][k]);
			}
	}
	int ans = INF;
	for(int i = 1; i &lt;= sum[n]; i++)
		for(int j = 1; j &lt;= sum[n]; j++)
			if(sum[n]-i-j != 0) ckmin(ans, max(i, j, sum[n]-i-j)*f[now][i][j]);
	printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.4.25 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210425/</id>
        <link href="https://acfboy.pw/20210425/">
        </link>
        <updated>2021-04-25T10:55:59.000Z</updated>
        <summary type="html"><![CDATA[<p><s>最近怎么一直打比赛啊，都没有练习的。</s></p>
<p>要论比赛体验，这场无疑是糟糕透顶，<s>听说是一个小时临时拼凑的</s>，题目没有一道是正常的，前面三道出锅，最后一道搬前天 cf 原题。</p>
<p>但其实题目质量还是不错的，可做性也挺高——但还是做不出来。</p>
]]></summary>
        <content type="html"><![CDATA[<p><s>最近怎么一直打比赛啊，都没有练习的。</s></p>
<p>要论比赛体验，这场无疑是糟糕透顶，<s>听说是一个小时临时拼凑的</s>，题目没有一道是正常的，前面三道出锅，最后一道搬前天 cf 原题。</p>
<p>但其实题目质量还是不错的，可做性也挺高——但还是做不出来。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>有点意思的结论题，但结论还是比较容易发现的。</p>
<blockquote>
<p>一个全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 矩阵，每次用这样形状的其中一块全部异或上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 能否全部变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<figure data-type="image" tabindex="1"><img src="https://z3.ax1x.com/2021/04/25/cvXPVs.png" alt="" loading="lazy"></figure>
</blockquote>
<p>证明也挺简单：首先若两个一起用，那么就是角上四个，肯定可以把长宽都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 的倍数的铺满而其它铺不了。若不是两个一起用，那么一定会留下缺口且无法修补，所以判断是否都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 的倍数就可以了。</p>
<h2 id="b">B</h2>
<blockquote>
<p>给定一个矩阵，从左上到右下的路径组成的序列中!有多少个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的上升子序列。</p>
</blockquote>
<p>开始想的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k][x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 表示到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>, 长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, 以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 结尾的答案，然后觉得这样难以转移，于是就把它前缀和掉，变成表示以小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 结尾的。<s>后来发现这样更难转移。</s></p>
<p>本想着每个两种情况就行了，霹雳扒拉写出代码，然后样例都没有过。</p>
<p>两种情况中就是把当前选上和不把当前选上，这里犯了两个很傻的错误：</p>
<ol>
<li>根本没有判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是不是大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，也就是这一位能不能选上去。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的转移漏了一种把当前选上的。</li>
</ol>
<p>第一个问题判断一下很好解决，但对于第二个问题，需要思考一下了，当前选上到底会产生几种方案？是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 种，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 种还是能从几个地方转移过来就几种？</p>
<p>其实都不是，因为只取这一个，所以从头到这里的每一条路径都可以产生一个贡献，得先 dp 预处理出有几条路径到这里。</p>
<p>最后是比赛后又调了很久才过的，其实原来的状态写起来会简单的很多，特别是避开了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 且当前选上的那个大坑。</p>
<p>不过最终还是要怪自己没有考虑清楚。轻敌了。无论什么样的题目都要确保考虑清楚了一个算法再去写啊！</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 55, p = 1000000007;
int n, m, a[N][N], f[N][N][N][N], k, C[N][N];
void dfs(int i, int j, int k, int x) {
	if(f[i][j][k][x] != -1) return;
	f[i][j][k][x] = 0;
	if(k == 1) {
		if(i == 1 &amp;&amp; j == 1) f[i][j][k][x] = (x &gt;= a[i][j]);
		if(i-1 &gt;= 1) {
			dfs(i-1, j, k, x), f[i][j][k][x] += f[i-1][j][k][x], f[i][j][k][x] %= p;
			if(x &gt;= a[i][j]) f[i][j][k][x] += C[i-1][j], f[i][j][k][x] %= p;
		}
		if(j-1 &gt;= 1) {
			dfs(i, j-1, k, x), f[i][j][k][x] += f[i][j-1][k][x], f[i][j][k][x] %= p;
			if(x &gt;= a[i][j]) f[i][j][k][x] += C[i][j-1], f[i][j][k][x] %= p;
		}
		return;
	}
	if(i-1 &gt;= 1) {
		if(x &gt;= a[i][j]) dfs(i-1, j, k-1, a[i][j]-1), f[i][j][k][x] = (f[i][j][k][x] + f[i-1][j][k-1][a[i][j]-1]) % p;
		dfs(i-1, j, k, x);
		f[i][j][k][x] = (f[i][j][k][x] + f[i-1][j][k][x]) % p;
	}
	if(j-1 &gt;= 1) {
		if(x &gt;= a[i][j]) dfs(i, j-1, k-1, a[i][j]-1), f[i][j][k][x] = (f[i][j][k][x] + f[i][j-1][k-1][a[i][j]-1]) % p;
		dfs(i, j-1, k, x);
		f[i][j][k][x] = (f[i][j][k][x] + f[i][j-1][k][x]) % p;
	}
}
signed main() {
	scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k);
	memset(f, -1, sizeof f);
	for(int i = 1; i &lt;= n; i++)	
		for(int j = 1; j &lt;= m; j++) scanf(&quot;%lld&quot;, &amp;a[i][j]);
	C[0][1] = 1;
	for(int i = 1; i &lt;= n; i++)
		for(int j = 1; j &lt;= m; j++)
			C[i][j] = (C[i][j-1] + C[i-1][j]) % p;
	dfs(n, m, k, 50);
	printf(&quot;%lld&quot;, f[n][m][k][50]);
	return 0;
}
</code></pre>
<h2 id="c">C</h2>
<p>题目经过一些比较显然的转换大概是这样：</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的矩阵选定一个起始点选定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>, 求在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 列之间每一行的最大值的和减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><msub><mi>s</mi><mi>r</mi></msub><mo>−</mo><mi>p</mi><mi>o</mi><msub><mi>s</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">pos_r -pos_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最大值。</p>
</blockquote>
<p>转换过程比较简单，但还是花了一会儿才想到，感觉旁边坐着个人比赛效率就直线下降。</p>
<p>暴力 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 能获得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>80</mn></mrow><annotation encoding="application/x-tex">80</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">0</span></span></span></span> 分。</p>
<p>然后就没辙了，想着那个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 怎么消得掉，于是想着去掉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, 半天未果，这端点显然没有单调性，去不掉。</p>
<p>其实就是要去掉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>, 还是一个比较套路的处理最大值和的方式：考虑每一个贡献的区间。</p>
<p>其实想到这个就挺简单的了，用单调栈可以处理出这样的一个区间，然后令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 列和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 列间的最大值的和，统计每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 的贡献就可以了。</p>
<p>这种矩阵中一块加上而又可以离线一次性处理完的使用二维差分就再合适不过了，树状数组都不用。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;stack&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define int long long
const int N = 5005, M = 305;
int n, m, pos[N], a[M][N], L[M][N], R[M][N], sum[N][N], ans;
signed main() {
	freopen(&quot;demon.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;demon.out&quot;, &quot;w&quot;, stdout);

	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;pos[i]);
	for(int i = 1; i &lt;= m; i++)
		for(int j = 1; j &lt;= n; j++) scanf(&quot;%lld&quot;, &amp;a[i][j]);
	for(int i = 1; i &lt;= m; i++) {
		std::stack&lt;int&gt; st;
		for(int j = 1; j &lt;= n; j++) {
			while(!st.empty() &amp;&amp; a[i][st.top()] &lt; a[i][j]) st.pop();
			if(!st.empty()) L[i][j] = st.top()+1; else L[i][j] = 1;
			st.push(j); 
		}
		while(!st.empty()) st.pop();
		for(int j = n; j &gt;= 1; j--) {
			while(!st.empty() &amp;&amp; a[i][st.top()] &lt;= a[i][j]) st.pop();
			if(!st.empty()) R[i][j] = st.top()-1; else R[i][j] = n;
			st.push(j);
		}
	}
	for(int i = 1; i &lt;= m; i++)
		for(int j = 1; j &lt;= n; j++) 
			sum[L[i][j]][j] += a[i][j], sum[j+1][R[i][j]+1] += a[i][j],
			sum[L[i][j]][R[i][j]+1] -= a[i][j], sum[j+1][j] -= a[i][j];
	for(int i = 1; i &lt;= n; i++) 
		for(int j = 1; j &lt;= n; j++)
			sum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];
	for(int l = 1; l &lt;= n; l++)
		for(int r = 1; r &lt;= n; r++)
		 	ans = std::max(sum[l][r] - pos[r] + pos[l], ans);
	printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
<h2 id="d">D</h2>
<p>放两天前的原题过分了。当我们不打 cf ?</p>
<hr>
<p>其实这场比赛带给我的提升还是挺大的，搬题人临时受命导致比赛质量低下也可以理解。</p>
<p>赛后订正的时候还是太浮躁了。穿着校服坐在这，仿佛谢兔兔的 “主要是静得下心来”  “学思学研”  “错的地方自己查（察）” 的教诲又回响在耳畔了。xhf 和 w策 不在安静了很多，<s>但我还是够吵的</s>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AtCoder Beginner Contest 199 游记]]></title>
        <id>https://acfboy.pw/abc199/</id>
        <link href="https://acfboy.pw/abc199/">
        </link>
        <updated>2021-04-24T23:59:58.000Z</updated>
        <summary type="html"><![CDATA[<p>我我我我居然独立做出了全场只有不到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn></mrow><annotation encoding="application/x-tex">400</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 人过的 E 题！</p>
<p>——可惜是在比赛结束以后……</p>
]]></summary>
        <content type="html"><![CDATA[<p>我我我我居然独立做出了全场只有不到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn></mrow><annotation encoding="application/x-tex">400</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 人过的 E 题！</p>
<p>——可惜是在比赛结束以后……</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题</p>
<h2 id="b">B</h2>
<p>水题</p>
<h2 id="c">C</h2>
<blockquote>
<p>交换两个或者把前一半和后一半交换，求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次变换后的结果。</p>
</blockquote>
<p>直接把前面一半和后面一半分开存就可以了。</p>
<h2 id="d">D</h2>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 条边的无向图，求用三种颜色染色后每条边相连的点不同的图有几种。</p>
</blockquote>
<p>一看数据范围显然是一个搜索题，不过直接搜索会有一些问题，因为先搜到哪个的不同可能图染色后是相同的，会造成重复，既然如此，那我们随便指定一个顺序就可以了。</p>
<p>然后居然错了三次才过，原因如下（全都是很傻的）：</p>
<ol>
<li>没定顺序，以为搜一个退出就行</li>
<li>认为度数有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 以上的都不行</li>
<li>数组开小！</li>
</ol>
<h2 id="e">E</h2>
<p>看了 standing 发现通过人数甚至比 D 要多！一下子就有了信心，不放弃地想。</p>
<p>看到题目大概就是两种想法，一是神奇的组合数学，二是 dp。通过组合数可以非常方便的算出一条限制的结果，但是对于多条限制的合并，组合数似乎吃不消了，因为它会变得无比复杂。</p>
<p>那么考虑的 dp, 数据范围只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>18</mn></mrow><annotation encoding="application/x-tex">18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span></span></span></span>, 可以进行状压，而且非常容易想到一个 dp, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> 表示已选的数集合为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 的方案数，那么再枚举下一个，然后再进行验证是否可行以及转移，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><msup><mi>n</mi><mn>2</mn></msup><mi>m</mi></mrow><annotation encoding="application/x-tex">2^nn^2m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span></span></span></span>, 显然会超时。</p>
<p>而转移的瓶颈在状态的验证。稍加观察就可以发现每一个条件只对状态中恰好有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的情况下有效，因为前面的都被前面的约束了，而且这种约束只和当前的状态有关，那么就可以分开来独立计算了。</p>
<p>时间复杂度的瓶颈仍然在验证状态是否可行，时间大约是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^nn^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 的，因为那个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 是被分掉的，不是乘上去的。</p>
<p>好耶，这些我都想到了，那么我的排名是不是要杀进前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn></mrow><annotation encoding="application/x-tex">400</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 了呢？</p>
<h3 id="并不因为我-i-和-j-写反了">并不，因为我 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 写反了！</h3>
<p>痛失 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>500</mn></mrow><annotation encoding="application/x-tex">500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 分，呜呜。 可能最后时间有点紧了，因为到最后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 分钟才想到以上的正解，到最后三分钟才写完，没有什么时间调试了。不过若没有这个手残还是可以过的。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define int long long
const int N = 20;
struct twt {
    int x, y, z;
    bool operator &lt; (twt b) { return x &lt; b.x; }
} a[N];
int n, m, L[N], R[N], g[N], f[(1 &lt;&lt; 19) + 5];
bool flag[(1 &lt;&lt; 19) + 5];
int popcount(int x) { return (x != 0) ? (popcount(x&amp;(x-1))+1) : 0; }
signed main() {
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= m; i++) scanf(&quot;%lld%lld%lld&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z);
    std::sort(a+1, a+1+m);
    for(int i = 1; i &lt;= n; i++) {
        for(int j = 1; j &lt;= m; j++) 
            if(a[j].x == i) {
                L[i] = j;
                break;
            }
        for(int j = m; j &gt;= 1; j--) 
            if(a[j].x == i) {
                R[i] = j;
                break;
            }
    }
    for(int S = 1; S &lt; (1 &lt;&lt; n); S++) {
        flag[S] = 1;
        int k = popcount(S);
        if(L[k] == 0) continue;
        for(int i = 1; i &lt;= n; i++) g[i] = 0;
        for(int i = 1, j = 1; i &lt;= k; i++) {
            while((S &amp; (1 &lt;&lt; j)) == 0) j++;
            for(int l = j; l &lt;= n; l++) g[l] ++;
            j++;
        }
        for(int i = L[k]; i &lt;= R[k]; i++) 
            flag[S] &amp;= (g[a[i].y] &lt;= a[i].z);
    }
    f[0] = 1;
    for(int S = 0; S &lt; (1 &lt;&lt; n); S++) 
        for(int i = 0; i &lt;= 18; i++)
            if(((S &amp; (1 &lt;&lt; i)) == 0) &amp;&amp; flag[S | (1 &lt;&lt; i)]) f[S | (1 &lt;&lt; i)] += f[S];
    printf(&quot;%lld&quot;, f[(1 &lt;&lt; n) - 1]);
    return 0;
}
</code></pre>
<hr>
<p>不过还是上分了！</p>
<figure data-type="image" tabindex="1"><img src="https://www.hualigs.cn/image/6084b04b299c7.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Contest 2050 and Codeforces Round #718 游记]]></title>
        <id>https://acfboy.pw/cf1517/</id>
        <link href="https://acfboy.pw/cf1517/">
        </link>
        <updated>2021-04-23T23:59:21.000Z</updated>
        <content type="html"><![CDATA[<p>难得有一场比赛大家全都来打了！</p>
<p>然而却是越做越糊涂，D 题开始搞错 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span> 后来又分析错时间，最后绝望极了，没能坚持到最后，放弃治疗。第二天发现其实挺简单的。</p>
<h2 id="a">A</h2>
<p>简单题。一遍过。</p>
<h2 id="b">B</h2>
<p>血的教训！清空不能一直滥用 <code>memset</code>, 不然这种多测保证积的和不超过几几几的会 T 掉。</p>
<h2 id="c">C</h2>
<p>简单题。一遍过。</p>
<h2 id="d">D</h2>
<blockquote>
<p>给定一张网格图，求每个点走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次后恰好回来所经过的最小边权。</p>
</blockquote>
<p>恰好回来的这种问题一看就想到分层图，然后一算时间是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>m</mi><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">nmk^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, 看到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 才二十以为能过，就无脑写了一波分层图 Dijkstra, 然后一开始搞错了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>, Wrong Answer on pretest 4, 修改后又 T 在了 pretest 5, 还傻乎乎的以为是小问题，然后交了两次 T 才自己造数据。</p>
<p>还瞎搞了一些无关紧要的压低常数做法，结果到好久之后才发现有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 张图，时间应该是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>m</mi><msup><mi>k</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">nmk^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 的，根本就是渐进复杂度错了。然后就<s>绝望等死了</s>没去重新想正解，转而放弃治疗了。</p>
<p>其实正解还要简单。</p>
<p>有一个很显然的性质，那就是一定是跑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>k</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{k}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 步后原路返回的，反证法易证。那么只需要看一个走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>k</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{k}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 步最少跨越多少边权了，随便 dp 或者记忆化搜索都可以。</p>
<p>最后还发现，原来先前写的代码不仅 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span> 搞错，循环的顺序也反了……</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define int long long
const int N = 505, K = 25, INF = 0x3f3f3f3f3f3f3f3fll, D = 1, U = 2, L = 3, R = 4;
int n, m, k, f[N][N][K], to[5][N][N], ans[N][N];
int dx[5] = {0, 1, -1, 0, 0},
    dy[5] = {0, 0, 0, -1, 1};
int dfs(int x, int y, int k) {
    if(k == 0) return 0;
    if(f[x][y][k] != -1) return f[x][y][k];
    f[x][y][k] = INF;
    for(int i = 1; i &lt;= 4; i++) {
        int xx = x + dx[i], yy = y + dy[i];
        if(xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;
        f[x][y][k] = std::min(f[x][y][k], dfs(xx, yy, k-1) + to[i][x][y]);
    }
    return f[x][y][k];
}
signed main() {
    scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k);
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt; m; j++) scanf(&quot;%lld&quot;, &amp;to[R][i][j]), to[L][i][j+1] = to[R][i][j];
    for(int i = 1; i &lt; n; i++)
        for(int j = 1; j &lt;= m; j++) scanf(&quot;%lld&quot;, &amp;to[D][i][j]), to[U][i+1][j] = to[D][i][j];
    memset(f, -1, sizeof f);
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++) 
            dfs(i, j, k/2);
    for(int i = 1; i &lt;= n; i++) {
        for(int j = 1; j &lt;= m; j++) printf(&quot;%lld &quot;, (k &amp; 1) ? -1 : f[i][j][k/2]*2);
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<hr>
<p>虽说比赛打得不怎么样，但别灰心啊，继续加油，总会有突破的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.4.23 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210423/</id>
        <link href="https://acfboy.pw/20210423/">
        </link>
        <updated>2021-04-23T07:58:30.000Z</updated>
        <summary type="html"><![CDATA[<p>体验十分糟糕的校内模拟赛。感觉这一天真是啥也没干，郁郁寡欢。</p>
<p>即使打得不好也要以昂扬的斗志面对生活鸭！</p>
]]></summary>
        <content type="html"><![CDATA[<p>体验十分糟糕的校内模拟赛。感觉这一天真是啥也没干，郁郁寡欢。</p>
<p>即使打得不好也要以昂扬的斗志面对生活鸭！</p>
<!-- more -->
<h2 id="a">A</h2>
<p>本来就是一个模拟平衡三进制的题，也就普及组一二题难度，结果比赛时题目改来改去，然后我又一时手残居然统计的时候从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 开始，于是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">100 \rightarrow 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
<h2 id="b">B</h2>
<p>反而这是比赛时体验最好的一题了，虽然题目长，但没有什么思维难度，就是最短路套上背包的板子。</p>
<h2 id="c">C</h2>
<p>后面两题似乎都没有被很好的思考过了，我既然得出了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 以上一定没解的结论，看这数据范围，总应该想到是状压的，结果居然搞了半天还是写暴力。</p>
<p>其实状压的思路也挺好想的，搞可行性 dp，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>S</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[S][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示当前状态能否合成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>, 然后转移挺显然的，<code>bitset</code> 优化也应该容易想到。</p>
<p>然后主要的问题在于输出方案。判断当前这个是否可选还是有一些细节的。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;bitset&gt;
int n, m, C[55][55];
std::bitset&lt;100005&gt; f[(1 &lt;&lt; 15)+5];
int count(int x) { return (x != 0) ? (count(x &amp; (x-1)) + 1) : 0; }
int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    if(n &gt;= 15 || m &lt; (1 &lt;&lt; n)) return puts(&quot;No Answer&quot;), 0;
    for(int i = 0; i &lt;= n; i++) {
        C[i][0] = C[i][i] = 1;
        for(int j = 1; j &lt; i; j++) C[i][j] = C[i-1][j-1] + C[i-1][j];
    }
    m -= (1 &lt;&lt; n);
    f[0][0] = 1;
    for(int i = 0; i &lt; (1 &lt;&lt; (n+1)); i++)
        for(int j = 0; j &lt;= n; j++)
            if(~i &amp; (1 &lt;&lt; j)) f[i | (1 &lt;&lt; j)] |= f[i] &lt;&lt; (j * C[n][count(i)]);
    if(f[(1 &lt;&lt; (n+1)) - 1][m]) {
        int now = (1 &lt;&lt; (n+1)) - 1, v = m;
        while(now) {
            for(int i = n; i &gt;= 0; --i)
                if(now &amp; 1 &lt;&lt; i &amp;&amp; v - i * C[n][count(now ^ 1 &lt;&lt; i)] &gt;= 0 &amp;&amp;
                    f[now ^ 1 &lt;&lt; i][v - i * C[n][count(now ^ 1 &lt;&lt; i)]]) {
                    v -= i * C[n][count(now ^= 1 &lt;&lt; i)];
                    printf(&quot;%d%c&quot;, i+1, (now == 0) ? '\n' : ' ');
                    break;
                }
        }
    } else puts(&quot;No Answer&quot;);
    return 0;
}

</code></pre>
<h2 id="d">D</h2>
<p><strong>我忏悔</strong>：在这做这题时，我背弃了正气和信仰。</p>
<p>非常浮躁地搞了一个错的贪心，然后就去看了原题别人的代码，而甚至没有自己好好的思考过做法以及其时间复杂度。</p>
<p>刚刚写过那篇文章，写过那段《无言》，这样又如何去面对内心的逼问？</p>
<p>下不为例。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #717 (div.2) 游记]]></title>
        <id>https://acfboy.pw/cf1516/</id>
        <link href="https://acfboy.pw/cf1516/">
        </link>
        <updated>2021-04-22T08:05:34.000Z</updated>
        <summary type="html"><![CDATA[<p>两个“人生第一次”——上蓝，变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="blue"><mtext mathvariant="sans-serif">Acfboy</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{blue}\textsf{Acfboy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text" style="color:blue;"><span class="mord textsf" style="color:blue;">Acfboy</span></span></span></span></span> 了！以及第一次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mtext mathvariant="sans-serif">FST</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\textsf{FST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text" style="color:red;"><span class="mord textsf" style="color:red;">FST</span></span></span></span></span> 了。</p>
<p>不过比赛状态真的是不好，第一题居然要交三次才过，第二题还 FST。但还是开心地庆祝上蓝！</p>
]]></summary>
        <content type="html"><![CDATA[<p>两个“人生第一次”——上蓝，变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="blue"><mtext mathvariant="sans-serif">Acfboy</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{blue}\textsf{Acfboy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text" style="color:blue;"><span class="mord textsf" style="color:blue;">Acfboy</span></span></span></span></span> 了！以及第一次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mtext mathvariant="sans-serif">FST</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\textsf{FST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text" style="color:red;"><span class="mord textsf" style="color:red;">FST</span></span></span></span></span> 了。</p>
<p>不过比赛状态真的是不好，第一题居然要交三次才过，第二题还 FST。但还是开心地庆祝上蓝！</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://www.hualigs.cn/image/60811d06c1a67.jpg" alt="" loading="lazy"></figure>
<h2 id="a">A</h2>
<p>英语不好有大问题， &quot;two different elements&quot; 指的是下标不同而不是那个数字不同，影响了一定的做题速度。</p>
<p>不过自己没有想清楚也是一个大的原因，没有考虑到根本不能减的情况。</p>
<p>开局不利，就比较慌。</p>
<h2 id="b">B</h2>
<blockquote>
<p>把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数分成至少两段，使每一段异或和相同。</p>
</blockquote>
<p>pretest 有点水啊。不过确实得怪自己没有考虑清楚。</p>
<p>思路是枚举第一段，然后后面验证能不能行。</p>
<p>验证时如果行的就直接断开就会遇到各种问题。一开始没有想到异或和本来就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的问题，顺利 Wrong Answer on pretest 2。又没有注意到如果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 可以和前面并上，顺利 FST。 然后没注意到一段为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 也可以和前面并上，又没有注意到如果前面只是一段就不能并过去，因为至少要两段。</p>
<p>最后居然交了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 发才过！</p>
<p>把代码和提交记录放上来作 警示/纪念 吧。</p>
<figure data-type="image" tabindex="2"><img src="https://www.hualigs.cn/image/608120b511c5d.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
const int N = 2005;
int T, n, a[N];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
        int fi = 0, ne = 0;
        bool flag = 0;
        for(int i = 1; i &lt; n; i++) {
            fi ^= a[i];
            ne = 0;
            bool twt = 0, did = 0;
            for(int j = i+1; j &lt;= n; j++) {
                ne ^= a[j];
                if(ne == fi || ne == 0 &amp;&amp; did) ne = 0, twt = 1, did = 1;
                else twt = 0;
                // printf(&quot;*%d %d\n&quot;, ne, twt);
            }
            if(twt) { flag = 1; /*printf(&quot;%d %d %d\n&quot;, i, fi, ne);*/ break;}
        }
        if(flag) puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="c">C</h2>
<p>好题！</p>
<blockquote>
<p>至少要删去几个数，使数组不能被分成和相等的两份。</p>
</blockquote>
<p>至于判断一个数组，那么很好做到，直接背包一遍就可以了。</p>
<p>那么怎么去掉呢？显然若有奇数直接去掉好了，可是没有又怎么去掉？枚举每一个的话万一还需要去掉一个呢？</p>
<p>找一些数据玩一玩，发现最多去掉一个就可以了。证明使用第二类数学归纳法。</p>
<ol>
<li>若存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i = 2^0x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是奇数)， 那么把它去掉肯定可以，所以若要去掉两个的，肯定不存在这样的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i = 2^kx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>) 都不存在，那么去掉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i = 2^mx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span> 的肯定可以，因为大家都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span> 的倍数，而去掉这个再除以二后就不能被 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span> 整除了，所以不能存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i = 2^mx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span></li>
<li>所有的数都不能存在。</li>
</ol>
<p>这样就证明了一堆数去掉一个肯定是可以的。</p>
<p>代码很好写，反而这题是我这场比赛最顺利的一道。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
const int N = 105;
int n, a[N], f[200005], v;
int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), v += a[i];
    for(int i = 1; i &lt;= n; i++)
        for(int j = v; j &gt;= a[i]; j--)
            f[j] = std::max(f[j], f[j-a[i]] + a[i]);
    if(v % 2 == 1 || f[v/2] != v/2) {
        puts(&quot;0&quot;);
        return 0;
    }
    for(int i = 1; i &lt;= n; i++) 
        if((v-a[i]) % 2 == 1 || f[(v-a[i])/2] != (v-a[i])/2) {
            printf(&quot;1\n%d&quot;, i);
            return 0;
        }
    return 0;
}
</code></pre>
<h2 id="d">D</h2>
<p>赛场上想着倍增但没想出个方案来，本来若积小一点就可以用线段树大力维护的，但这样的数据范围要么暴力出奇迹，高精去(用 <code>Python</code> 写线段树？)，要么就另寻他法了。</p>
<p>结果题解真的是倍增。</p>
<p>先处理出每一个开始的断点是在哪儿，然后倍增跳过几段而不是跳过几个数字就好了。</p>
<p>感觉难点在于如何预处理那个第一个断点的问题。</p>
<p>可以先预处理存下每个数的质因数，然后从后往前每一个的质因子的下一个有的取个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span> 就好了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
const int N = 100005;
int n, q, a[N], f[N][25], ans, l, r, next[N];
std::vector&lt;int&gt; p[N];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
	for(int i = 2; i &lt; N; i++) 
		if(p[i].empty()) {
			next[i] = n+1;
			for(int j = 1; i*j &lt; N; j++)
				p[i*j].push_back(i);
		}
		
	f[n+1][0] = n+1;
	for(int i = n; i &gt;= 1; i--) {
		f[i][0] = f[i+1][0];
		for(int j = 0; j &lt; (signed)p[a[i]].size(); j++) {
			f[i][0] = std::min(f[i][0], next[p[a[i]][j]]);
			next[p[a[i]][j]] = i;
		}
	}
	for(int j = 1; j &lt;= 20; j++)
		for(int i = 1; i &lt;= n+1; i++)
			f[i][j] = f[f[i][j-1]][j-1];
	while(q--) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		ans = 0;
		for(int i = 19; i &gt;= 0; i--)
			if(f[l][i] &lt;= r) {
				ans += (1 &lt;&lt; i);
				l = f[l][i];
			} 
		printf(&quot;%d\n&quot;, ans+1);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [BalticOI 2020 Day2] 村庄]]></title>
        <id>https://acfboy.pw/20210421/</id>
        <link href="https://acfboy.pw/20210421/">
        </link>
        <updated>2021-04-22T06:43:52.000Z</updated>
        <summary type="html"><![CDATA[<p><s>《2021.4.21 校内模拟赛游记》</s></p>
<p>模拟赛的一题——我整场模拟赛都用来做这题了，所以没有游记了，只剩下一篇题解了。</p>
]]></summary>
        <content type="html"><![CDATA[<p><s>《2021.4.21 校内模拟赛游记》</s></p>
<p>模拟赛的一题——我整场模拟赛都用来做这题了，所以没有游记了，只剩下一篇题解了。</p>
<!-- more -->
<blockquote>
<p>有一棵树，要让每一个点移动到另一个点，求移动距离和的最大值和最小值。</p>
</blockquote>
<p>先考虑最小值，这个移动的下届非常好确定，因为由题目可以知道，每一个点最少要移动一次，所以考虑一下链的情况，就是偶数个的话取到下界，不然一个就要多移动一次。然后考虑菊花图，同样很好确定大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的菊花图的最小答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，最大值同样也是这个。</p>
<p>然后就简单了，就把书分成若干条链和菊花图就可以了，一个点儿子多那是没办法，得菊花，不然肯定是变成链的好。至于怎么剖图为链，其实不需要把整条链给拿出来，因为反正我们都是两两配的，先两两配着，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号点多出来了后面再修复一下就可以了。</p>
<p>说着好像很简单的样子，但考场上推了半天，草稿纸上处理了一堆的问题，挺长的时间才想到，赛后口胡和赛场上去独立完成还是有很大的距离的。</p>
<p>那么最大的怎么做呢？赛场上同样考虑了链上的情况，很容易发现把链劈成两半，然后让一边的一定得跨越到另一边就可以了，于是猜想在树上就按照中心或重心之类的分成两半，然后让一边的子树跨到另一边去就可以了。</p>
<p>但是比赛的时候我不知道怎样去确定上界，所以也不清楚到底是中心还是重心，对于多余两个的子树又怎么去处理。</p>
<p>赛后发现其实还是很容易证明的，考虑每一条边最多经过多少次。最多是两边的子树较小的那个的节点个数次乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, 因为小的那个子树里的点全部跑出来，外面最多有这些点跑进去。</p>
<p>那么这个上界能否取到呢？怎么样才会取到呢？其实只要能保证每一条边都能取到必须得是这条边一个点相连的所有子树的和必须要比另一个点的子树要大，不然的话就没有办法确保每一个子树中的点都跑到了和它不相同的子树，也就没有办法确保边被跑满。那么就是要取重心了。</p>
<p>具体的做法也是比较的巧妙的，因为反正没有一个子树大小会超过整个树的一半，那么把它的编号加一半就肯定在另外一棵子树里面了。</p>
<p>代码实现得比较啰嗦，因为把链和菊花图分开存了，为了修正，需要记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号点儿子所在的 菊花图/链 的 下标/迭代器。后来发现其实可以一起处理的（因为都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 啊），但比较懒，就没有改。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#define int long long
const int N = 100005;
typedef std::vector&lt;int&gt; twt;
typedef std::vector&lt;twt&gt;::iterator IT;
twt g[N];
IT t;
std::vector&lt;twt&gt; fl, tr;
int min, ans[N], n, x, y, t2, t3, t4, max, ans2[N], dfn[N], num, size[N];
bool flag[N];
void dfs(int u, int fa) {
	twt tmp;
	dfn[++num] = u;
	size[u] = 1;
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		dfs(v, u);
		size[u] += size[v];
		if(flag[v] == 0) tmp.push_back(v);
	}
	if(tmp.size() == 1 || tmp.size() == 2) {
		tmp.push_back(u);
		tr.push_back(tmp);
		flag[u] = 1;
		if(fa == 1) {
			if(tmp.size() == 2) t2 = tr.size()-1;
			else t = --tr.end(), t3 = tr.size()-1;
		}
	}
	else if(tmp.size() &gt; 2) {
		tmp.push_back(u);
		fl.push_back(tmp);
		flag[u] = 1;
		if(fa == 1) t4 = fl.size()-1;
	}
	max += 2*std::min(size[u], n - size[u]);
}
void fix() {
	if(t2 != 0) {
		tr[t2].push_back(1);
		return;
	}
	if(t3 != 0) {
		twt tmp;
		for(int i = 0; i &lt; (signed)tr[t3].size(); i++) tmp.push_back(tr[t3][i]);
		tmp.push_back(1);
		tr.erase(t);
		fl.push_back(tmp);
		return;
	}
	fl[t4].push_back(1);
}
signed main() {
//	freopen(&quot;village.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;village.out&quot;, &quot;w&quot;, stdout);
	
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt; n; i++) 
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y), 
		g[x].push_back(y), g[y].push_back(x);
	dfs(1, 0); 
	for(int i = 1; i &lt;= n; i++) ans2[dfn[i]] = dfn[(i+n/2-1)%n+1];
	if(flag[1] == 0) fix();
	for(int i = 0; i &lt; (signed)tr.size(); i++) 
		if(tr[i].size() == 3) {
			tr[i].push_back(tr[i][0]);
			for(int j = 0; j &lt; (signed)tr[i].size()-1; j++)
				ans[tr[i][j]] = tr[i][j+1];
			min += 4;
		}
		else {
			ans[tr[i][0]] = tr[i][1], ans[tr[i][1]] = tr[i][0];
			min += 2;
		}
	for(int i = 0; i &lt; (signed)fl.size(); i++) {
		min += 2 * ((signed)fl[i].size()-1);
		ans[fl[i][0]] = fl[i][1], ans[fl[i][1]] = fl[i][0];
		fl[i].push_back(fl[i][2]);
		for(int j = 2; j &lt; (signed)fl[i].size()-1; j++) ans[fl[i][j]] = fl[i][j+1];
	}
	printf(&quot;%lld %lld\n&quot;, min, max);
	for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]);
	puts(&quot;&quot;);
	for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans2[i]);
	return 0;
}
</code></pre>
<p>感觉思维难度其实挺大的，而模拟赛搬题人却说思维难度不高，NOIP <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span></span></span></span>……</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[梅 开 三 度]]></title>
        <id>https://acfboy.pw/mei-kai-san-du/</id>
        <link href="https://acfboy.pw/mei-kai-san-du/">
        </link>
        <updated>2021-04-22T04:53:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="离开">离开</h3>
<p>2021 年的元旦刚过，我居然这么就不经意间参加了一次考试，又得到了意料之外的录取的消息，于是三号下午，我便知道了那是我在 sy 的最后一天。</p>
<p>但那时肯定是兴奋而期待的，对未来充满了憧憬，虽有一点点淡淡的伤感，但肯定不会认真的思考对过去的告别，对所喜欢的人们作出自己无悔的告别。</p>
<p>所以我所作出的唯一的告别就是得到正式的通知以后在社会课上手写的一封告别信，用了 “萨曼·威斯高德·霍欧维斯·肖特·安特肖斯·艾斯·阿塞恩特·金神叹” 的自称和“一个焦点是木桩，一个焦点在远方”的典故。本想着在英文部分留下什么彩蛋，最终还是什么都没有留，只是写上了我这名字糟糕的翻译——不过，将标题译作“You are beautiful”。晚上等到几乎最后一个走，将信放在校牌里对着她的桌子。</p>
<p>甚至没有说出一声的再见。</p>
<p>但她在那天晚自修说的话我记得很清晰，至今还是——可能一直到我退役都会是——我洛谷个人主页唯一的一句话。</p>
<blockquote>
<p>翘翘以前很可爱，现在不可爱了。</p>
</blockquote>
<p>罗翔讲《会饮篇》，讲得很好，柏拉图写得很好，苏格拉底讲得也很好。爱是要追求自己想要的美好，而肉体上的幸福只是追求灵魂高贵的阶梯。最终还是向往他人所拥有的美好，向往灵魂的高贵。</p>
<p>罗翔老师的这一个多小时的直播确实起到了很好的作用，让我更加理性地去看待这个事情。她很自律，能为自己想要的而奋斗；也很阳光，充满纯洁和正气。这确实是我所向往而不曾拥有过的美好。</p>
<p>但我确实自知不配，所以什么也没有说过，从来就没有说过什么。</p>
<p>我就什么都没有说，就这么走了，但一个一个的脚印又确实印在操场上，印在时间里，印在人心里；为了改变现状做的微不足道的努力也同样弥漫在那段时光中。</p>
<h3 id="无言">无言</h3>
<p>我居然会很想她，准确的来讲，似乎走了之后，就想两个人，还有一个是 wc。</p>
<p>我本来期盼着 wc 能考上来的，我们还可以一起奔跑在晚霞中，但他没能来，无论只是恰好的失误还是什么其它的问题，这都一锤定音了，我将离开熟悉的 911,独自踏上新的旅程。</p>
<p>我怀念在 sy 大声朗读的日子，所以尽管没有早读课，仍然拿着一本书，或是经典诵读，或是必修上册，和翘翘响亮的声音，相约在清晨；我同样仍然喜爱身体稳定运行的感觉，所以继续奔跑在这儿的操场。但虽然脑中仍能想起“翘翘加油”的声音，仍能想起“不合时宜了”的忠告，抓着的灌水区似乎有着要被扯走的力度，却仍然没有办法专心地去练习，去静下心来思考。</p>
<p>911 的氛围真的好的多，虽然同样有吵闹而浮躁的时候，但同样有着充满理想而奋斗的人们。</p>
<p>sxyz 的机房环境，至少我所在的地方，似乎却不大对得起它强省强校的称号。但当自己深陷在其中的时候，却不是那么好拒绝的。不是怀着一点点的热血、吟着华丽的篇章就能做到的。</p>
<p>于是，翘翘以前很可爱，现在不可爱了。最可怕的其实是面对这样内心深处的声音而又无力去改变，它一点点地剥夺着人对美好的念想。</p>
<p>罗翔在《请回答2020》中谈到人为什么害怕孤独中谈得很彻底，或者说叔本华对这个问题认识得彻底，概括得也凝练。因为当你静下来的时候，会面对来自自己内心深处的声音，你想成为什么样的人，你为之奋斗了吗。但我没法去直面这样的声音，所以只能企图用吵闹和浮躁将其掩盖，或许所谓“娱乐至死”的原因也正是在此。</p>
<p>记得有一次我对她说“聒噪”——当然是水浒传里的聒噪，打扰了之类的意思——她说“我确实很聒噪”。或许每个人都会遇上这样的困境，但无论如何，在痛苦中沉沦，放弃自己的理想不是我想要的，我希望能为自己所想要的而奋斗，尽管可能无法坦然面对内心所有的逼问，也许没有办法完全脱掉浮躁的外衣，但总比待在此处更加接近幸福。</p>
<p>我时常想她。怀疑这只是青春的萌动是不无道理，但我确实向往着能常怀正气，能为自己所爱的事业而奋斗。</p>
<p>对于那首“梦游天姥吟长恨歌”，我至今还是不明白她最初的意图是什么，不过我也将它看作是她给我的劝诫。实验操作考试，英语口语考试，我几乎没有和她说过话，这是无言。但我更常面对的是，对内心深处逼问的无言。</p>
<h3 id="上路">上路</h3>
<p>今天体育中考了，我迟到了以为要上楼拿准考证时在楼梯上碰到她，她主动的叫了一声“翘翘”。等到真正到考场后似乎有很多的时间，至少可以问个“吟长恨歌”的事，但我却不敢去说什么。然后就只是在操场入口看见过一眼。但等我跑的时候却见她在那弯道处喊加油。</p>
<p>前两次的考试中的无言让我觉得她对我很冷淡，但那个瞬间，我发觉其实冷淡的是我，我不敢主动叫她，也从未为她加油呐喊过。或许是我不敢面对，因为我在努力去为自己想要的而奋斗上取得了彻底的失败。我们两个的关系自然是没有继续的可能，我也不配哇。</p>
<p>但追求灵魂的高贵，追求她所拥有的美好，何必局限在这点上。</p>
<p>我所能做的，当然只有，也确实应该只有，怀着追求自身所想要的美好的梦想，和他人给予的鼓励，独自一人上路了。人生是没有人能陪你到最后的旅程，我长跑中也常体验过这样的感觉，我来这里之后，几乎不再有人和我跑过全程或者大多数的旅程了。</p>
<p>生命中的很多人，在你前行的路上陪过你一段，给你留下了美好的回忆，也足够了。他/她 的精神的品质，完全可以留在你的心里，陪你去走更远。你脑中留下的，也是 他/她 最好的年纪，最好的样子。</p>
<p>在“梦游天姥”之前，她还给过填过一行字，那是现代汉语，“心怀热爱，奔赴山海”，我记得我好像填成的是“爱怀热心，奔山赴海”，<s>我怎么语感如此糟糕</s>, 其实又何尝不可以呢？我所爱的，所向往的，也确实是怀着一颗少年炽热的心，去迎接生活中的挑战。</p>
<p>我非常感谢并想念那些曾经陪伴我走过一段的人（怎么突然就有 wzf 的腔调了），但不得不告别，独自一人踏上另一段旅程了。但他们其实都陪在我身边，不是吗？我跑得累的时候，仿佛一转头，就是那几个陪跑的人，仿佛下一个弯道，就有着“翘翘加油”的呼声。和一道题奋战的时候一抬头，他们何尝不在。</p>
<h3 id="最后">最后</h3>
<p>不知道她是怎么看待我的，我感觉我的什么心思她清楚的很，感觉总是她给我疯狂暗示然后我又啥也不懂，憨憨的，想问个啥也是毫无计划<s>一头雾水两眼抓瞎模式</s>。</p>
<p>还记得有一次跑完五千她说了什么“同化”“异化”，我没明白，再追问也不说了，现在也不知道什么意思，最近看了一本书结果感觉这居然牵扯到黑格尔的哲学？？？当然也有可能不是同个东西。</p>
<p>好像我对她是一无所知的。</p>
<p>然后，大概就得向我初中时代很多很熟悉但又一无所知的人告别了，以后，各自保重。</p>
<p>而 sxyz 又何曾没有为自己的梦想默默奋斗的人呢，不可被一些 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mo>×</mo></mrow><annotation encoding="application/x-tex">\times \times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">×</span></span></span></span> 所诓骗，要自己去看地底下。</p>
<p>现在忽然又想起刚刚读完的王小波《三十而立》，则似乎满眼都是对自我的坚持了。</p>
<blockquote>
<p>内心坚持着梅的圣洁高雅，面对逆境坚持梅的傲雪自强，对待生活时刻保持梅的清雅俊逸，此之谓梅开三度。</p>
</blockquote>
<p>翘翘加油。</p>
<p><s>花那么多时间写下这些似乎有些不合时宜</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC035C] Skolem XOR Tree]]></title>
        <id>https://acfboy.pw/agc035c/</id>
        <link href="https://acfboy.pw/agc035c/">
        </link>
        <updated>2021-04-21T00:09:39.000Z</updated>
        <summary type="html"><![CDATA[<p>止步于一个死胡同里了，没能换一种思路出正解。感觉做这种构造题的方向也没有搞对。</p>
]]></summary>
        <content type="html"><![CDATA[<p>止步于一个死胡同里了，没能换一种思路出正解。感觉做这种构造题的方向也没有搞对。</p>
<!-- more -->
<blockquote>
<p>构造一颗大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span> 的树，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的权值都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>, 使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span></span></span></span> 路径上的异或和都为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 或断言这不可能。</p>
</blockquote>
<p>开始的时候去研究了一下连续数异或的性质，发现连续四个一组异或起来是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，如下。</p>
<pre><code>00000
00001
00010
00011
---
00100
00101
00110
00111
---
01000
01001
01010
01011
---
01100
01101
01110
01111
</code></pre>
<p>这一点的正确性挺显然的，于是我们对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn><mi>k</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n = 4k+3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的就有了一种构造方案，即把三个一组，后面每四个一组进行构造，用笔模拟一下发现四个四个的构造都是独立且成立的，那么随便选一个点连起来就可以了。</p>
<p>那么其它情况呢？能断言其不成立吗？我就束手无策了。</p>
<p>其实一条路走不通，得确定它确实走不通，然后换条路试试，而不可放弃啊。</p>
<p>其实做这种构造题应该先确定一个绝对没有解的条件，再去尝试构造剩下的。</p>
<p>那么什么事绝对没有解的呢？<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的幂次的时候肯定不行，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">n&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 中间在这最高位上肯定不会有了。</p>
<p>那么考虑剩下的怎么去构造，其实有一个很“显然”的性质，那就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是偶数时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn><mo>⊕</mo><mn>1</mn><mo>=</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x+1 \oplus 1 = x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>， 是奇数时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⊕</mo><mn>1</mn><mo>=</mo><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x \oplus 1 = x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 那么我们就可以用下图构造了。</p>
<figure data-type="image" tabindex="1"><img src="https://www.hualigs.cn/image/607f6b8455e90.jpg" alt="" loading="lazy"></figure>
<p>把每一组偶数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 都向上面连接就可以了。</p>
<p>至于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 直接接在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 下面就好了，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>⊕</mo><mn>3</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 \oplus 3 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。还有就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是偶数时会多出来，再想想怎么修补。</p>
<p>可发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>→</mo><mtext>lowbit</mtext><mo>(</mo><mi>n</mi><mo>)</mo><mo>→</mo><mn>1</mn><mo>→</mo><mi>n</mi><mo>−</mo><mtext>lowbit</mtext><mo>(</mo><mi>n</mi><mo>)</mo><mo>+</mo><mn>1</mn><mo>→</mo><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">n \rightarrow \text{lowbit}(n) \rightarrow 1 \rightarrow n - \text{lowbit}(n)+1 \rightarrow n&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lowbit</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lowbit</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 满足条件，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>lowbit</mtext><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{lowbit}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lowbit</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 是偶的，所以这样的路一定存在。</p>
<p>代码就不放了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2012]守卫]]></title>
        <id>https://acfboy.pw/apio2012shou-wei/</id>
        <link href="https://acfboy.pw/apio2012shou-wei/">
        </link>
        <updated>2021-04-20T11:01:41.000Z</updated>
        <summary type="html"><![CDATA[<p>一道从开始就被我想歪的题目，以至于写了一天最后发现根本就是错误的算法，只好照题解写去了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一道从开始就被我想歪的题目，以至于写了一天最后发现根本就是错误的算法，只好照题解写去了。</p>
<!-- more -->
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 的区间内有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个标记在整数上，给出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 段区间内有/没有标记，输出一定有标记的数字。</p>
</blockquote>
<p>看完题我就直接给出了一堆“显然”的结论：</p>
<ol>
<li>去掉没有的，若有的区间长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 那这个就肯定是的了。</li>
<li>把肯定是的去掉，当且仅当剩下还有的标记数和现在有覆盖标记的数字数一样的时候有一定有标记的数字，且一定是全都是。</li>
</ol>
<p>看上去是不是挺有道理？于是我就设计了一个用 <code>std::set</code> 的算法，用 <code>(twt){st, len}</code> 表示从 <code>st</code> 开始长度 <code>len</code> 的有覆盖，维护一个可能有的区间，和一个一定没有到区间，然后用一定没有的在有的区间内除去，然后判一下前面两条就行了。合并区间的时候注意有标记的区间刚刚好相接是不能接上的，因为要注意一号判断。</p>
<p>似乎好有道理，然后我就写、调了俩小时，最后获得了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 分的优异成绩。</p>
<p>其实反例很显然：</p>
<pre><code class="language-cpp">3 1 3
1 1 1
1 2 1
1 3 1
</code></pre>
<p>这样我认为是无法确定的，其实第一个明显是可以确定的。解决这个问题可不是仅仅把开始时长度就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的判掉那么简单。</p>
<p>比如这组反例：</p>
<pre><code class="language-cpp">5 1 3
2 3 1
1 5 1
3 3 0
</code></pre>
<p>把前两段并起来后就损失了它们单独的信息了！</p>
<p>所以前面的断言根本就是错的。浪费了我许多的时间。<strong>在开始写代码前一定要想清楚，充分考虑算法的正确性是否成立。</strong></p>
<p>那么现在来讲正确的做法吧。</p>
<p>正确做法同样维护了可能由标记的区间并从中去掉了一定没有标记的区间，那它是如何处理在合并中的信息损失呢？</p>
<p>其实，正确做法根本不需要这个信息，<s>因为它不依赖于我的断言</s>。</p>
<p>想法很简单，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 记录前面到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 段所需的最少标记数量，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">g_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 记录从后面开始的。然后枚举每一个点就强制它不选，选它左边一个，再看下前后所需的会不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 就好了。</p>
<p>当然细节还是要处理的。</p>
<p>题解里处理合并的方式比我的 <code>set</code> 好多了，既快（没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>） 又好写 （不用处理迭代器删除的问题），用差分把现在不是肯定没有的点抓出来重新编号，用新编号表示线段的端点。</p>
<p>处理合并可以将一个端点排序后使用单调栈处理合并。至于找左右的线段端点？既然有序，直接二分就好了。</p>
<p>代码实现感觉也一些的难度。</p>
<pre><code class="language-cpp">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m);
	for(int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d%d&quot;, &amp;a[i].l, &amp;a[i].r, &amp;a[i].f);
		if(a[i].f == 0) ++b[a[i].l], --b[a[i].r+1];
	}
	int now = 0, cnt = 0;
	for(int i = 1; i &lt;= n; i++) {
		now += b[i];
		if(now == 0) L[i] = R[i] = ++cnt, be[cnt] = i;
	}
	if(cnt == k) {
		for(int i = 1; i &lt;= cnt; i++) printf(&quot;%d\n&quot;, be[i]);
		return 0;
	}
</code></pre>
<p>先是重新编号的过程，如果发现这些点恰好就是需要的，那么直接输出就可以了。</p>
<p>同时标记出了一个新的点左右最靠近的一个端点。</p>
<pre><code class="language-cpp">	L[n+1] = n+1;
	for(int i = 1; i &lt;= n; i++) 
		if(R[i] == 0) R[i] = R[i-1];
	for(int i = n; i &gt;= 1; i--) 
		if(L[i] == 0) L[i] = L[i+1];
	cnt = 0;
	for(int i = 1; i &lt;= m; i++) {
		if(a[i].f == 0) continue;
		if(L[a[i].l] &lt;= R[a[i].r]) a[++cnt].l = L[a[i].l], a[cnt].r = R[a[i].r];
	}
	std::sort(a+1, a+cnt+1);
</code></pre>
<p>然后更新 <code>a</code> 的编号并进行排序。</p>
<p>以下重新使用了 <code>L</code> 和 <code>R</code> 作为栈，注意这里的合并不是我假做法里的合并，而是把完全覆盖的给并掉了。还求出了 <code>f</code> 和 <code>g</code>。</p>
<pre><code>	int top = 0;
	for(int i = 1; i &lt;= cnt; i++) {
		while(top != 0 &amp;&amp; a[i].l &gt;= L[top] &amp;&amp; a[i].r &lt;= R[top]) top--;
		L[++top] = a[i].l, R[top] = a[i].r;
	}
	int l = n+1, r = 0;
	for(int i = 1; i &lt;= top; i++) {	
		if (L[i] &gt; r) f[i] = f[i-1] + 1, r = R[i];
		else f[i] = f[i-1];
	}
	for(int i = top; i &gt;= 1; i--) {
		if (R[i] &lt; l) g[i] = g[i+1] + 1, l = L[i];
		else g[i] = g[i+1];
	}
</code></pre>
<p>最后是关键的判断环节。</p>
<p>这里还需要说明一下，最后栈中的编号是剩下线段的编号，我们每次只判断了最右边一个是否是一定要有的，是因为这样子显然是最优的，因为放在这个位置右边也可能会利用到，而因为每一段覆盖只需要一个就可以了，其它地方判断出来是不能确定的，因为可以放到线段最右边的位置可能更优。</p>
<pre><code class="language-cpp">	bool flag = 0;
	for(int i = 1; i &lt;= top; i++) {
		if(f[i] == f[i-1]) continue;
		if (L[i] == R[i]) {
			printf(&quot;%d\n&quot;, be[R[i]]);
			flag = 1; 
			continue;
		}
		int l = 1, r = i - 1, x = 0, y = top + 1;
		while (l &lt;= r) {				 
			int mid = l + ((r - l) &gt;&gt; 1);
			if (R[mid] &lt; R[i] - 1) x = mid, l = mid + 1;
			else r = mid - 1;
		}
		l = i + 1, r = top;
		while (l &lt;= r) {
			int mid = l + ((r - l) &gt;&gt; 1);
			if (L[mid] &gt; R[i] - 1) y = mid, r = mid - 1;
			else l = mid + 1;
		}
		if (f[x] + g[y] + 1 &gt; k) {
			printf(&quot;%d\n&quot;, be[R[i]]);
			flag = 1;
		}
	}
	if(flag == 0) puts(&quot;-1&quot;);
}
</code></pre>
]]></content>
    </entry>
</feed>