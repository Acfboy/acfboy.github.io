<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的博客</title>
    <updated>2021-05-25T12:40:15.155Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的博客</rights>
    <entry>
        <title type="html"><![CDATA[题解 由乃喜欢二次离线根号黑科技]]></title>
        <id>https://acfboy.pw/shenmeguimodui/</id>
        <link href="https://acfboy.pw/shenmeguimodui/">
        </link>
        <updated>2021-05-25T12:10:41.000Z</updated>
        <summary type="html"><![CDATA[<p>题目 <em>Yuno loves sqrt technology II</em> 中的二是不是有双关的意思？</p>
<p>这是一道二次离线的黑科技版题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>题目 <em>Yuno loves sqrt technology II</em> 中的二是不是有双关的意思？</p>
<p>这是一道二次离线的黑科技版题。</p>
<!-- more -->
<p>感觉现在去写这种黑科技意义不大，因为在做（卡）这题的时候不能通过自己的思考体会到算法的精妙，不过体验一下黑题也是不错的。<s>这句话中的“卡”其实也有双关的意思</s></p>
<p>另外，这是 Ynoi 模拟赛，所以老板其实没有完成第一道 Ynoi（</p>
<h2 id="二次离线基础思想">二次离线基础思想</h2>
<p>有的时候用离线后用莫队做移动一个端点消耗的时间不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的，所以总复杂度除了一个根号还得乘上那个操作的复杂度，没有办法接受。</p>
<p>所以可以把“移动”这一个操作再离线一遍，放到后面再一起做，使移动的复杂度均摊 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="具体实现">具体实现</h2>
<blockquote>
<p>求区间逆序对数。</p>
</blockquote>
<p>首先有个简单的莫队做法，将询问离线，然后每次莫队移动的时候用个树状数组统计 比它大/比它小 的即变化量。时间复杂度大概是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msqrt><mi>n</mi></msqrt><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \sqrt n \log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>分开仔细考虑一下左右指针移动时的变化量。</p>
<ol>
<li>左指针向左移动：答案会增加当前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间中比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{l-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 小的的个数。</li>
<li>左指针向右移动：答案会减少第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l+1, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 个中比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 小的的个数。</li>
<li>右指针向左： 减少第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 个比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 大的。</li>
<li>右指针向右：增加第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中比 个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{r+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 大的。</li>
</ol>
<p>那么就记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 个中比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">a_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 大的， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(x, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 是前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个中比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">a_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 小的。如果能快速处理这些东西，就可以快速计算上面的内容了。</p>
<p>把四种操作的增量重新写一遍。</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>g</mi><mo>(</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mo>−</mo><mi>g</mi><mo>(</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">+g(l-1, r) - g(l-1, l-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>g</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mo>+</mo><mi>g</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">-g(l, r) + g(l, l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">-f(r, r-1) + f(r, l-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mo>−</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">+f(r+1, r) - f(r+1, l-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>发现其中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(x, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x, x-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 可以方便地用树状数组求出来，然后考虑把剩下的离线下来处理。</p>
<p>可以从头到尾循环一遍，每次将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 加入到某个数据结构中。可以发现照这个顺序，处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 移动的会在前面 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个都处理出来的时候就得到答案，同理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 移动要等到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 出来的时候才得到答案，所以可以用 <code>vector</code> 将这些询问挂到对应的端点上，然后在循环的时候加（减）上相应的答案就可以了。</p>
<p>然后想想这个数据结构得是个啥。它需要支持 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 查询一个值域内数的个数（不然你白离线了）， 但修改可以在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span> 或者根号的时间内。</p>
<p>那么就上值域分块吧。</p>
<p>最后要注意我们记录的只是变化量，要做一个前缀和才是答案。</p>
<h2 id="最后">最后</h2>
<p>代码有点长，点击展开看。</p>
<details>
<summary> Code </summary>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define re register
const int N = 100005, M = 350;
int a[N], c[N], l[M], r[M], s[M], sv[M][M], bv[N], blo[N], t[N], 
	n, m, size, B, ls[N], gr[N];
long long ans[N];
struct twt { int l, r, c, op, id; };
std::vector&lt;twt&gt; v[N];
struct dwd {
	int l, r, id; long long ans;
	bool operator &lt; (dwd b) const {
		return (blo[l] == blo[b.l]) ? ((blo[l]&amp;1) ? (r &lt; b.r) : (r &gt; b.r)) : (blo[l] &lt; blo[b.l]);
	}
} q[N];
inline int ask(int x) { re int an = 0; for(re int i = x; i &gt;= 1; i -= i&amp;-i) an += t[i]; return an; }
inline void add(int x, int y) { for(re int i = x; i &lt;= n; i += i &amp;-i) t[i] += y; }
inline void update(int x) {
	for(re int i = x-l[bv[x]], *k = sv[bv[x]]; i &lt; size; i++) k[i] ++;
	for(re int i = bv[x]; i &lt;= bv[n]; i++) ++s[i];
}
inline int query(int x) { return s[bv[x]-1] + sv[bv[x]][x-l[bv[x]]];}
int main() {
	cin &gt;&gt; n &gt;&gt; m;
	for(re int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], ls[i] = a[i];
	std::sort(ls+1, ls+n+1);
	for(re int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(ls+1, ls+n+1, a[i]) - ls;
	for(re int i = 1; i &lt;= n; i++) {
		ls[i] = ask(a[i] - 1);
		gr[i] = ask(n) - ask(a[i]);
		add(a[i], 1);
	}
	
	size = sqrt(n);
	for(re int i = 1; i &lt;= n; i++) bv[i] = (i-1) / size + 1;
	for(re int i = 0, j = 1; i &lt; n; i += size, j++) l[j] = i+1, r[j-1] = i;
	r[bv[n]] = n;
	
	B = n / sqrt(m);
	for(re int i = 1; i &lt;= n; i++) blo[i] = (i-1) / B + 1;
	for(re int i = 1; i &lt;= m; i++) cin &gt;&gt; q[i].l &gt;&gt; q[i].r, q[i].id = i;
	std::sort(q+1, q+m+1);
	for(re int i = 1, l = 1, r = 0; i &lt;= m; i++) {
		if(l &gt; q[i].l) v[r].push_back((twt){q[i].l, l-1, 1, 1, i});
		while(l &gt; q[i].l) q[i].ans -= ls[--l];
		if(r &lt; q[i].r) v[l-1].push_back((twt){r+1, q[i].r, 0, -1, i});
		while(r &lt; q[i].r) q[i].ans += gr[++r];
		if(l &lt; q[i].l) v[r].push_back((twt){l, q[i].l-1, 1, -1, i});
		while(l &lt; q[i].l) q[i].ans += ls[l++];
		if(r &gt; q[i].r) v[l-1].push_back((twt){q[i].r+1, r, 0, 1, i});
		while(r &gt; q[i].r) q[i].ans -= gr[r--];
	}
	
	for(re int i = 1; i &lt;= n; i++) {
		update(a[i]);
		for(re int j = 0; j &lt; (signed)v[i].size(); j++) {
			twt x = v[i][j];
			int l = x.l, r = x.r, c = x.c, op = x.op, id = x.id;
			for(int k = l; k &lt;= r; k++)
				if(c == 1) q[id].ans += op * query(a[k]-1);
				else q[id].ans += op * (query(n) - query(a[k])); 
		}
	}
	
	for(re int i = 2; i &lt;= m; i++) q[i].ans += q[i-1].ans;
	for(re int i = 1; i &lt;= m; i++) ans[q[i].id] = q[i].ans;
	for(re int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; '\n';
	return 0;
}
</code></pre>
</details>
<p>这题卡常卡了好久，发现奇偶性优化还是挺管用的。</p>
<p>放个重载好的快读快写吧。</p>
<details>
  <summary>输入输出优化</summary>
<pre><code class="language-cpp">namespace IO {
#define BUFSIZE 10000000
struct read {
    char buf[BUFSIZE], *p1, *p2, c, f;
    read() : p1(buf), p2(buf) {}
    char gc(void) {
        if (p1 == p2) p2 = buf + fread(p1 = buf, 1, BUFSIZE, stdin);
        if (p1 == p2)
            return EOF;
        else
            return *p1++;
    }
    read&amp; operator&gt;&gt;(int&amp; x) {
        c = gc(), f = 1, x = 0;
        for (; c &lt; '0' || c &gt; '9'; c = gc())
            if (c == '-') f = -1;
        for (; c &gt;= '0' &amp;&amp; c &lt;= '9'; c = gc()) x = x * 10 + c - '0';
        x *= f;
        return *this;
    }
};
struct write {
    char buf[BUFSIZE], *p1, *p2, s[50];
    int tp;
    write() : p1(buf), p2(buf + BUFSIZE) {}
    ~write() { flush(); }
    void flush(void) {
        fwrite(buf, 1, p1 - buf, stdout);
        p1 = buf;
    }
    void pc(char c) {
        if (p1 == p2) flush();
        *p1++ = c;
    }
    write&amp; operator&lt;&lt;(long long x) {
        if (x &lt; 0) x = -x, pc('-');
        do {
            s[tp++] = x % 10 + '0', x /= 10;
        } while (x);
        while (tp) pc(s[--tp]);
        return *this;
    }
    write&amp; operator&lt;&lt;(char x) {
        pc(x);
        return *this;
    }
};
read cin;
write cout;
} 
using IO::cin;
using IO::cout;
</code></pre>
</details>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[APIO 2021 游记]]></title>
        <id>https://acfboy.pw/apio2021/</id>
        <link href="https://acfboy.pw/apio2021/">
        </link>
        <updated>2021-05-24T12:53:46.000Z</updated>
        <summary type="html"><![CDATA[<p>50 天没啥进步倒是真的，但我真的没有想到 <strong>IOI 赛制都能挂分</strong>。</p>
<p><s>APIO 大概是算正式比赛（？）了吧，所以这似乎不是事故征候调查报告了，而是事故调查报告了——不过这种情况在 OI 赛制中不大会遇到。</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>50 天没啥进步倒是真的，但我真的没有想到 <strong>IOI 赛制都能挂分</strong>。</p>
<p><s>APIO 大概是算正式比赛（？）了吧，所以这似乎不是事故征候调查报告了，而是事故调查报告了——不过这种情况在 OI 赛制中不大会遇到。</s></p>
<!-- more -->
<h2 id="day-3">Day -3</h2>
<p>开始听课了……听不懂，跑了。</p>
<h2 id="day-2">Day -2</h2>
<p>听不懂 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2</p>
<h2 id="day-1">Day -1</h2>
<p>《不会有人掉线的》<br>
《掉线了可以马上重连》</p>
<p>前面还撑了一会儿，后面开始黑题多了就又听不懂了，跑了。</p>
<p>不过多了两发通过。</p>
<h2 id="day-1-2">Day 1</h2>
<h3 id="a">A</h3>
<p>上午来机房写了主席树/带修主席树的板子，就等待开始比赛。</p>
<p>没想到就在原机房里比赛，还以为要换机房以方便视频监考呢（</p>
<p>A 很快读完了题面，<s>运用出色的初中平面几何能力</s>，很容易发现 A 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的点就是等边三角形，很快推出了式子。</p>
<p>没急着写，反正就两三行，看了下下面的 subtask, 觉得暴力可做，但暴力太难写了，于是放弃，开始写 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 分。</p>
<p>然后就开始走向事故了，交了一发 WA, 又交了一发 WA, 仔细读题，原来是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 搞反了，好吧好吧，这会儿该对了，结果一交继续 WA，赛场上就很心态爆炸。一个小时居然一分没得。继续好好读题——发现边长似乎是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">L_0+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 然后一改就过了，于是一个小时半只得了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 分。</p>
<h3 id="b-1">B - 1</h3>
<p>B 题看着很眼熟，有点像线段树优化建图，于是我打开了洛谷，然后再把题目好好读。(<s>押韵</s>)</p>
<p>前面的 subtask 似乎单调栈建边都不用，直接 floyd 做就完了。后面也不大可能是比较普适的图论问题，<s>不然百度一下就会有了</s>， 所以想着挖掘一下性质。然后 nottttttthy 和 墨神 就在旁边叽里呱啦讲起了性质，但是我不想被剧透，于是把他俩请到外面去了。</p>
<p>结果自己研究了半天啥性质也没有发现，时间复杂度没有得到任何优化。而且当时脑子混沌一片，连多源 bfs 这种显然的东西都没有想到，一直想着离线下来一起考虑可能会减少很多的重复和不必要……</p>
<p>想什么呢！这不是强制在线吗！</p>
<p>想了会儿没啥思路，隔壁小渔已经宣布他在 C 题获得了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 分的优异成绩了，于是去想 C。</p>
<h3 id="c-1">C - 1</h3>
<p>显然第一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 分排个序就行了。</p>
<p>第二个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 分想了会儿贪心然后及时悬崖勒马了，发现是一个很简单的 dp ，于是写了就交了，然后进入一直 waiting 状态。</p>
<h3 id="吃饭">吃饭</h3>
<p>虽然说 APIO 要好好打，但是饭还是得吃的。</p>
<p>吃饭的时候交流了一下发现我现在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>18</mn></mrow><annotation encoding="application/x-tex">18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span></span></span></span> 的得分居然挺高的了。</p>
<h3 id="c-2">C - 2</h3>
<p>吃完饭测完了……居然 WA 了。</p>
<p>这么简单的 dp 我能 WA ? 找渔一问发现做法是对的，然后盲猜是边界有问题，修改了一波边界就交了。</p>
<h3 id="b-2">B - 2</h3>
<p>再次看到 B 的时候发现无权，所以直接多源 bfs 就可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>37</mn></mrow><annotation encoding="application/x-tex">37</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">7</span></span></span></span> 分了，于是写了个交上，然后发现评测机已经 SPFA 了。</p>
<p>也不太想做测试，就观察了一下代码，觉得这么简单的程序应该不会写错的（刚刚写挂了 C 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 分忘了？）， 然后想了一下下一个点怎么做。</p>
<p>尝试用数据结构大力维护，可是未果。</p>
<p>继续挖掘性质也没发现什么有用的。其实是人比较浮躁了没法静下心来了。索性就不写了。</p>
<p>看 C</p>
<h3 id="c-3">C - 3</h3>
<p>发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">n \le 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 的数据似乎可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> dp， 但是觉得方程可能会有些小问题，结合当时的情况觉得银牌应该没戏了，所以也不想做了，弃疗。</p>
<h3 id="赛后">赛后</h3>
<p>C 居然是原题。惊了。</p>
<p>赛后讲分块也不想听。不过 nottttttthy 倒是对女选手讲课很感兴趣。</p>
<p>放学前打了下篮球然后成功地受伤了，严重的萝卜干，手指都肿了，用点力弯曲伸直就痛，回到家后冰敷了也没用，第二天变得青一块紫一块，样子十分恐怖。</p>
<p>篮球太危险了，再也不大篮球了。</p>
<p>晚上 ABC PB 了，开心。</p>
<p>第二天 ARC 没有什么有价值的思考出来的成果，分数原地不动。</p>
<h2 id="day-2-2">Day 2</h2>
<p>居然有讲题？居然有颁奖典礼？</p>
<p>电脑上下 zoom 怎么那么的慢，用 <code>wget</code> 也很慢。</p>
<p>手机里放没有声音，所以不看了。</p>
<p>据说铜牌线是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>, 银牌只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>61</mn></mrow><annotation encoding="application/x-tex">61</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">1</span></span></span></span>。</p>
<p>什么！银牌只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>61</mn></mrow><annotation encoding="application/x-tex">61</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">1</span></span></span></span>, 那银牌完全可以得啊！这个时候有些后悔弃疗了。</p>
<h2 id="day-3-2">Day 3</h2>
<p>收到了 CCF 发来的邮件。</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/gxn9sI"><img src="https://z3.ax1x.com/2021/05/24/gxn9sI.png" alt="gxn9sI.png" loading="lazy"></a></figure>
<p>果然挂分。不过若果得了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>58</mn></mrow><annotation encoding="application/x-tex">58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span></span></span></span> 恐怕感觉会更糟糕，只差三分就上银了。</p>
<p>% 不挂分选手 LYC！</p>
<p><s>然后开始调查事故原因</s></p>
<h2 id="investigation">Investigation</h2>
<p>首先打开 C 的存档，检查哪里挂了。</p>
<p>一眼就看见没开 <code>long long</code>。</p>
<p>好了，调查结束。</p>
<p>！！！！！！！！！</p>
<h2 id="结论和建议">结论和建议</h2>
<ol>
<li>
<p>因为赛制不同所以全程未执行检查单，导致事故发生。</p>
<p><s>按照 CAAC 的风格恐怕是要“暂停 <code>#define int long long</code> 在算法竞赛中的应用”。</s></p>
</li>
<li>
<p>因为对比赛结果失去信息所以放弃治疗。</p>
</li>
</ol>
<p>改进方式：</p>
<ol>
<li>在任何正式比赛中必须执行检查单。</li>
<li>在 CF/AT 中除去极水的题以外也应执行检查单。</li>
<li>任何时候不能对比赛失去信心。</li>
</ol>
<p>其实 APIO 的失败主要还是在于平时的训练吧，说着冲刺 APIO, 可是简要日志里面基于 SOP SCR CI 的练习情况评价全是 Failed。</p>
<p>APIO 后，吸取教训，再出发。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AtCoder Beginner Contest 202 游记]]></title>
        <id>https://acfboy.pw/abc202/</id>
        <link href="https://acfboy.pw/abc202/">
        </link>
        <updated>2021-05-24T08:59:41.000Z</updated>
        <summary type="html"><![CDATA[<p>Personal Best !</p>
<p>晚上状态挺好，一下就恢复信心了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Personal Best !</p>
<p>晚上状态挺好，一下就恢复信心了。</p>
<!-- more -->
<p><a href="https://imgtu.com/i/gONCA1"><img src="https://z3.ax1x.com/2021/05/23/gONCA1.png" alt="gONCA1.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/gONPtx"><img src="https://z3.ax1x.com/2021/05/23/gONPtx.png" alt="gONPtx.png" loading="lazy"></a></p>
<p>D 一下子没有想清楚，吃了一发罚时，其它都还是可以的。</p>
<p>手指受伤前两题慢了些，对后面的题应该影响不大。</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/gONih6"><img src="https://z3.ax1x.com/2021/05/23/gONih6.png" alt="gONih6.png" loading="lazy"></a></figure>
<h2 id="a">A</h2>
<p>水题，直接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>21</mn></mrow><annotation encoding="application/x-tex">21</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span></span></span></span> 减掉输入的仨。</p>
<h2 id="b">B</h2>
<p>照题目说的做就行了。</p>
<h2 id="c">C</h2>
<p>拿个桶先存一下 B 中出现的就可以了。</p>
<h2 id="d">D</h2>
<blockquote>
<p>求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个 <code>a</code> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个 <code>b</code> 组成的字符串中字典序第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 小的。</p>
</blockquote>
<p>思路倒是很快有，就是每次确定最前面的一个 <code>b</code> 的位置，然后一个个处理下去。但是细节上有点小问题，导致我调了一会儿。</p>
<p>这是错误代码：</p>
<pre><code class="language-cpp">    for(int i = 1; i &lt;= B; i++) {
        int j;
        for(j = n-b+1; j &gt; B-b+1 &amp;&amp; C[n-j+1][b-1] &lt; k; j--);
        flag[j] = 1;
        k -= C[n-j][b-1];
        b--;
    }
</code></pre>
<p>我们要确认的第一个的位置应该是第一个随便排会大于等于现在的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的位置，而不是确定了这个后面随便排要小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的位置，然后再 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 减掉后面随便排的方案，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个数去掉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 继续做就可以了。</p>
<p>这才是正确代码：</p>
<pre><code class="language-cpp">    for(int i = 1; i &lt;= B; i++) {
        int j;
        for(j = n-b+1; j &gt; B-b+1 &amp;&amp; C[n-j+1][b] &lt; k; j--); 
        flag[j] = 1;
        k -= C[n-j][b];
        b--;
    }
</code></pre>
<h2 id="e">E</h2>
<blockquote>
<p>输入一棵树，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 次询问，每次求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子树中深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 的点的个数。</p>
</blockquote>
<p>直接做 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">nq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 显然会超时。</p>
<p>模拟下这个过程发现每次找了其它的深度是完全没有必要的，所以把每个深度分开来存储，然后考虑如何快速判断一个深度的点有几个在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子树里。</p>
<p>判断是否在子树里很容易想到 dfs 序，只要看 dfs 序是不是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>u</mi></msub><mo separator="true">,</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>u</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mi>u</mi></msub><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[dfn_u, dfn_u + size_u - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 这个区间里就可以了。为了快速做到这一点，可以将每一个深度的点按 dfs 序排序，然后再 <code>std::lower_bound</code> 一下起止点就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
const int N = 200005;
int n, x, y, m, dfn[N], size[N], tot;
std::vector&lt;int&gt; g[N], a[N];
void dfs(int u, int fa, int d) {
    size[u] = 1;
    dfn[u] = ++tot;
    a[d].push_back(dfn[u]);
    for(int i = 0; i &lt; (signed)g[u].size(); i++) {
        int v = g[u][i];
        if(v == fa) continue;
        dfs(v, u, d+1);
        size[u] += size[v];
    }
}
int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 2; i &lt;= n; i++) {
        scanf(&quot;%d&quot;, &amp;x);
        g[x].push_back(i), g[i].push_back(x);
    }
    dfs(1, 0, 0);
    for(int i = 0; i &lt; n; i++)
        if(a[i].size()) std::sort(a[i].begin(), a[i].end());
    scanf(&quot;%d&quot;, &amp;m);
    while(m--) {
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        int l = dfn[x], r = dfn[x] + size[x] - 1;
        int L = std::lower_bound(a[y].begin(), a[y].end(), l) - a[y].begin(),
            R = std::upper_bound(a[y].begin(), a[y].end(), r) - a[y].begin();
        printf(&quot;%d\n&quot;, std::max(R-L, 0));        
    }
    return 0;
}
</code></pre>
<p>难得在一个小时多一点就 A 了 E 题。</p>
<h2 id="f">F</h2>
<p>计算几何题，而且很难，没思路，总共才 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>25</mn></mrow><annotation encoding="application/x-tex">25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span> 个人过。</p>
<h2 id="最后">最后</h2>
<p>APIO 报名时的豪迈壮志最终一天天的化解， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> 天一过仍未有任何进步。每天浑浑噩噩的都过去了。</p>
<p>林语堂说：</p>
<blockquote>
<p>一个人心地干净，思路清晰，没有多余情绪和妄想的人，是会带给人安全感的，因为他不伤人，也不自伤，不制造麻烦，也不麻烦别人。某种程度上来说，这是一种持戒。</p>
</blockquote>
<p>翘翘所谓的可爱，只是在原来可爱优秀的同学们中受感染的罢了。只有真正的独立的做到和坚持“心地干净，思路清晰，没有多余情绪和妄想”，才是真正可爱的翘翘。</p>
<p>任何时候改变都来的及，前方的路还长。加油。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.5.21 模拟赛游记]]></title>
        <id>https://acfboy.pw/20210521/</id>
        <link href="https://acfboy.pw/20210521/">
        </link>
        <updated>2021-05-21T06:36:15.000Z</updated>
        <summary type="html"><![CDATA[<p>其实又是未遵循标准程序造成的严重事故征候。</p>
<p>吸取了上次的经验，开始记录较为详细的 CVR 数据了，用来 <s>热烈庆祝</s> 加速调查。</p>
]]></summary>
        <content type="html"><![CDATA[<p>其实又是未遵循标准程序造成的严重事故征候。</p>
<p>吸取了上次的经验，开始记录较为详细的 CVR 数据了，用来 <s>热烈庆祝</s> 加速调查。</p>
<!-- more -->
<p>先放上 CVR 数据：</p>
<pre><code class="language-CVR">比赛开始于 0110Z

共产生三份备份，备份最终修改时间 0218Z 0239Z 和 0318Z。
未进行回滚。

A:
// 0130Z - coding completed
// 0137Z - before submit checklist completed

B:
// 0210Z - coding compeleted
// 0211Z - error occured ! 
// 0225Z - extra tests begin
// 0235Z - error occured !
// 0310Z - skip procedues
// 0328Z - debug again
// 0343Z - before submit checklist compeleted

C:
未执行检查单。
</code></pre>
<h2 id="a">A</h2>
<p>看题之后先瞎想了一会儿，然后模拟了一下暴力思路，很快发现了重复，写出了正解。</p>
<p>由 CVR 数据可知在比赛开始之后二十分钟写完了，然后没经过什么调试并在七分钟后完成了提交前检查单。对于模拟赛第一题来说这个速度可能略微有一点慢，但从总体看对这场比赛的影响不大。</p>
<h2 id="b1">B1</h2>
<p>明明是数位 dp 的模板，但事情有一点儿不太对劲了。</p>
<p>从 CVR 看，B 题完成第一份代码一共使用了超过半小时，对于一个不是很复杂的模板这个用时显然有一点高了。</p>
<p>随后开始执行提交前检查单，很快发现了错误，即输入数据无法使用整型进行存储，然后开始修正，最终在十多分钟后通过了样例。由于独立完成的数位 dp 不多，所以有点不放心，而且人工难以完成检查单所要求的 tests, 所以开始对拍。</p>
<p>然后直接就拍出了错误……接着就是一堆的调试了。</p>
<p>甚至写完之后一个小时了都没有调处来，因为这题总用时已经达到一小时三十分，严重超出了最开始的计划，所以执行跳题程序，先去 C 了。</p>
<h2 id="c">C</h2>
<p>看了题觉得是有什么结论的，但是由于前一题的原因，直接就写了个模拟，时间上可能是可以过的，但是没空考虑证明了，所以这大概是一个谭变。</p>
<p>既然没有给出啥证明，就觉得 <s>速度大点没事</s>，检查单啥的不管了。</p>
<h2 id="b2">B2</h2>
<p>调了一会儿总算是调出来了。一个很傻的小问题。</p>
<p>比赛开始之后两小时三十二分完成了检查单。</p>
<h2 id="然后">然后……</h2>
<p>然后呢！这个时候明明已经完成了，为什么不去做最后一题的检查单？！</p>
<p>最后因为 （返回值不为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>）</p>
<pre><code class="language-cpp">if(b == 0) return printf(&quot;%lld\n&quot;, ans);
</code></pre>
<p>而 RE 了，失去了 AK 的机会。</p>
<p>还是得讲一下最后一题的：</p>
<blockquote>
<p>两个数，每次可以把大的一个减去小的并把小的一个翻倍，问多少次之后一个为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
</blockquote>
<p>反过来考虑这个问题，若最后有解，那么一次次的分裂之中不可能超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 级别次，所以复杂度是对的。</p>
<p>事实上还有一种更简单的做法：因为永远是把一个减掉，所以分的最小的块就是两个的最大公约数了，除掉这个公约数答案不会发生变化。而由前面的分裂理论得到，把两个数的和除掉公约数然后取个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span> 就可以了。</p>
<h2 id="结论和建议">结论和建议</h2>
<p>这次严重事故征候的原因主要在于对于简单问题过于放松，未完整执行检查单。</p>
<p>所以建议在任何情况下都应遵循标准操作程序并严格执行检查单。同时，对 IO 的检查中也应该加入对输出后退出的检查， tests 检查中应确认程序返回值。</p>
<p>对于一些合并的证明可以反向思考。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.5.19 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210519/</id>
        <link href="https://acfboy.pw/20210519/">
        </link>
        <updated>2021-05-19T12:14:25.000Z</updated>
        <summary type="html"><![CDATA[<p>AK 了，但又完全没有 AK.</p>
]]></summary>
        <content type="html"><![CDATA[<p>AK 了，但又完全没有 AK.</p>
<!-- more -->
<h2 id="a">A</h2>
<p>【模板】分层图最短路</p>
<h2 id="b-times-1">B <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 1</h2>
<blockquote>
<p>求一个无向图生成树最小叶子个数。</p>
</blockquote>
<p>一看数据范围 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>, 开始考虑状压，不过树的形态不同会导致后效性，解决后效性一般要么加维要么改变 dp 顺序，由于一个点被连边两次以上之后就不可能成为儿子，所以可以加维记哪些是儿子，但这题一加维直接爆空间。</p>
<p>至于顺序，这个后效性和顺序好像没有什么关系。</p>
<p>想足二十分钟而未果后执行跳题检查单，果断跳过。</p>
<h2 id="c">C</h2>
<p>【模板】换根 DP</p>
<h2 id="d">D</h2>
<p>【模板】01 背包</p>
<p>其实一开始想到贪心去了，后来一看权值的范围这不是直接背包就完了吗？</p>
<h2 id="b-times-2">B <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2</h2>
<p>仔细确认了解决后效性的确实不可做，开始想着换思路。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 的数据范围……那不是应该先想着爆搜吗？于是就想了下能否直接搜索哪些点是叶子，再验证，结果发现……确实可以。</p>
<p>然后切了。</p>
<p><strong>切了，但又完全没切</strong>（ <s>矛 盾 文 学 奖</s> ）</p>
<p>加边的时候出了点小问题：插了一个后没有 break, 另外没有特判 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的情况。</p>
<hr>
<p><s>一场比赛三道模板题，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">❀</mi></mrow><annotation encoding="application/x-tex">❀</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord">❀</span></span></span></span> 瞧不起谁呢！</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AtCoder Regular Contest 119 游记]]></title>
        <id>https://acfboy.pw/arc119/</id>
        <link href="https://acfboy.pw/arc119/">
        </link>
        <updated>2021-05-17T00:59:45.000Z</updated>
        <summary type="html"><![CDATA[<p>都是神仙思维题啊…… dblark 七分钟 B 题， 六分钟 C 写完 C</p>
]]></summary>
        <content type="html"><![CDATA[<p>都是神仙思维题啊…… dblark 七分钟 B 题， 六分钟 C 写完 C</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>找出三元组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, b, c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>×</mo><msup><mn>2</mn><mi>b</mi></msup><mo>+</mo><mi>c</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">a \times 2^b + c = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a+b+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 最小。</p>
</blockquote>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mfrac><mi>n</mi><msup><mn>2</mn><mi>b</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">k = \frac{n}{2^b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0528119999999999em;vertical-align:-0.3574199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.64258em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3574199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，那么三元组可以有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo>+</mo><msup><mn>2</mn><mi>b</mi></msup><mo>)</mo><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">(k, b, c), (k-1, b, c+2^b), \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> 因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>b</mi></msup><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^b \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.985078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 所以让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 变小没有好处，那么枚举一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 然后求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 即可。</p>
<h2 id="b">B</h2>
<blockquote>
<p>每次可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>011</mn><mo>…</mo><mn>1</mn><mo>→</mo><mn>111</mn><mo>…</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">011\dots1 \to 111\dots 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span></span></span></span> 或反过来，问最少需要多少步使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>。</p>
</blockquote>
<p>显然若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的个数不一样是没有办法做到的，而一样的显然是可以完成的。</p>
<p>然后我就陷入了没有进展的一个小时，一会儿考虑整块 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的跳动，一会而又想贪心处理哪一些 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 应该到哪些位置去。</p>
<p>终于过了一个多小时之后才发现了关键：考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的位移。</p>
<p>本质上这个变换所需要的最少步数就是把移动所涉及到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 都给移动一次。所以问题变成了如何判断哪些 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 是必需移动的就可以了。</p>
<p>那么显然左右的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个数都相等的直接就不需要移动了。</p>
<h2 id="c">C</h2>
<p>同样是思维题。</p>
<blockquote>
<p>每次可以把相邻的两个同时加或减一个数，问能全变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的区间有几个。</p>
</blockquote>
<p>因为相邻的两个同时加减，所以奇数位和偶数位的差是不变的，那么一开始奇数偶数位的差不一样的肯定不行，一样的直接考虑把前面尽可能清空就可以了。</p>
<p>有个小 trick, 可以前缀和的时候直接对奇偶位和的差作前缀和就行了，然后存进个 <code>std::map</code> 里面，统计的时候看有几个一样的中间选俩就可以了。</p>
<hr>
<p>又掉分了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Educational Codeforces Round 109 游记]]></title>
        <id>https://acfboy.pw/educational-codeforces-round-109/</id>
        <link href="https://acfboy.pw/educational-codeforces-round-109/">
        </link>
        <updated>2021-05-17T00:59:15.000Z</updated>
        <summary type="html"><![CDATA[<p>恐怕要继续掉分了……没经过证明的贪心绝对不能用啊。</p>
]]></summary>
        <content type="html"><![CDATA[<p>恐怕要继续掉分了……没经过证明的贪心绝对不能用啊。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题，约分即可。</p>
<h2 id="b">B</h2>
<blockquote>
<p>输入一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列，每次可以选一个长度不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的区间打乱，求使他有序的最小步数。</p>
</blockquote>
<p>显然，若原来有序答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 若头/尾在正确的位置上答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 那么否则答案是不是就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 了呢？</p>
<p>其实不是，还要考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的情况，这样没法一次使头/尾归位，所以需要三次操作。</p>
<p>因为没考虑到最后一个情况，所以 WA 了一发。</p>
<p>其实前面的情况的证明中就涉及了一次要让头/尾中至少一个归为，所以当然应该考虑不能归为的情况。</p>
<h2 id="c">C</h2>
<p>看了题大概知道是小模拟，先搞个栈处理一遍再处理通向两边的再处理回来的。因为不想写小模拟所以先过。</p>
<h2 id="d">D</h2>
<blockquote>
<p>每次可以移动一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 移动代价是移动的距离，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 全移动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的位置上的最小代价是多少？</p>
</blockquote>
<p>模拟了几个小样例觉得不能穿越，所以天真的以为就是从中间分开，然后必然往两边跑，但这个想法实际上样例都过不了，居然写完了以后才发现这一点。</p>
<p>然后又去想着其它的贪心，就是一块向两边拓展，想了想似乎没有问题，因为如果一定要到另一边才行的话那后面的必然会到另一边的。</p>
<p>但实际上这个做法是错误的，反例如下：</p>
<pre><code class="language-plain">30
0 0 0 0 1 0 1 1 1 0 1 0 1 1 1 1 0 1 0 1 1 1 0 0 0 0 0 0 0 1 
</code></pre>
<p>正确输出是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>52</mn></mrow><annotation encoding="application/x-tex">52</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">2</span></span></span></span>，而我呢吧的做法输出是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>60</mn></mrow><annotation encoding="application/x-tex">60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span></span></span></span>, 因为最右边那一段往右边移动更近，而实际上左边多使用一格可以使前面减少的更多。而我的所谓证明错在它根本没有证明，它只是考虑跨越的情况而已，而没有考虑整体往一边多出一点会更优。</p>
<p>正确做法是一个挺好做的 dp。设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 是用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 要移动的最少步数，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>{</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>b</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">f_{i,j} = \min\{f_{i-1, j}, f_{i-1,j-1} + |a_i - b_j|\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mop">min</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mclose">}</span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 中存的分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的下标们。</p>
<p>这样是对的因为加入一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或把当前最后一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 移动到最后一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的构造方案可以构造出所有的移动方案。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
const int N = 5005;
int n, x, f[N][N];
std::vector&lt;int&gt; a, b;
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d&quot;, &amp;x);
		if(x == 0) a.push_back(i);
		else b.push_back(i);
	}
	memset(f, 0x3f, sizeof f);
	f[0][0] = 0;
	for(int i = 1; i &lt;= (signed)a.size(); i++)
		for(int j = 0; j &lt;= std::min((signed)b.size(), i); j++) {
			f[i][j] = std::min(f[i-1][j], f[i][j]);
			if(j != 0) f[i][j] = std::min(f[i][j], f[i-1][j-1] + std::abs(a[i-1] - b[j-1]));
	}
	printf(&quot;%d&quot;, f[a.size()][b.size()]);
	return 0;
}
</code></pre>
<p><s>根据 CVR 数据</s>， 我其实第一次贪心 WA 了之后转 dp 还是来得及的……</p>
<p>所以未经证明的贪心千万别用，用了之后 WA 了也赶紧回头吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AtCoder Beginner Conteset 201 游记]]></title>
        <id>https://acfboy.pw/abc201/</id>
        <link href="https://acfboy.pw/abc201/">
        </link>
        <updated>2021-05-17T00:58:49.000Z</updated>
        <summary type="html"><![CDATA[<p>似乎 D、E 的套路都很明显啊，我居然这个都要调半天甚至想不出来了……</p>
]]></summary>
        <content type="html"><![CDATA[<p>似乎 D、E 的套路都很明显啊，我居然这个都要调半天甚至想不出来了……</p>
<!-- more -->
<h2 id="d">D</h2>
<blockquote>
<p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 出发可以向下一格向右一格，到一格时相应的人的分数会因为格子上的 <code>+/-</code>  而加一或者减一，T 先， A 后，最优策略下谁赢？</p>
</blockquote>
<p>我开始时居然从头开始 dp, WA 了三发才发现决策的东西不对，应该是这一格来决策下一格，而不是这一格决策从哪一格来。</p>
<p>而且我们仅能确定的是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 谁能赢。那么倒着 dp 一次就好了。</p>
<p>归根结底还是没想清楚就着急写。</p>
<h2 id="e">E</h2>
<blockquote>
<p>求树上所有点对路径上边异或和的和。</p>
</blockquote>
<p>我开始的想法是每一位分开处理，预处理出一个点向上/向下有多少当前位是奇数/偶数的，然后在统计，但这样显然会又重复，因为路径上 dfs 到的时候同一条路会被计算多次。</p>
<p>其实简单转化一下就很好做了，把它转化成根到两点的异或和的和，这样只要每一位看一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的个数乘起来就可以了。这个转化似乎也挺套路的。</p>
<p>也是最后时间紧急了就没想清楚直接写了哇，其实想清楚后完全来得及的，以后不要再犯这种错误了。</p>
<hr>
<p>现在状态确实越来越差了。</p>
<blockquote>
<p>翘翘</p>
<p>是谁使你优秀</p>
<p>又是谁使你堕落</p>
<p>所以你喜欢着谁</p>
<p>又痛恨着谁？</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [CCC 2018]平衡树]]></title>
        <id>https://acfboy.pw/2018ping-heng-shu/</id>
        <link href="https://acfboy.pw/2018ping-heng-shu/">
        </link>
        <updated>2021-05-15T01:05:01.000Z</updated>
        <summary type="html"><![CDATA[<p>第一次发现哈希表这么好用。<code>^_^</code></p>
<p>其实不用哈希表和 STL 的做法思想还是非常巧妙的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>第一次发现哈希表这么好用。<code>^_^</code></p>
<p>其实不用哈希表和 STL 的做法思想还是非常巧妙的。</p>
<!-- more -->
<p>简化后题意：</p>
<blockquote>
<p>输入的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 每次除以一个数下取整，到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 停止，两个方案有一次除以的数不同就算作不同，方案有多少种？</p>
</blockquote>
<p>直接转移的方程很好想，如果做过一些数论分块的题的话也应该很容易想到这是数论分块。</p>
<p>但是数论分块做复杂度大约是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\log n \sqrt n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span> 的，再记忆化的话用 <code>map</code> 就会 T 掉。那么 <s>考虑 unordered_map</s> 就自己实现一个哈希表吧。</p>
<p>我用了链式的方法处理冲突，本以为会被卡，结果一发就过了，没想到哈希表那么好用，<s>以后就别用 <code>map</code> 了，直接啥都哈希表吧</s> 该用 <code>map</code> 的时候还是 <code>map</code> 好用。</p>
<p>代码。（不知道那种直接赋值的应该如何重载，所以写了 <code>twt.insert</code>）</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
#define int long long
int n;
const int p = 951161;
struct twt {
	std::vector&lt;std::pair&lt;int, int&gt; &gt; g[1000000];
	bool count(int x) {
		int t = x % p;
		for(int i = 0; i &lt; (signed)g[t].size(); i++)
			if(g[t][i].first == x) return true;
		return false;
	}
	int operator [] (int x) {
		int t = x % p;
		for(int i = 0; i &lt; (signed)g[t].size(); i++)
			if(g[t][i].first == x) return g[t][i].second;
	}
	void insert(int x, int y) {
		int t = x % p;
		g[t].push_back(std::make_pair(x, y));
	}
} hash;
int solve(int x) {
	if(hash.count(x)) return hash[x];
	int an = 0;
	for(int l = 2; l &lt;= x; l++) {
		int r = x / (x / l);
		an += solve(x/l) * (r-l+1);
		l = r;
	}
	hash.insert(x, an);
	return an;
}
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	hash.insert(1, 1);
	printf(&quot;%lld&quot;, solve(n));
	return 0;
}
</code></pre>
<p>这里用哈希似乎有点无脑了，那么不用哈希怎么做呢？</p>
<p>题解中有一个巧妙的想法：小范围内先处理出来一串。然后经过一堆看不懂的时间复杂度分析就可以过，以后如果实在没有办法可以试试这样的方式。</p>
<p>还有个大佬直接就建立一对一的映射了：</p>
<pre><code class="language-cpp">b = sqrt(n);
int pos(int x) { return (x*x &lt;= n) ? x : (b+n/x); }
</code></pre>
<p>原理大概是 <code>x*x &lt;= n</code> 时比较密，然后后面就以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mi>x</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 为一段才出现一个了，所以直接加上去。</p>
<p>妙啊！以后遇上这种问题不妨多模拟几个小样例试试这样的一对一映射是否可行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.5.14 模拟赛游记]]></title>
        <id>https://acfboy.pw/20210514/</id>
        <link href="https://acfboy.pw/20210514/">
        </link>
        <updated>2021-05-14T07:31:11.000Z</updated>
        <summary type="html"><![CDATA[<p>恐怕又变成严重事故征候调查报告了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>恐怕又变成严重事故征候调查报告了。</p>
<!-- more -->
<p>本来是想着一定要吸取上次的教训严格执行检查单和标操作程序的，虽然最后一题差了那么一些但前两题总应该过的吧。</p>
<p>结果吃好午饭回来就是事故现场了。</p>
<h2 id="a">A</h2>
<p>签到题。</p>
<h2 id="b">B</h2>
<p>同样很容易想到直接用树状数组的做法，但我一时脑抽还加了个 <code>set</code>, 本来也是没有问题的，结果就直接炸成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 分了。</p>
<p><s>KTSB 第一时间就展开了调查。</s> 数据扔进去一看，居然是用空格分隔的，我怎么用了换行符呢？改了之后还是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span> 分，盯着看了很久没有发现任何问题，结果老板看了一眼就说：“没有取模”。</p>
<p>居然还真是没有取模。</p>
<p>没有取模。</p>
<p>取模。</p>
<p>取模可是在检查单里的啊！代码注释下面就写了 <code>mod</code> 居然会死在取模上。</p>
<p><code>IO</code> 似乎也是在检查单上的。</p>
<h2 id="c">C</h2>
<blockquote>
<p>执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次，每次在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的网格上随机选俩点，求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次之后覆盖的格子大小的期望。</p>
</blockquote>
<p>开始就是直接想的，模拟了一下小样例，然后试图发现一些性质，然后就发现了这条路是走不通的，因为不同的形态太多了。</p>
<p>此时已经是最后半小时了吧，想着换一种思路来考虑这个问题，于是考虑每一个点对答案的贡献，设所有方案的总数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>， 包含当前点的方案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个， 那么一次取到的概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>t</mi><mi>w</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{t}{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824556em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, 那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次里面有至少一个取到的方案数是多少呢？</p>
<p>我居然傻乎乎的想当然了一下认为是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mi>p</mi></mrow><annotation encoding="application/x-tex">3p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord mathdefault">p</span></span></span></span>, 显然是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo>)</mo><mi>k</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(1-(1-p)^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 啊！然后就考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 怎么求。</p>
<p>开始的时候想的是只考虑左上和右下的，总方案数也除以个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>,结果搞了半天没有搞出来，比赛就结束了。</p>
<p>其实左下和右上同样构成答案，这里不像其它一些问题中是可以省略的。那么来考虑怎么样不会有重复。介于我容斥啥一窍不通，所以就直接分成九块大力讨论了，然后代码就变成这个样子了：</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
int n, k, m;
double ans, p;
int main() {
	freopen(&quot;paint.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;paint.out&quot;, &quot;w&quot;, stdout);
	
	scanf(&quot;%d%d%d&quot;, &amp;k, &amp;n, &amp;m);
	double w = (double)n*m*n*m;
	for(int i = 1; i &lt;= n; i++)
		for(int j = 1; j &lt;= m; j++) {
			double s1 = (i-1)*(j-1),
				   s2 = i-1,
				   s3 = (m-j)*(i-1),
				   s4 = j-1,
				   s5 = m-j,
				   s6 = (j-1)*(n-i),
				   s7 = n-i,
				   s8 = (m-j)*(n-i);
			double t = s1 * (s5 + s7 + s8 + 1)
					 + s2 * (s4 + 1 + s5 + s6 + s7 + s8)
					 + s3 * (s4 + 1 + s7 + s6)
					 + s4 * (s2 + s3 + 1 + s5 + s7 + s8)
					 + s5 * (s1 + s2 + s4 + 1 + s6 + s7)
					 + s6 * (s2 + 1 + s3 + s5)
					 + s7 * (s1 + s2 + s3 + s4 + 1 + s5)
					 + s8 * (s1 + s2 + s4 + 1)
					 + 1 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8;
			t /= w;
			p = t;
			ans += (1 - pow(1-p, k));
		}
	printf(&quot;%.8lf&quot;, ans);
	return 0;
}

</code></pre>
<h2 id="结论和建议">结论和建议</h2>
<p>想着 “严格执行检查单和标操作程序的”， 结果还是因为没有真正做好这些要求而失去了 B 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 分。</p>
<p>至于 C，则是 <s>机械故障</s> 技术上的错误了。</p>
<p>所以：</p>
<ol>
<li>要认真执行检查单。
<ol>
<li>输入输出条目不仅包括文件，也得包括输出格式。</li>
<li>检查取模不能停留在表面，必须检查每一个需要取模的运算。</li>
<li>不能想着以后对拍，必须及时执行 <code>test</code> 项。</li>
</ol>
</li>
<li>数学问题不能只想当然。
<ol>
<li>&quot;至少取到一个&quot; 的问题刻意转换成“一个都不取到”然后容斥一下。</li>
<li>遇到重复时静下来暴力讨论也是个好方法。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
</feed>