<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的小站</title>
    <updated>2021-04-02T03:40:40.356Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的小站</rights>
    <entry>
        <title type="html"><![CDATA[4.22 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210422/</id>
        <link href="https://acfboy.pw/20210422/">
        </link>
        <updated>2021-04-02T03:37:47.000Z</updated>
        <summary type="html"><![CDATA[<p>其实正解都想得挺快的，但是 D 题细节有些恶心，最终调了很久，没空做最后一题了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>其实正解都想得挺快的，但是 D 题细节有些恶心，最终调了很久，没空做最后一题了。</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>一个字符串，若干个操作，每次翻转或在开头/结尾插入，输出最后结果。</p>
</blockquote>
<p>水题，<code>deque</code> 解决。</p>
<h2 id="b">B</h2>
<blockquote>
<p>一个字符串，维护区间内不同的字符个数，支持单点修改。</p>
</blockquote>
<p>线段树裸题。</p>
<h2 id="c">C</h2>
<p>水题，题目都不想打了。</p>
<h2 id="d">D</h2>
<p>随便来个样例，把所有的列出来。</p>
<pre><code class="language-plain">3
35
354
3543
 5
 54 
 543
  43
   3
</code></pre>
<p>中间显然有很多重复。</p>
<p>若只维护第一组，那么每次每个要减去的数不一样，所以从后面开始。</p>
<pre><code class="language-plain">   3
  43
 543
3543
  4
 54
354
 5
35
3
</code></pre>
<p>这样对于每一组，就是把第一个去掉，然后剩下的每一个减去最后一个位再除以十就可以了。</p>
<p>因为对于所有数的处理都一样，所以直接把取模完每一个答案有几个给记下来，然后维护一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, 满足经过了哪些操作原来答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的答案会变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 然后加上这个就可以了。</p>
<p>具体地，比如有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 个数，我现在要求倒数第二组的答案，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 需要满足(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">inv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的逆元)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mo>(</mo><mi>k</mi><mo>−</mo><msub><mi>s</mi><mn>5</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>)</mo><mo>−</mo><msub><mi>s</mi><mn>4</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>)</mo><mo>−</mo><msub><mi>s</mi><mn>3</mn></msub><mo>)</mo><mo>×</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="1em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">((((((k-s_5)\times inv) - s_4) \times inv) - s_3) \times inv \equiv 0 \pmod p
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p>
<p>化简一下就是每次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>p</mi><mi>o</mi><mi>w</mi></mrow></msup></mrow><annotation encoding="application/x-tex">s_i \times 10^{pow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></span> 。</p>
<p>然后你就可以交了。</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#define int long long
int n, m, p, ans, f[10005];
char s[200005];
signed main() {
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p);
    scanf(&quot;%s&quot;, s + 1);
    for (int i = n, pow = 1, now = 0; i &gt;= 1; i--, pow = pow * 10 % p) {
        now = (now + (s[i] - '0' + p) * pow % p) % p;
        f[now]++;
    }
    for (int i = n, pow = 1, now = 0; i &gt;= 1; i--, pow = pow * 10 % p) {
        ans = ans + f[now];
        now = (now + (s[i] - '0') * pow % p) % p;
        f[now]--;
    }
    printf(&quot;%lld&quot;, ans);
}

</code></pre>
<p>交了以后会发现：WA 了</p>
<p>细细一想，发现若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的约数时连个逆元都没有，你乘个锤子！</p>
<p>所以特判一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的情况。</p>
<pre><code class="language-cpp">    if (p == 2 || p == 5) {
        for (int i = 1; i &lt;= n; i++)
            if ((s[i] - '0') % p == 0)
                ans += i;
        printf(&quot;%lld&quot;, ans);
        return 0;
    }
</code></pre>
<p>现在真的过了。这错误我调了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span> 分钟</p>
<h2 id="e">E</h2>
<p>原题是 ABC158F。</p>
<p><s>看了题解</s> 觉得 dp 还是比较显然的，肯定得排一个序，然后倒着。因为我们能唯一能确定的状态就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这个编号，根本没有机器人，方案只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个的方案数。显然可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_i = f_{i+1} + f_{next}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span> 是后面不受影响的。</p>
<p>问题在于后面那个怎么求。 <code>next</code> 即后面第一个大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x + d - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的，那不就是单调栈吗？</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
const int N = 200005, p = 998244353;
int n, f[N];
std::pair&lt;int, int&gt; a[N];
std::stack&lt;std::pair&lt;int, int&gt; &gt; st;
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i].first, &amp;a[i].second);
	std::sort(a+1, a+1+n);
	f[n+1] = 1;
	for(int i = n; i &gt;= 1; i--) {
		int t = a[i].first + a[i].second, next = i+1;
		while(!st.empty() &amp;&amp; t &gt; a[st.top().first].first) {
			next = st.top().second;
			st.pop();
		}
		st.push({i, next});
		f[i] = (f[i+1] + f[next]) % p;
	}
	printf(&quot;%d&quot;, f[1]);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[焦点]]></title>
        <id>https://acfboy.pw/fighting/</id>
        <link href="https://acfboy.pw/fighting/">
        </link>
        <updated>2021-04-01T23:22:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>一个焦点是木桩，一个焦点在远方。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>一个焦点是木桩，一个焦点在远方。</p>
</blockquote>
<!-- more -->
<p>语出萨曼·霍伊斯·艾伯特·康佩尔·威斯·阿瑞尔·佩格·赛真猪，原指在 Shaopi 的研究中，知道绳长较长的一种是一个椭圆；又猜测猜测一种圆桌上的 Shaopi 构成椭圆，一个焦点是 “木桩”，另一个无法确定在哪。</p>
<p>现在我们知道，那不是椭圆，而是双曲线，另一个焦点，就在圆心。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [CF -1172D]Nauuo and Binary Tree]]></title>
        <id>https://acfboy.pw/nauuo-and-binary-tree/</id>
        <link href="https://acfboy.pw/nauuo-and-binary-tree/">
        </link>
        <updated>2021-04-01T23:21:17.000Z</updated>
        <summary type="html"><![CDATA[<p>清新的好题，考验了对树剖的总和理解和运用。</p>
<p>只可惜 <a href="https://ouuan.github.io/post/bad-round-%E4%B8%8E%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E5%9D%9A%E5%AE%88/">赛前四天撞题</a>，这道题没能出现在真正的 CF 里。</p>
]]></summary>
        <content type="html"><![CDATA[<p>清新的好题，考验了对树剖的总和理解和运用。</p>
<p>只可惜 <a href="https://ouuan.github.io/post/bad-round-%E4%B8%8E%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E5%9D%9A%E5%AE%88/">赛前四天撞题</a>，这道题没能出现在真正的 CF 里。</p>
<!-- more -->
<blockquote>
<p><strong>交互题</strong>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个节点的二叉树，每次可以询问两个点的距离，求这个二叉树的结构。树的大小不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3000</mn></mrow><annotation encoding="application/x-tex">3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>, 可以询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30000</mn></mrow><annotation encoding="application/x-tex">30000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次。</p>
</blockquote>
<p>看到这个题面我是没有一点想法，甚至连暴力做法都不太清楚。</p>
<p>看了题解直呼好题。</p>
<ol>
<li>
<p>首先可以询问出每一个点的深度，这样可以按照深度确定点，从而确保去确定一个点的时候它的祖先都已经确定了。</p>
</li>
<li>
<p>每次确定一个点时</p>
<ol>
<li>先用 dfs 维护已知树上的轻重链。注意，因为是二叉树，所以一个点若有两个儿子，那么必定是一条轻边一条重边。如果只有一个儿子，我们规定连向它的是重边。这个性质非常有用。</li>
<li>在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子树中找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 时，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 已经没有儿子了，肯定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的父亲。</li>
<li>否则询问当前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 所在重链底部的距离记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>, 通过类似通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">LCA</mtext></mrow><annotation encoding="application/x-tex">\texttt{LCA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">LCA</span></span></span></span></span> 求两点距离的那个式子可以求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">LCA</mtext></mrow><annotation encoding="application/x-tex">\texttt{LCA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">LCA</span></span></span></span></span> 的深度，进而求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">LCA</mtext></mrow><annotation encoding="application/x-tex">\texttt{LCA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">LCA</span></span></span></span></span>, 然后就可以确定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 所在的新子树，递归求解。</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 只有一个儿子，那它就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 了，因为只有一个儿子那么肯定是重边，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 所在重链的最底端也是它自己。</li>
</ol>
</li>
</ol>
<p>具体可以见下图。</p>
<figure data-type="image" tabindex="1"><img src="https://oi-wiki.org/graph/images/hld2.png" alt="" loading="lazy"></figure>
<p>时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的，询问由于每次都会确定一个子树，所以是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span> 级别的，具体分析可以去看 OI-wiki</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
const int N = 3005;
struct twt {
	int dep, id;
	bool operator &lt; (twt b) const {
		return dep &lt; b.dep;
	}
} a[N];
int n, ch[N][2], son[N], fa[N], bot[N], deep[N], size[N];
void Print() {
	std::cout &lt;&lt; &quot;! &quot;;
	for(int i = 2; i &lt;= n; i++) std::cout &lt;&lt; fa[i] &lt;&lt; &quot; &quot;;
	std::cout &lt;&lt; std::endl;
}
int ask(int u, int v) {
	std::cout &lt;&lt; &quot;? &quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; std::endl;
	int d;
	std::cin &gt;&gt; d;
	return d;
}
void add(int u, int v) {
	fa[v] = u;
	if(ch[u][0] != 0) ch[u][1] = v;
	else ch[u][0] = v;
}
void dfs(int u) {
	if(ch[u][0]) dfs(ch[u][0]);
	if(ch[u][1]) dfs(ch[u][1]);
	size[u] = size[ch[u][0]] + size[ch[u][1]] + 1;
	if(ch[u][1] != 0) son[u] = size[ch[u][1]] &gt; size[ch[u][0]];
	else son[u] = 0;
	if(ch[u][son[u]] != 0) bot[u] = bot[ch[u][son[u]]];
	else bot[u] = u;
}
void solve(int u, int k) {
	if(ch[u][0] == 0) {
		add(u, k);
		return;
	}
	int d = ask(k, bot[u]), v = bot[u];
	while(deep[v] &gt; (deep[k] + deep[bot[u]] - d) / 2) v = fa[v];
	int w = ch[v][son[v] ^ 1];
	if(w != 0) solve(w, k);
	else add(v, k);
}
int main() {
	std::cin &gt;&gt; n;
	for(int i = 2; i &lt;= n; i++) {
		a[i].id = i;
		a[i].dep = ask(1, i);
		deep[i] = a[i].dep;
	}
	std::sort(a+2, a+1+n);
	for(int i = 2; i &lt;= n; i++) {
		dfs(1);
		solve(1, a[i].id);
	}
	Print();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.3.31 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/2021331/</id>
        <link href="https://acfboy.pw/2021331/">
        </link>
        <updated>2021-04-01T00:15:33.000Z</updated>
        <summary type="html"><![CDATA[<p>极其糟糕的比赛体验，中文题面比 CF 的英文题面还要难以读懂。</p>
<p>赛后一直搞 T4 的瞎搞哈希做法，用了一整个晚自修。</p>
]]></summary>
        <content type="html"><![CDATA[<p>极其糟糕的比赛体验，中文题面比 CF 的英文题面还要难以读懂。</p>
<p>赛后一直搞 T4 的瞎搞哈希做法，用了一整个晚自修。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>题面有些迷，样例又出锅。</p>
<p>看懂题面后就好做了。</p>
<blockquote>
<p>就是要求一个最长不上升子序列，要求字典序最大。</p>
</blockquote>
<p>字典序最大的问题只需要反过来跑最长不下降子序列，更新的时候不把等号取上，然后正着找，等号也取上就行了。</p>
<h2 id="b">B</h2>
<p>简单的数学题。</p>
<blockquote>
<p>给出由 <code>abc?</code> 四个字符组成的字符串， <code>?</code> 可变为任意字符，问在所有的情况中子序列 <code>abc</code> 出现了几次。</p>
</blockquote>
<p>没有 <code>?</code> 的做法就左右记一下 <code>a</code> 和 <code>c</code> 的个数然后乘起来就可以了。</p>
<p>有 <code>?</code> 的就考虑定下一些 <code>?</code> 的字母，然后其它随便排就可以了。具体地，在找到 <code>b</code> 的时候把左边 <code>a</code> 的个数和右边 <code>?</code> 的个数乘起来再乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">3^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 就是以当前这个为中间，左边的 <code>a</code> 为左边，右边使用 <code>?</code> 在所有序列中出现的次数。</p>
<h2 id="c">C</h2>
<p>前两题都是签到题，现在开始略有难度(主要在读题)，原题是 CF980D。</p>
<p>其实不怪搬题人，洛谷的翻译过于糟糕了。分成的序列是可以不连续的，赛时按照连续的来做了。</p>
<p>两数相乘是平方数其实是由传递性的，很容易证明。</p>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo>∏</mo><msubsup><mi>a</mi><mi>i</mi><msub><mi>k</mi><mi>i</mi></msub></msubsup><mo separator="true">,</mo><mi>B</mi><mo>=</mo><mo>∏</mo><msubsup><mi>b</mi><mi>i</mi><msub><mi>m</mi><mi>i</mi></msub></msubsup><mo separator="true">,</mo><mi>C</mi><mo>=</mo><mo>∏</mo><msubsup><mi>c</mi><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">A = \prod a_i^{k_i}, B = \prod b_i ^ {m_i}, C = \prod c_i ^ {n_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.207872em;vertical-align:-0.276864em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.931008em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.026864em;vertical-align:-0.276864em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.026864em;vertical-align:-0.276864em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span>, 若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 是平方数，那么一定有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><msub><mi>k</mi><mi>i</mi></msub><mo>+</mo><msub><mi>m</mi><mi>i</mi></msub><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall i, k_i+m_i \equiv 0 \pmod 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61375em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, 同理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><msub><mi>n</mi><mi>i</mi></msub><mo>+</mo><msub><mi>m</mi><mi>i</mi></msub><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall i, n_i+m_i \equiv 0 \pmod 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61375em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, 所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><msub><mi>n</mi><mi>i</mi></msub><mo>≡</mo><msub><mi>k</mi><mi>i</mi></msub><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall i, n_i \equiv k_i\pmod 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \times C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 也是平方数。</p>
<p>那么就可以用并查集维护了，看一段子串中有几个不同集合就好了。</p>
<p>注意 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 不能参与上面运算，它可以放入任意集合，所以单独考虑。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 5005;
int n, a[N], fa[N], ans[N], map[N];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
bool check(int x, int y) {
	if(x * y &lt;= 0) return false;
	int an = sqrt(x*y);
	if(an * an == x * y) return true;
	else return false;
}
signed main() {
    scanf(&quot;%lld&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) fa[i] = i;
    for(int i = 1; i &lt;= n; i++) {
        scanf(&quot;%lld&quot;, &amp;a[i]);
        for(int j = 1; j &lt; i; j++)
            if(check(a[i], a[j]))  fa[find(i)] = find(j);
    }
    for(int i = 1; i &lt;= n; i++) {
        memset(map, 0, sizeof(map));
        int an = 0;
        for (int j = i; j &lt;= n; j++)
            if(a[j] == 0) ans[std::max(an, 1ll)]++;
            else {
                if(!map[fa[j]]) an++;
                map[fa[j]] = 1;
                ans[an]++;
            }
    }
    for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]);
    return 0;
}
</code></pre>
<h2 id="d">D</h2>
<p>原题是 [SDOI2008]Sandy的卡片。</p>
<p>题面可以转化为(作差以后)。</p>
<blockquote>
<p>求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个串的最长相同子串</p>
</blockquote>
<p>赛场上以为是要最长相同的相同子串，样例太水，还让我过了，居然有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>。</p>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n, m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span> 非常小，所以不用啥后缀自动机了，直接 dp 就好。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 是前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 串前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个且以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 结尾的最长相同子串， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 是相邻的两行前一行以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 结尾， 后一行以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 结尾的前面的最长相同子串。利用辅助的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 可以方便转移。</p>
<p>其实挺妙的，想不到用两个来维护转移。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#define int long long
const int N = 1005, INF = 0x3f3f3f3f3f3f3f3f;
int n, m, x, ans, g[N][N], f[N][N];
std::vector&lt;int&gt; a[N];
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%lld&quot;, &amp;m);
		for(int j = 1; j &lt;= m; j++) {
			scanf(&quot;%lld&quot;, &amp;x);
			a[i].push_back(x);
		}
		for(int j = (signed)a[i].size()-1; j &gt;= 1; j--) a[i][j] -= a[i][j-1]; 
	}
	for(int i = 1; i &lt; (signed)a[1].size(); i++) f[1][i] = INF;
	for(int i = 2; i &lt;= n; i++) {
		memset(g, 0, sizeof g);
		for(int j = 1; j &lt; (signed)a[i].size(); j++)
			for(int k =  1; k &lt; (signed)a[i-1].size(); k++)
				if(a[i][j] == a[i-1][k]) 
					g[j][k] = std::min(f[i-1][k], g[j-1][k-1] + 1),
					f[i][j] = std::max(f[i][j], g[j][k]);
	}
	for(int j = 1; j &lt; (signed)a[n].size(); j++)
		ans = std::max(ans, f[n][j]);
	printf(&quot;%lld&quot;, ans+1);
	return 0;
}
</code></pre>
<p>好，正戏收场，<strong>开始乱搞。</strong></p>
<p>赛时我按照错误的理解写了一个 <code>map</code> 做法，然后挂掉了，所以赛后我不甘心，一定要使用 <code>map</code> 来做。</p>
<p>如果把所有的子串直接用 <code>map</code> 来映射到它的长度，那肯定是要超时的，因为枚举所有子串用的总复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><msup><mi>m</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">nm^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> 了，再乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span> 再乘上移动串所需要的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的复杂度，显然超时。</p>
<p><strong>注意：</strong> <code>erase</code> 的时候不能直接 <code>erase</code> 因为 <code>map</code> 的迭代器不会自动跳到下一个，所以要写作 <code>erase(j++)</code> 先传进去，没删掉就到下一个，不然会 RE。</p>
<p><a href="https://www.luogu.com.cn/record/48778679">提交记录</a></p>
<p>氧气也救不了</p>
<p><a href="https://www.luogu.com.cn/record/48778698">吸氧的记录</a></p>
<p>代码如下。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#define int long long
const int N = 1005;
int n, m, x, ans;
typedef std::vector&lt;int&gt; twt;
twt a[N], hash;
std::map&lt;twt, int&gt; anst, t;
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%lld&quot;, &amp;m);
		for(int j = 1; j &lt;= m; j++) {
			scanf(&quot;%lld&quot;, &amp;x);
			a[i].push_back(x);
		}
		for(int j = (signed)a[i].size()-1; j &gt;= 1; j--) a[i][j] -= a[i][j-1]; 
		t.clear();
		for(int j = 1; j &lt; (signed)a[i].size(); j++) {
			hash.clear();
			for(int k = j; k &lt; (signed)a[i].size(); k++) {
				hash.push_back(a[i][k]);
				t[hash] = std::max(t[hash], k-j+1);
			}
		}  
		for(std::map&lt;twt, int&gt;::iterator j = anst.begin(); j != anst.end();)
			if(t[j -&gt; first] != 0) j -&gt; second = std::min(j -&gt; second, t[j -&gt; first]), j++;
			else anst.erase(j++);			
		if(i == 1) 
			for(std::map&lt;twt, int&gt;::iterator j = t.begin(); j != t.end(); j++) 
				anst[j -&gt; first] = j -&gt; second;
	}
	for(std::map&lt;twt, int&gt;::iterator j = anst.begin(); j != anst.end(); j++)
		ans = std::max(ans, j -&gt; second);
	printf(&quot;%lld&quot;, ans+1);
	return 0;
}
</code></pre>
<p>那么怎么办呢？我们难道要放弃这个伟大的做法吗？</p>
<p>不，上面的程序复杂度大主要在于要把整个串给存进去，那么我们先哈希一下再存进去不就可以避免这个问题了吗。</p>
<p>但在这题中似乎特别容易冲突，毕竟全是数，值域大，然而<a href="https://www.luogu.com.cn/record/48778790">单哈希过了</a>......</p>
<p>为了追求严谨，还是使用三哈希。</p>
<p>代码如下，其实就是重写了上面的 twt.</p>
<p>重写成这样:</p>
<pre><code class="language-cpp">struct twt {
	int h[T];
	void clear() {
		for(int i = 0; i &lt; T; i++) h[i] = 0;
	}
	void insert(int x) {
		for(int i = 0; i &lt; T; i++) h[i] = h[i] * ti[i] + x % mod[i];
	}
	bool operator &lt; (twt b) const {
		return h[0] &lt; b.h[0];
	}
} hash;
</code></pre>
<p>就好了，注意必须要重载严格弱序的 <code>&lt;</code>, 因为在红黑树中需要用到。</p>
<p><a href="https://www.luogu.com.cn/record/48760531">交了</a>发现 TLE on #5</p>
<p>吸口氧就过了。</p>
<p>我们知道主要复杂度在于 <code>map</code> (?), 所以使用传说中的 <code>unordered_map</code> 是不是就可以过了呢？</p>
<p>对于单哈希的那玩意儿，直接把 <code>map</code> 替换为 <code>unoredered_map</code> 就可以了，确实快了很多，但本地测试最慢的点仍然要 1.64s 还是过不了，在洛谷上不开 O2 就 TLE， <a href="https://www.luogu.com.cn/record/48778899">开了</a> 需要 545ms, <s>比暴力程序还要慢</s>。</p>
<p>那么对于三哈希的 twt, 如果你直接使用 <code>unordered_map</code> ，恭喜，会收到<a href="https://www.luogu.com.cn/record/48763002">一大坨 CE</a>, 因为 <code>unordered_map</code> 不知道该如何哈希 twt， 所以我们需要自定义哈希函数，并重载等号的运算，哈希函数需要写成伪函数的形式，最后就是这个样子的。</p>
<pre><code class="language-cpp">struct twt {
	int h[T];
	void clear()  {for(int i = 0; i &lt; T; i++) h[i] = 0; }
	void insert(int x) { for(int i = 0; i &lt; T; i++) h[i] = h[i] * ti[i] + x % mod[i]; }
	bool operator == (twt b) const {	return h[0] == b.h[0] &amp;&amp; h[1] == b.h[1] &amp;&amp; h[2] == b.h[2]; }
} hash;
struct hashf{
	size_t operator() (twt a) const {
		return (unsigned) a.h[0] + a.h[1] + a.h[2];
	} 
};
std::unordered_map&lt;twt, int, hashf&gt; anst, t;
</code></pre>
<p><s>hash 到最后又合成了一个，这三哈希了个寂寞。</s></p>
<p>其实说了那么多，就是想普及一下 <code>unordered_map</code> 的用法。</p>
<p>但遗憾的是 <code>unordered_map</code> 不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的，仍然过不了，开了 O2 也一样........</p>
<hr>
<p>这场主要难度在于读题的比赛其实对我的帮助在于普及了 <code>unordered_map</code>  和 <code>map.erase()</code>的用法......</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [2019 ICPC 上海网络赛] Lighting Routing I]]></title>
        <id>https://acfboy.pw/lightingrouting/</id>
        <link href="https://acfboy.pw/lightingrouting/">
        </link>
        <updated>2021-03-31T00:26:37.000Z</updated>
        <summary type="html"><![CDATA[<p><s>封面图是随便找的真实的 Lighting Routing</s></p>
<p>据说这题有神奇的 LCT 和 树套树 的做法，很可惜，我都不会。</p>
<p>于是搞了一个用欧拉序来维护直径的做法，搭配线段树和倍增 LCA 来解决这题。</p>
]]></summary>
        <content type="html"><![CDATA[<p><s>封面图是随便找的真实的 Lighting Routing</s></p>
<p>据说这题有神奇的 LCT 和 树套树 的做法，很可惜，我都不会。</p>
<p>于是搞了一个用欧拉序来维护直径的做法，搭配线段树和倍增 LCA 来解决这题。</p>
<!-- more -->
<blockquote>
<p>支持边的修改操作，每次询问树上离一个点最远的点和它的距离。</p>
</blockquote>
<p>我们知道从树上任意一个点出发，能到达的最远的点一定是树的直径的一个端点，所以这题也就是要动态维护树的直径，然后求一下距离就可以了。</p>
<p>那么怎么维护树的直径呢？这里介绍一下一个神奇的做法，欧拉序。</p>
<p>欧拉序是一个类似 DFS 序的东西，不同的是，欧拉序在遍历完一个点的子树的时候还会把这个点加入欧拉序中，相当于一个人沿 DFS 的顺序走完树上所有点的路径。欧拉序的长度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 因为每一条边两个端点都要算一次，最后退出的时候根节点过算了一次。</p>
<p>求得欧拉序的代码, 其中 <code>pos[(i+1)/2] = v</code> 是将输入边的编号和指向的点对应起来，因为是双向建边的，所以要除以二上取整。而且这样子给这条边定的指向的点是以我们定的根为根的，这个处理其实挺妙。</p>
<p><code>tin</code> 和 <code>tout</code> 用来记录一个子树在欧拉序中的起点和终点。</p>
<pre><code class="language-cpp">void dfs(int u, int fa) {
	dfn[++tot] = u; tin[u] = tot;
	for(int i = head[u]; i; i = next[i]) {
		int v = vet[i];
		if(v == fa) continue;
		pos[(i+1)/2] = v, dep[v] = dep[u] + len[i];
		dfs(v, u);
		dfn[++tot] = u;
	}
	tout[u] = tot;
}
</code></pre>
<p>那么使用欧拉序有什么好处呢？</p>
<p>在两个点的欧拉序之间，深度最小的一定就是它们的 LCA 了，这很好理解，因为欧拉序就是走过每一个点的路径嘛，你要走过两个点，肯定是要先到一个，然后退出来，再接着到第二个。这样就把 LCA 的问题转换成了 RMQ 问题。因为欧拉序也具有 dfs 序子树都在一起的性质，所以给一条边的边权加上一个数就是给一段区间的 <code>dep</code> 都加上一个数。</p>
<p>然后考虑在欧拉序上维护直径。</p>
<p>我们在树形 DP 求直径的时候是到每一个点把它们最深的两个拼在了一起，链的长度是两个点的距离，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>x</mi></msub><mo>+</mo><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>y</mi></msub><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><msub><mi>p</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dep_x + dep_y - 2dep_{lca}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，经过每一个点时，就是要让这个东西最大，或者直接采用下面的答案。</p>
<p>可以用线段树来维护这样几个东西。</p>
<ul>
<li>最大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span></span></span></span>, 记作 <code>maxd</code></li>
<li>最大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><msub><mi>p</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">-2dep_{lca}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 记作 <code>vlca</code></li>
<li>最大的左边和中间拼起来的，即最大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>x</mi></msub><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><msub><mi>p</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dep_x - 2dep_{lca}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 记作 <code>lm</code></li>
<li>同理 <code>mr</code></li>
<li>还有当前子树的直径 <code>lmr</code></li>
</ul>
<p>因为一段欧拉序代表的都是树的一部分，所以可以这样来维护，也可以合并。<br>
<code>pushup</code> 的时候 <code>maxd</code> 和 <code>vlca</code> 显然都是子树取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop">max</span></span></span></span> 就可以了，<code>lm</code> 要考虑左边的 <code>maxd</code> 和 <code>vlca</code> 拼成或直接用下面的答案，<code>mr</code> 同理， <code>lmr</code> 要考虑直接用下面的答案或左边的 <code>lm</code> 拼右边的 <code>maxd</code> 或者右边的 <code>mr</code> 配左边的 <code>maxd</code>。</p>
<p>但这样怎么记录方案呢？我们可以参考 dp 的时候记录方案的做法，从哪边转移过来就继承哪边的结果。然后我们就可以得到以下的 <code>pushup</code> 代码。</p>
<pre><code class="language-cpp">void pushUp(int p) {
	maxd[p] = std::max(maxd[p+p], maxd[p+p+1]);
	vlca[p] = std::max(vlca[p+p], vlca[p+p+1]);
	lm[p] = std::max(std::max(lm[p+p], lm[p+p+1]), maxd[p+p] + vlca[p+p+1]);
	mr[p] = std::max(std::max(mr[p+p], mr[p+p+1]), vlca[p+p] + maxd[p+p+1]);
	lmr[p] = std::max(std::max(lmr[p+p], lmr[p+p+1]), std::max(lm[p+p]+maxd[p+p+1], maxd[p+p]+mr[p+p+1]));
	
	if(maxd[p] == maxd[p+p]) vd[p] = vd[p+p];
	else vd[p] = vd[p+p+1];
	
	if(lm[p] == lm[p+p]) vl[p] = vl[p+p];
	else if(lm[p] == lm[p+p+1]) vl[p] = vl[p+p+1];
	else vl[p] = vd[p+p];
	
	if(mr[p] == mr[p+p]) vr[p] = vr[p+p];
	else if(mr[p] == mr[p+p+1]) vr[p] = vr[p+p+1];
	else vr[p] = vd[p+p+1];
	
	if(lmr[p] == lmr[p+p]) s[p] = s[p+p], t[p] = t[p+p];
	else if(lmr[p] == lmr[p+p+1]) s[p] = s[p+p+1], t[p] = t[p+p+1];
	else if(lmr[p] == lm[p+p] + maxd[p+p+1]) s[p] = vl[p+p], t[p] = vd[p+p+1];
	else s[p] = vd[p+p], t[p] = vr[p+p+1];
}
</code></pre>
<p>这是整道题的核心。</p>
<p>剩下的部分就是普通的线段树以及求两点间距离了(线段树中单个点的 <code>maxd</code> 其实就是 <code>dep</code>)， 不难实现， 要注意区分欧拉序编号和原始编号，我为这个调了很久。</p>
<p><a href="https://vjudge.net/solution/30295703">完整代码链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [ICPC2014 牡丹江区域赛] Building Fire Station]]></title>
        <id>https://acfboy.pw/gym10054b/</id>
        <link href="https://acfboy.pw/gym10054b/">
        </link>
        <updated>2021-03-30T07:07:00.000Z</updated>
        <summary type="html"><![CDATA[<p>题目来源的原文是 <code>2014 ACM-ICPC Asia Mudanjiang Regional Contest</code>, 大概就叫这个名字了。</p>
<p>这题考察了对树直径的性质的理解和运用，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n \log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的二分做法，但是巧妙运用性质就可以做到线性。</p>
]]></summary>
        <content type="html"><![CDATA[<p>题目来源的原文是 <code>2014 ACM-ICPC Asia Mudanjiang Regional Contest</code>, 大概就叫这个名字了。</p>
<p>这题考察了对树直径的性质的理解和运用，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n \log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的二分做法，但是巧妙运用性质就可以做到线性。</p>
<!-- more -->
<blockquote>
<p>在树上标记两个点，使树上点到最近的标记点的距离最大的最小</p>
</blockquote>
<p>看到最大值最小，很快想到二分，二分确实也可以做，但这有一种奇妙的做法可以让它变成线性。</p>
<p>在讲树的直径的时候肯定已经证明过，树上离一个点距离最远的点一定是直径的一个端点，由这个性质我们很容易可以得到直径旁边伸出去的枝节一定没有直径深，所以如果标记的点在那些枝节上，把它靠近直径移动不会使它离它的最长点变长，而会使它到直径端点的距离变短，所以标记一定在树的直径上。</p>
<p>有了这个结论，只要把直径劈成两半，然后在两边求中心就可以了。仔细想想为什么，还是很妙的。</p>
<p>注意是中心，不是重心。</p>
<p>求中心的方法可以借鉴我 CodeChef 一道题的题解。至于劈开树，只需要在 dfs 开始的时候把父亲设为不能去的隔壁那个就可以了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
const int N = 200005, F = 1, INF = 0x3f3f3f3f;
int TWT, n, x, y, S, T, ans, ansu1, ansu2, anss, dep[N], size[N], pre[N], up[N], down[N], maxL;
std::vector&lt;int&gt; g[N], d;
void init() {
	for(int i = 0; i &lt; N; i++) g[i].clear();
	memset(dep, 0, sizeof dep);
	d.clear();
}
void dfs(int u, int fa, int opt) {
	if(opt == F &amp;&amp; dep[u] &gt; dep[S]) S = u;
	else if(opt != F &amp;&amp; dep[u] &gt; dep[T]) T = u;
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		dep[v] = dep[u] + 1;
		dfs(v, u, opt);
	}
}
void color(int u, int fa) {
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		color(v, u);
		pre[v] = u;
	}
}
void getdown(int u, int fa) {
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		getdown(v, u);
		down[u] = std::max(down[u], down[v] + 1);
	}
}
void getup(int u, int fa) {
	int max = -1, sax = -1;
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		if(down[v] + 1 &gt; max) sax = max, max = down[v] + 1;
		else if(down[v] + 1 &gt; sax) sax = down[v] + 1;
	}
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		up[v] = std::max(up[u] + 1, (max == down[v]+1) ? (sax+2) : (max+2));
		getup(v, u);
	}
}
void getans(int u, int fa, int &amp;ans) {
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		getans(v, u, ans);
	}
	int max = std::max(down[u], up[u]);
	if(max &lt; maxL) maxL = max, ans = u;
}
void findCe(int u, int fa, int &amp;ans) {
	maxL = 0x3f3f3f3f;
	memset(up, 0, sizeof up);
	memset(down, 0, sizeof down);
	getdown(u, fa);
	getup(u, fa);
	getans(u, fa, ans);
}
int main() {
	scanf(&quot;%d&quot;, &amp;TWT);
	while(TWT--) {
		init();
		scanf(&quot;%d&quot;, &amp;n);
		for(int i = 1; i &lt; n; i++) {
			scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
			g[x].push_back(y), g[y].push_back(x);
		}
		dfs(1, 0, F);
		memset(dep, 0, sizeof dep); 
		dfs(S, 0, !F);
		color(S, 0);
		for(int i = T; i != S; i = pre[i]) d.push_back(i);
		d.push_back(S);
		findCe(d[d.size() / 2], d[d.size()/2-1], ansu2);
		findCe(d[d.size() / 2 - 1], d[d.size()/2], ansu1);
		ans = std::max(dep[T] - dep[ansu1], 
		      std::max(dep[ansu2], 
		      std::max(dep[ansu1] - dep[d[d.size()/2-1]], 
		      		   dep[d[d.size()/2]] - dep[ansu2])));
		printf(&quot;%d %d %d&quot;, ans, ansu1, ansu2);
		if(TWT != 0) puts(&quot;&quot;);
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CodeChef-DTREE]]></title>
        <id>https://acfboy.pw/codechef-dtree/</id>
        <link href="https://acfboy.pw/codechef-dtree/">
        </link>
        <updated>2021-03-29T11:54:26.000Z</updated>
        <summary type="html"><![CDATA[<p>考验对数的直径的 dp 做法变形处理的好题目。</p>
]]></summary>
        <content type="html"><![CDATA[<p>考验对数的直径的 dp 做法变形处理的好题目。</p>
<!-- more -->
<blockquote>
<p>给定一棵树，求去掉一个点构成的森林中树的直径的最大值，输出对于对于每一个点，去掉它的结果。</p>
</blockquote>
<p>先想一想我们原来求树的直径的做法是怎么样的，能求出些什么。</p>
<p>原来就是找出一个点向下最深的和次深的将它们连在一起，找出最大的。所以我们用原来的做法，假设删掉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>, 可以很容易地求出它的所有儿子所在子树的直径，以及它们的最大值，所以现在只需要考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 向上的子树的直径怎么计算。</p>
<p>上面的直径没有办法直接计算，那么考虑它有哪些可能。参考原来的做法，可以想到从一个点的父亲出发一条向上的链再和经过这个点的父亲的某条向下的链可能可以拼成上面树的直径。所以先考虑向上的最长的链怎么求。</p>
<p>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><msub><mi>p</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">up_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 为起点向上最长的链的长度，可得一种情况是直接由原来向上的加一拼接而成，另一种情况是在这个点父亲那点转向了下方。如图，注意 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 指的是要更新点的父亲。</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cCz5dA"><img src="https://z3.ax1x.com/2021/03/29/cCz5dA.png" alt="cCz5dA.png" loading="lazy"></a></figure>
<p>那么这条链当然是要和经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 号点的另一条链拼成的，所以我们需要记录除了父亲到当前点所在子树以外的最长的链和它拼在一起。</p>
<p>当然，也有可能不向上延伸，就是当前点兄弟子树向下的最大直径，或上面本来就有的直径。</p>
<p>还有可能是经过当前点的父亲拼起来的两条向下的最大的链。</p>
<p>把它们画在一起就是这个样子的。</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/cP9MrD"><img src="https://z3.ax1x.com/2021/03/29/cP9MrD.png" alt="cP9MrD.png" loading="lazy"></a></figure>
<p>然后再用下面的更新就可以了。</p>
<p>因为枚举的点是要空出来的，所以我们用当前点计算出来的一堆值其实是更新下面的点用的。</p>
<p>注意判断当前的这个子树是 最大/次大 的情况，选其它的最大和次大不能把当前选进去，所以还需要取出 次次大，在最大或次大被占用时作为次大使用。</p>
<p>代码。</p>
<p>注意代码中向下的深度 最大/次大/次次大 值初值都为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 是因为下面都计算了它们的根到当前点的连边，找不到的时候一加上恰好为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 而下面原有的子树(即 <code>maxf</code>) 初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 因为它们不需要有加上的运算，而是直接使用。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
const int N = 100005;
int T, n, x, y, ans[N], down[N], f[N], up[N];
std::vector&lt;int&gt; g[N];
void init() {
	memset(down, 0, sizeof down);
	memset(up, 0, sizeof up);
	memset(f, 0, sizeof f);
	memset(ans, 0, sizeof ans);
	for(int i = 1; i &lt; N; i++) g[i].clear();
}
void update2(int x, int &amp;max, int &amp;sax) {
	if(x &gt; max) sax = max, max = x;
	else if(x &gt; sax) sax = x;
}
void update3(int x, int &amp;max1, int &amp;max2, int &amp;max3) {
	if(x &gt; max1) max3 = max2, max2 = max1, max1 = x;
	else if(x &gt; max2) max3 = max2, max2 = x;
	else if(x &gt; max3) max3 = x;
}
void dfs1(int u, int fa) {
	int max = 0, sax = -1;
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		dfs1(v, u);
		update2(down[v]+1, max, sax);
		f[u] = std::max(f[u], f[v]);
	}
	down[u] = max;
	f[u] = std::max(f[u], max + sax);
}
void dfs2(int u, int fa) {
	int maxd1 = -1, maxd2 = -1, maxd3 = -1,
		maxf1 = 0, maxf2 = 0;
	int tmp = ans[u]; // 记下仅上面部分的答案，以便更新需要
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		ans[u] = std::max(ans[u], f[v]);
		update3(down[v], maxd1, maxd2, maxd3);
		update2(f[v], maxf1, maxf2);
	}
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		up[v] = std::max(up[u] + 1, (down[v] == maxd1) ? maxd2 + 2 : maxd1 + 2); // 求出向上的最长链
		ans[v] = tmp; // 上面本来就有的 
		ans[v] = std::max(ans[v], (f[v] == maxf1) ? maxf2 : maxf1); // 兄弟本来就有的情况
		ans[v] = std::max(ans[v], (down[v] == maxd1) ? (maxd2 + up[u] + 1) : (up[u] + maxd1 + 1)); // 上下拼起来的情况
		if(down[v] == maxd1) ans[v] = std::max(ans[v], maxd2 + maxd3 + 2); 
		else if(down[v] == maxd2) ans[v] = std::max(ans[v], maxd1 + maxd3 + 2);
		else ans[v] = std::max(ans[v], maxd1 + maxd2 + 2);
      // 经过这点下面的链拼起来的情况
		dfs2(v, u);
	}
}
int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T--) {
		init();
		scanf(&quot;%d&quot;, &amp;n);
		for(int i = 1; i &lt; n; i++) {
			scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
			g[x].push_back(y), g[y].push_back(x);
		}
		dfs1(1, 0);
		dfs2(1, 0);
		for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]);
		puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AtCoder Regular Contest 116 游记]]></title>
        <id>https://acfboy.pw/arc116/</id>
        <link href="https://acfboy.pw/arc116/">
        </link>
        <updated>2021-03-29T03:38:41.000Z</updated>
        <summary type="html"><![CDATA[<p>本想着要做四道的，结果第三题也做不出来......</p>
]]></summary>
        <content type="html"><![CDATA[<p>本想着要做四道的，结果第三题也做不出来......</p>
<!-- more -->
<h2 id="a">A</h2>
<p>好题目。</p>
<blockquote>
<p>输入一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, 求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的奇数因子多还是偶数因子多。</p>
</blockquote>
<p>乍一看还是没有什么头绪的，似乎是个数论题。数据范围有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>, 又有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 个询问，根号的做法显然不行， 只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span> 的做法能过了。</p>
<p>我们知道偶因子就是带有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 因子的因子(废话)，那奇数因子的数量就是去掉所有带有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 因子的因子数啦。我们记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 去掉所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 因子后剩下的数，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">k | n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span><span class="mord mathdefault">n</span></span></span></span>, 所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的因子也是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的因子。</p>
<p>来构造偶数因子，设有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, 那么每个奇数因子都可以乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1...</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">1...x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">x</span></span></span></span>  个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 变成偶因子，所以偶因子的数量就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的因子数，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的因子数就是所有奇数因子的数量，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x &lt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就是奇数因子多， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就是一样多， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就是偶数因子多。</p>
<h2 id="b">B</h2>
<blockquote>
<p>输入序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, 求所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的子序列最大值和最小值积的和。</p>
</blockquote>
<p>若一个最大值和最小值确定了，则中间的取不取都可以，所以可以想到排个序，然后答案就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>j</mi></msub><mo>×</mo><msub><mi>a</mi><mi>i</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>a</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n-1} \sum_{j=i+1}^n a_j \times a_i \times 2^{j-i-1} + \sum_{i=1}^n a_i^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.2148900000000005em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.957994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>后面一部分非常好求，考虑前面一部分怎么求。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 无关，可以提到前面来。 式子变成了</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo fence="true">(</mo><msub><mi>a</mi><mi>i</mi></msub><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>j</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n-1} \left( a_i\sum_{j=i+1}^n a_j  \times 2^{j-i-1}\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.2148900000000005em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span></span></span></span></span></p>
<p>只要考虑如何快速求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>j</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{j=i+1}^n a_j  \times 2^{j-i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 就可以了。</p>
<p>可以预处理出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的结果，然后每次只需要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 减掉，后面的一堆东西除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 就好了。</p>
<p>感觉还是很好的题。</p>
<h2 id="c">C</h2>
<blockquote>
<p>求长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, 每个数都不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的，后一个数是前一个数的倍数的序列个数。</p>
</blockquote>
<p>把半个小时过了两题之后，我就把剩下的时间都花在这题上了。</p>
<p>开始以为不能重复，所以直接算一下就好了，一看样例发觉不对。</p>
<p>一看这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2\times 10^ 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 的数据就想到是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">n\sqrt n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord mathdefault">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>  的做法，但能一下想到的只有一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 状态， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span> 转移的糟糕 dp, 这个 dp 显然没有前途，因为状态一枚举就超时了。</p>
<p>又因为一个数后面能跟几个和它在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 以内的倍数个数有关，所以想到了数论分块，企图优化这个状态，但这还是一条死路，因为状态虽然可以，但转移做不到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, 因为转移可以到很多块中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">It’s</mtext><mtext> </mtext><mtext mathvariant="monospace">another</mtext><mtext> </mtext><mtext mathvariant="monospace">dead</mtext><mtext> </mtext><mtext mathvariant="monospace">end.</mtext></mrow><annotation encoding="application/x-tex">\texttt{It&#x27;s another dead end.}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">It’s another dead end.</span></span></span></span></span>(飞友知道我在说什么)</p>
<p>然后放弃了 dp 的想法，转而观察性质，未果。比赛就结束了。</p>
<p><strong>来看正确做法</strong></p>
<p>其实注意到最初的想法，如果不能重复会怎么样，那就好做了，因为长度枚举一个最后值， 长度肯定不能超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>m</mi></mrow><annotation encoding="application/x-tex">\log_2 m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span> (因为从两倍开始), 不然铁定超啊。</p>
<p>再考虑如何用这个得到最后的答案。</p>
<p>其实很简单，解决重复，只要把不重复的在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 中的几个位置放上，然后剩下的都用相同的填上就可以了。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 是长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的，最后一个为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的，各不相同的方案数。</p>
<p>答案就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>×</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\sum C_{n-1}^{i-1} \times f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1894339999999999em;vertical-align:-0.324639em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864795em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>代码如下。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define int long long
const int M = 200005, p = 998244353;
int n, m, f[20][M], fac[M], inv[M], ans;
int Pow(int a, int b) {
	int an = 1;
	while(b) {
		if(b &amp; 1) an = an * a % p;
		a = a * a % p;
		b &gt;&gt;= 1;
	}
	return an;
}
int C(int n, int m) {
	if(n &lt; m) return 0;
	return fac[n] * inv[m] % p * inv[n-m] % p;
}
void init(int n) {
	fac[0] = 1;
	for(int i = 1; i &lt;= n; i++) fac[i] = fac[i-1] * i % p;
	inv[n] = Pow(fac[n], p-2);
	for(int i = n; i &gt;= 1; i--) inv[i-1] = inv[i] * i % p;
}
signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	init(n);
	for(int i = 1; i &lt;= m; i++) f[1][i] = 1;
	for(int i = 1; i &lt;= 18; i++) 
		for(int j = 1; j &lt;= m; j++)
			for(int k = 2*j; k &lt;= m; k += j)
				f[i+1][k] = (f[i+1][k] + f[i][j]) % p;
	for(int i = 1; i &lt;= std::min(18ll, n); i++)	
		for(int j = 1; j &lt;= m; j++)
			ans = (ans + f[i][j] * C(n-1, i-1)) % p;
	printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
<h3 id="后记">后记</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 月 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 日有 AGC, 但恐怕又打不了了呜呜。</p>
<p>其实第三题这想法听了后也不是很难，好好练习，下次加油吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AtCoder Beginner Contest 197 游记]]></title>
        <id>https://acfboy.pw/abc197/</id>
        <link href="https://acfboy.pw/abc197/">
        </link>
        <updated>2021-03-28T00:26:29.000Z</updated>
        <summary type="html"><![CDATA[<p>又是典型的前四题一下就过，第五题卡死到最后都没有做出来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>又是典型的前四题一下就过，第五题卡死到最后都没有做出来。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cSBZct"><img src="https://z3.ax1x.com/2021/03/28/cSBZct.png" alt="cSBZct.png" loading="lazy"></a></figure>
<p>赛后看了题解过了第五题，居然是 DP, 赛时一直想着贪心...... 主要是一个性质没有利用好。</p>
<h3 id="a">A</h3>
<p>大水题，一分钟暴切。</p>
<h3 id="b">B</h3>
<p>大水题</p>
<h3 id="c">C</h3>
<p>乍一看好难，一看数据范围，直接搜索。</p>
<h3 id="d">D</h3>
<p>用旋转的公式，先将旋转中心平移到原点，然后旋转完再平移回去。</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/cSBejP"><img src="https://z3.ax1x.com/2021/03/28/cSBejP.png" alt="cSBejP.png" loading="lazy"></a></figure>
<p>记住 <code>math</code> 库中的三角函数是弧度制的。</p>
<h3 id="e">E</h3>
<p>一看以为是贪心，按照某种神奇的方式排个序就好了。</p>
<p>想到过 DP，但一看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 的数据范围，觉得 1D / 0D 不太现实，就继续回去贪心。</p>
<p>看了题解，发现确实不是 1D/0D，但确实是 DP。</p>
<p>有一个性质决定了它可以 DP， 这个性质其实挺贪心的，<strong>每一种 ID 一定是停在最左或最右</strong>， 我想贪心的时候，确实也想到了类似的结论，但却从没有想过要用它来 DP。</p>
<p>既然有了这个结论，那么只停在 左边/右边 这个状态就方便记录了，而且显然有最优子结构性质，也没有后效性，容易转移。</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define int long long
const int N = 200005, INF = 0x3f3f3f3f3f3f3f3fll;
int n, l[N], r[N], cnt, pre, f[N][2];
struct twt {
    int x, c;
} a[N];
signed main(){
    scanf(&quot;%lld&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) {
        scanf(&quot;%lld%lld&quot;, &amp;a[i].x, &amp;a[i].c);
        l[i] = INF, r[i] = -INF;
    }
    for(int i = 1; i &lt;= n; i++) {
        l[a[i].c] = std::min(l[a[i].c], a[i].x);
        r[a[i].c] = std::max(r[a[i].c], a[i].x);
    }
    for(int i = 1; i &lt;= n; i++) {
        if(l[i] == INF) continue;
        cnt++;
        f[cnt][0] = std::min(f[cnt-1][0] + abs(l[pre] - r[i]), f[cnt-1][1] + abs(r[pre]-r[i])) + abs(r[i] - l[i]);
        f[cnt][1] = std::min(f[cnt-1][0] + abs(l[pre] - l[i]), f[cnt-1][1] + abs(r[pre]-l[i])) + abs(r[i] - l[i]);
        pre = i;
    }
	printf(&quot;%lld&quot;, std::min(f[cnt][0] + abs(l[pre]), f[cnt][1]+abs(r[pre])));
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3.26 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/20210326/</id>
        <link href="https://acfboy.pw/20210326/">
        </link>
        <updated>2021-03-26T07:02:23.000Z</updated>
        <summary type="html"><![CDATA[<p>完完全全 PJ 难度的比赛，居然给我玩炸了.......</p>
<p>大概就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 分钟前两道，T3 是有些恶心的大模拟，写了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mtext mathvariant="sans-serif">h</mtext><mn>40</mn><mtext mathvariant="sans-serif">min</mtext></mrow><annotation encoding="application/x-tex">1\textsf{h} 40\textsf{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord text"><span class="mord textsf">h</span></span><span class="mord">4</span><span class="mord">0</span><span class="mord text"><span class="mord textsf">min</span></span></span></span></span>，结果还挂在了俩傻傻的问题上。 T4 一道巧妙的题，但模拟样例时想歪了，最后没有做出来。所以赶紧写游记，下次不能再犯这样的错误了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>完完全全 PJ 难度的比赛，居然给我玩炸了.......</p>
<p>大概就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 分钟前两道，T3 是有些恶心的大模拟，写了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mtext mathvariant="sans-serif">h</mtext><mn>40</mn><mtext mathvariant="sans-serif">min</mtext></mrow><annotation encoding="application/x-tex">1\textsf{h} 40\textsf{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord text"><span class="mord textsf">h</span></span><span class="mord">4</span><span class="mord">0</span><span class="mord text"><span class="mord textsf">min</span></span></span></span></span>，结果还挂在了俩傻傻的问题上。 T4 一道巧妙的题，但模拟样例时想歪了，最后没有做出来。所以赶紧写游记，下次不能再犯这样的错误了。</p>
<!-- more -->
<p>只讲 T3 &amp; T4.</p>
<h2 id="t3">T3</h2>
<p><a href="https://www.luogu.com.cn/problem/P2749">原题传送门</a></p>
<p>考虑如何判断相似的情况，暴力的做法是要判断四次旋转和一个镜像共八种，但当然不会去真的旋转，不同的方向只是角度的不同，循环的时候变一下顺序就可以了。</p>
<p>暴力判断会超时，我没有想到题解中的神奇定理，于是大力哈希了，将每个块抠出来，每行分开拼成一个二进制数。但这样是错的，如下面这种情况。</p>
<pre><code class="language-plain">11
11
</code></pre>
<p>二进制是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1111</mn></mrow><annotation encoding="application/x-tex">1111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>， 和 <code>1111</code> 的哈希值是一样的。为了解决这个问题，随便在换行的时候做点什么即可，如果您担心其它的重复，只要上多次哈希就好了，赛场上我写了三哈希，如果不是错误的哈希做法，这样重复的概率大概是很小的。</p>
<p>染色的时候我本来想着反正也染了就不用来判重复了吧，但遗憾的是，不行。</p>
<p>如这样子的数据。</p>
<pre><code class="language-plain">1111
1111
1111
1111
...
1111
1111
</code></pre>
<p>就会被大量地重复塞入，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 塞入了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, 但先走到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, 然后再次塞入了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，这样会有大量的重复，最终超时和超空间。</p>
<p>代码总长度达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>180</mn></mrow><annotation encoding="application/x-tex">180</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">0</span></span></span></span> 行。但模块化做的非常的好 <s>自卖自夸</s> 思路特别的清晰。</p>
<p>大概理一下思路(来自赛场草稿)：</p>
<ol>
<li>遍历</li>
<li>抠出图形
<ol>
<li>bfs 找出联通的和起始块的相对位置</li>
<li>修正坐标，让最小的 横/纵 都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ol>
</li>
<li>哈希
<ol>
<li>包括镜像的共八个方向处理</li>
<li>三个模数都跑一遍</li>
<li>对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 个哈希值排序，以处理不同方向读到顺序不同的情况</li>
</ol>
</li>
<li>比较
<ol>
<li>如果前面没有就新开一个</li>
<li>染色</li>
</ol>
</li>
</ol>
<p>因为最多星座不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>26</mn></mrow><annotation encoding="application/x-tex">26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span></span></span></span> 所以时间复杂度是对的。</p>
<p>主程序（没什么东西，就是遍历一遍，如果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 就执行上面的操作）：</p>
<pre><code class="language-cpp">int main() {
	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
	for(int i = 1; i &lt;= n; i++) 
		scanf(&quot;%s&quot;, map[i]+1);
	for(int i = 1; i &lt;= n; i++) 
		for(int j = 1; j &lt;= m; j++) 
			if(map[i][j] == '1') doit(i, j);
	for(int i = 1; i &lt;= n; i++) {
		for(int j = 1; j &lt;= m; j++) putchar(map[i][j]);
		putchar('\n');
	}
	return 0;
} 
</code></pre>
<p>然后是 <code>doit</code> 函数, 各个函数都是字面意思，就是把上面所说的给组织了一下。</p>
<pre><code class="language-cpp">void doit(int i, int j) {
	int x = 0, y = 0;
	getClu(i, j, x, y);
	twt a = hashClu(x, y);
	int pos = findClu(a);
	if(pos == -1) {
		clusters.push_back(a);
		pos = ++totC; 
	}
	Color(i, j, pos + 'a' - 1);
	initClu(x, y);
}
</code></pre>
<p>再看 <code>getClu</code>，同样没有什么东西</p>
<pre><code class="language-cpp">void getClu(int sx, int sy, int &amp;n, int &amp;m) {
	bfs(sx, sy);
	revize(n, m);
}
</code></pre>
<p>相信 <code>bfs</code> 很容易实现，来看 <code>revize</code>, 修正也很简单，就是找到最小的然后都加上它和一的差。</p>
<pre><code class="language-cpp">void revize(int &amp;n, int &amp;m) {
	n = 0, m = 0;
	int minx = 0, miny = 0;
	for(int i = 0; i &lt; (signed)tmp.size(); i++) {
		minx = std::min(minx, tmp[i].x);
		miny = std::min(miny, tmp[i].y);
	}
	int deltaX = 1 - minx, deltaY = 1 - miny;
	for(int i = 0; i &lt; (signed)tmp.size(); i++) {
		int x = tmp[i].x + deltaX, y = tmp[i].y + deltaY;
		clu[x][y] = rclu[x][y] = 1;
		n = std::max(n, x), m = std::max(m, y);
	} 
	for(int i = 1; i &lt;= n; i++) std::reverse(rclu[i]+1, rclu[i]+1+m);
}
</code></pre>
<p>再看 <code>hashClu</code>, 这里我们需要把八个东西都哈希一遍。最后记得排序， <code>hash1-4</code> 就是四种不同的方向， <code>Z</code> 是正，<code>F</code> 是反。也不难写，是吧。</p>
<pre><code class="language-cpp">twt hashClu(int n, int m) {
	twt an;
	for(int i = 1; i &lt;= 3; i++) { // 三哈希！
		an.insert(i, hash1(Z, n, m, i)), an.insert(i, hash1(F, n, m, i));
		an.insert(i, hash2(Z, n, m, i)), an.insert(i, hash2(F, n, m, i));
		an.insert(i, hash3(Z, n, m, i)), an.insert(i, hash3(F, n, m, i));
		an.insert(i, hash4(Z, n, m, i)), an.insert(i, hash4(F, n, m, i));
	} 
	an.Sort();
	return an; 
}
</code></pre>
<p><code>hash</code> 是要注意的，四种方向不是转换一个轴就可以的，赛场上我还因此而调试了一会儿，要根据实际的旋转情况定顺序，确保相似的图形遍历到每个元素的顺序都是一样的，处理行，我使用了乘十。</p>
<pre><code class="language-cpp">int hash1(int opt, int n, int m, int p) {
	p = mods[p];
	long long an = 0;
	for(int i = 1; i &lt;= n; i++) {
		for(int j = 1; j &lt;= m; j++) 
			if(opt == Z) an = (an * 2ll + (long long) clu[i][j]) % (long long) p;
			else an = (an * 2ll + (long long) rclu[i][j]) % (long long) p;
		an = an * 10 % p;		
	}
	return an;
}
int hash2(int opt, int n, int m, int p) {
	p = mods[p];
	long long an = 0;
	for(int i = n; i &gt;= 1; i--) {
		for(int j = m; j &gt;= 1; j--) 
			if(opt == Z) an = (an * 2ll + (long long) clu[i][j]) % (long long) p;
			else an = (an * 2ll + (long long) rclu[i][j]) % (long long) p;
		an = an * 10 % p;
	}
	return an;
}
int hash3(int opt, int n, int m, int p) {
	p = mods[p];
	long long an = 0;
	for(int j = 1; j &lt;= m; j++) {
		for(int i = n; i &gt;= 1; i--)
			if(opt == Z) an = (an * 2ll + (long long) clu[i][j]) % (long long) p;
			else an = (an * 2ll + (long long) rclu[i][j]) % (long long) p;
		an = an * 10 % p;
	}
	return an;
}
int hash4(int opt, int n, int m, int p) {
	p = mods[p];
	long long an = 0;
	for(int j = m; j &gt;= 1; j--) {
		for(int i = 1; i &lt;= n; i++)
			if(opt == Z) an = (an * 2ll + (long long) clu[i][j]) % (long long) p;
			else an = (an * 2ll + (long long) rclu[i][j]) % (long long) p;
		an = an * 10 % p;
	}
	return an;
}
</code></pre>
<p>然后是简单的查找和染色，没有什么好说的。</p>
<p>最后是一堆同样重要的定义。</p>
<pre><code class="language-cpp">const int N = 105, Z = 123, F = 321;
char map[N][N];
int clu[N][N], rclu[N][N], vis[N][N], n, m, totC, vis2[N][N];
int dx[9] = {0, 1, 1, 1, -1, -1, -1, 0, 0},
	dy[9] = {0, -1, 0, 1, -1, 0, 1, 1, -1},
	mods[4] = {0, 998244353, 1000000007, 1000000009}; 
struct point { int x, y; };
std::queue&lt;point&gt; que;
std::vector&lt;point&gt; tmp;
struct twt {
	std::vector&lt;int&gt; wc[3];
	twt() { wc[0].clear(), wc[1].clear(), wc[2].clear(); }
	void insert(int p, int x) {
		p--;
		wc[p].push_back(x);
	}
	void Sort() {
		std::sort(wc[0].begin(), wc[0].end());
		std::sort(wc[1].begin(), wc[1].end());
		std::sort(wc[2].begin(), wc[2].end());
	}
	bool operator == (twt b) const {
		for(int i = 0; i &lt; 3; i++) 
			if(wc[i].size() != b.wc[i].size()) return false;
		for(int i = 0; i &lt; 3; i++)	
			for(int j = 0; j &lt; wc[i].size(); j++)
				if(wc[i][j] != b.wc[i][j]) return false;
		return true; 
	}
};
std::vector&lt;twt&gt; clusters;

</code></pre>
<p>就完成了。</p>
<p>赛场上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>180</mn></mrow><annotation encoding="application/x-tex">180</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">0</span></span></span></span> 行的代码准确地实现了自己的思路，还是让人很舒服的，尽管还是少考虑了一点。</p>
<p>模块化的思路，化那么复杂的一个操作变为很好写的小操作，并在赛场上完成，体现了代码能力的增长和严密，还是让我很开心的。</p>
<h3 id="t4">T4</h3>
<p>这似乎是一道原创题，很好的好题，代码极短。</p>
<p>赛场也模拟了较大的样例，但却想歪了，错失发现正解的机会。</p>
<blockquote>
<p>给定一个由 <code>M</code> 和 <code>F</code> 组成的序列，每一秒 <code>MF</code> 会交换成 <code>FM</code>，问多少次后不能交换。</p>
</blockquote>
<p>赛场上模拟了这样的一个数据。</p>
<pre><code class="language-plain">MFFFFMMFFMMMFMFFF
</code></pre>
<p>大概是这样的（用 $0 $ 代替 <code>M</code>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 代替 <code>F</code>）</p>
<pre><code class="language-plain">01111001100010111
10111010100101011
11011101001010101
11101110010101010
11110110101010100
11111011010101000
11111101101010000
11111110110100000
11111111011000000
11111111101000000
11111111110000000
</code></pre>
<p>然后画出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的运动路径（大概这个样）</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/6jgwRA"><img src="https://z3.ax1x.com/2021/03/26/6jgwRA.png" alt="6jgwRA.png" loading="lazy"></a></figure>
<p>就发现相撞转折一直是单调递增的，而每个点最多被撞一次，所以用类似单调队列的方法找新的这一个撞到的。</p>
<p>这似乎是对的，但是仔细观察，我们有更简单的方法。</p>
<p>要求就是要把后面的 <code>M</code> 堆到后面的相应位置，所以至少要和 <code>F</code> 进行交换，主要是在多个 <code>M</code> 连在一起，这个就得等前面的移掉后再来，所以答案要加上 <code>1</code>,  如果至少要的都更多，那么肯定不会交上了，两个取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop">max</span></span></span></span> 即可。</p>
<p>感觉这其实是巧妙的处理了前面的碰撞？</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
char st[1000005];
int cnt, ans;
int main() {
	scanf(&quot;%s&quot;, st+1);
	int n = strlen(st+1);
	for(int i = n; i &gt;= 1; i--) 
		if(st[i] == 'F') cnt++;
		else if(cnt != 0) ans = std::max(ans+1, cnt);
	printf(&quot;%d&quot;, ans);
}
</code></pre>
<hr>
<p>明天 NOI Online 加油！</p>
<p>下次模拟赛加油！</p>
]]></content>
    </entry>
</feed>