<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://acfboy.pw</id>
    <title>Acfboy 的博客</title>
    <updated>2021-04-22T23:25:37.223Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://acfboy.pw"/>
    <link rel="self" href="https://acfboy.pw/atom.xml"/>
    <subtitle>纵世事物欲横流，仍心归少年志向。</subtitle>
    <logo>https://acfboy.pw/images/avatar.png</logo>
    <icon>https://acfboy.pw/favicon.ico</icon>
    <rights>All rights reserved 2021, Acfboy 的博客</rights>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #717 (div.2) 游记]]></title>
        <id>https://acfboy.pw/cf1516/</id>
        <link href="https://acfboy.pw/cf1516/">
        </link>
        <updated>2021-04-22T08:05:34.000Z</updated>
        <summary type="html"><![CDATA[<p>两个“人生第一次”——上蓝，变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="blue"><mtext mathvariant="sans-serif">Acfboy</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{blue}\textsf{Acfboy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text" style="color:blue;"><span class="mord textsf" style="color:blue;">Acfboy</span></span></span></span></span> 了！以及第一次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mtext mathvariant="sans-serif">FST</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\textsf{FST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text" style="color:red;"><span class="mord textsf" style="color:red;">FST</span></span></span></span></span> 了。</p>
<p>不过比赛状态真的是不好，第一题居然要交三次才过，第二题还 FST。但还是开心地庆祝上蓝！</p>
]]></summary>
        <content type="html"><![CDATA[<p>两个“人生第一次”——上蓝，变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="blue"><mtext mathvariant="sans-serif">Acfboy</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{blue}\textsf{Acfboy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text" style="color:blue;"><span class="mord textsf" style="color:blue;">Acfboy</span></span></span></span></span> 了！以及第一次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mtext mathvariant="sans-serif">FST</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\textsf{FST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text" style="color:red;"><span class="mord textsf" style="color:red;">FST</span></span></span></span></span> 了。</p>
<p>不过比赛状态真的是不好，第一题居然要交三次才过，第二题还 FST。但还是开心地庆祝上蓝！</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://www.hualigs.cn/image/60811d06c1a67.jpg" alt="" loading="lazy"></figure>
<h2 id="a">A</h2>
<p>英语不好有大问题， &quot;two different elements&quot; 指的是下标不同而不是那个数字不同，影响了一定的做题速度。</p>
<p>不过自己没有想清楚也是一个大的原因，没有考虑到根本不能减的情况。</p>
<p>开局不利，就比较慌。</p>
<h2 id="b">B</h2>
<blockquote>
<p>把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数分成至少两段，使每一段异或和相同。</p>
</blockquote>
<p>pretest 有点水啊。不过确实得怪自己没有考虑清楚。</p>
<p>思路是枚举第一段，然后后面验证能不能行。</p>
<p>验证时如果行的就直接断开就会遇到各种问题。一开始没有想到异或和本来就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的问题，顺利 Wrong Answer on pretest 2。又没有注意到如果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 可以和前面并上，顺利 FST。 然后没注意到一段为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 也可以和前面并上，又没有注意到如果前面只是一段就不能并过去，因为至少要两段。</p>
<p>最后居然交了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 发才过！</p>
<p>把代码和提交记录放上来作 警示/纪念 吧。</p>
<figure data-type="image" tabindex="2"><img src="https://www.hualigs.cn/image/608120b511c5d.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
const int N = 2005;
int T, n, a[N];
int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
        int fi = 0, ne = 0;
        bool flag = 0;
        for(int i = 1; i &lt; n; i++) {
            fi ^= a[i];
            ne = 0;
            bool twt = 0, did = 0;
            for(int j = i+1; j &lt;= n; j++) {
                ne ^= a[j];
                if(ne == fi || ne == 0 &amp;&amp; did) ne = 0, twt = 1, did = 1;
                else twt = 0;
                // printf(&quot;*%d %d\n&quot;, ne, twt);
            }
            if(twt) { flag = 1; /*printf(&quot;%d %d %d\n&quot;, i, fi, ne);*/ break;}
        }
        if(flag) puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="c">C</h2>
<p>好题！</p>
<blockquote>
<p>至少要删去几个数，使数组不能被分成和相等的两份。</p>
</blockquote>
<p>至于判断一个数组，那么很好做到，直接背包一遍就可以了。</p>
<p>那么怎么去掉呢？显然若有奇数直接去掉好了，可是没有又怎么去掉？枚举每一个的话万一还需要去掉一个呢？</p>
<p>找一些数据玩一玩，发现最多去掉一个就可以了。证明使用第二类数学归纳法。</p>
<ol>
<li>若存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i = 2^0x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是奇数)， 那么把它去掉肯定可以，所以若要去掉两个的，肯定不存在这样的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i = 2^kx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>) 都不存在，那么去掉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i = 2^mx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span> 的肯定可以，因为大家都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span> 的倍数，而去掉这个再除以二后就不能被 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span> 整除了，所以不能存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i = 2^mx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span></li>
<li>所有的数都不能存在。</li>
</ol>
<p>这样就证明了一堆数去掉一个肯定是可以的。</p>
<p>代码很好写，反而这题是我这场比赛最顺利的一道。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
const int N = 105;
int n, a[N], f[200005], v;
int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), v += a[i];
    for(int i = 1; i &lt;= n; i++)
        for(int j = v; j &gt;= a[i]; j--)
            f[j] = std::max(f[j], f[j-a[i]] + a[i]);
    if(v % 2 == 1 || f[v/2] != v/2) {
        puts(&quot;0&quot;);
        return 0;
    }
    for(int i = 1; i &lt;= n; i++) 
        if((v-a[i]) % 2 == 1 || f[(v-a[i])/2] != (v-a[i])/2) {
            printf(&quot;1\n%d&quot;, i);
            return 0;
        }
    return 0;
}
</code></pre>
<h2 id="d">D</h2>
<p>赛场上想着倍增但没想出个方案来，本来若积小一点就可以用线段树大力维护的，但这样的数据范围要么暴力出奇迹，高精去(用 <code>Python</code> 写线段树？)，要么就另寻他法了。</p>
<p>结果题解真的是倍增。</p>
<p>先处理出每一个开始的断点是在哪儿，然后倍增跳过几段而不是跳过几个数字就好了。</p>
<p>感觉难点在于如何预处理那个第一个断点的问题。</p>
<p>可以先预处理存下每个数的质因数，然后从后往前每一个的质因子的下一个有的取个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span> 就好了。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
const int N = 100005;
int n, q, a[N], f[N][25], ans, l, r, next[N];
std::vector&lt;int&gt; p[N];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
	for(int i = 2; i &lt; N; i++) 
		if(p[i].empty()) {
			next[i] = n+1;
			for(int j = 1; i*j &lt; N; j++)
				p[i*j].push_back(i);
		}
		
	f[n+1][0] = n+1;
	for(int i = n; i &gt;= 1; i--) {
		f[i][0] = f[i+1][0];
		for(int j = 0; j &lt; (signed)p[a[i]].size(); j++) {
			f[i][0] = std::min(f[i][0], next[p[a[i]][j]]);
			next[p[a[i]][j]] = i;
		}
	}
	for(int j = 1; j &lt;= 20; j++)
		for(int i = 1; i &lt;= n+1; i++)
			f[i][j] = f[f[i][j-1]][j-1];
	while(q--) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		ans = 0;
		for(int i = 19; i &gt;= 0; i--)
			if(f[l][i] &lt;= r) {
				ans += (1 &lt;&lt; i);
				l = f[l][i];
			} 
		printf(&quot;%d\n&quot;, ans+1);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [BalticOI 2020 Day2] 村庄]]></title>
        <id>https://acfboy.pw/20210421/</id>
        <link href="https://acfboy.pw/20210421/">
        </link>
        <updated>2021-04-22T06:43:52.000Z</updated>
        <summary type="html"><![CDATA[<p><s>《2021.4.21 校内模拟赛游记》</s></p>
<p>模拟赛的一题——我整场模拟赛都用来做这题了，所以没有游记了，只剩下一篇题解了。</p>
]]></summary>
        <content type="html"><![CDATA[<p><s>《2021.4.21 校内模拟赛游记》</s></p>
<p>模拟赛的一题——我整场模拟赛都用来做这题了，所以没有游记了，只剩下一篇题解了。</p>
<!-- more -->
<blockquote>
<p>有一棵树，要让每一个点移动到另一个点，求移动距离和的最大值和最小值。</p>
</blockquote>
<p>先考虑最小值，这个移动的下届非常好确定，因为由题目可以知道，每一个点最少要移动一次，所以考虑一下链的情况，就是偶数个的话取到下界，不然一个就要多移动一次。然后考虑菊花图，同样很好确定大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的菊花图的最小答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，最大值同样也是这个。</p>
<p>然后就简单了，就把书分成若干条链和菊花图就可以了，一个点儿子多那是没办法，得菊花，不然肯定是变成链的好。至于怎么剖图为链，其实不需要把整条链给拿出来，因为反正我们都是两两配的，先两两配着，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号点多出来了后面再修复一下就可以了。</p>
<p>说着好像很简单的样子，但考场上推了半天，草稿纸上处理了一堆的问题，挺长的时间才想到，赛后口胡和赛场上去独立完成还是有很大的距离的。</p>
<p>那么最大的怎么做呢？赛场上同样考虑了链上的情况，很容易发现把链劈成两半，然后让一边的一定得跨越到另一边就可以了，于是猜想在树上就按照中心或重心之类的分成两半，然后让一边的子树跨到另一边去就可以了。</p>
<p>但是比赛的时候我不知道怎样去确定上界，所以也不清楚到底是中心还是重心，对于多余两个的子树又怎么去处理。</p>
<p>赛后发现其实还是很容易证明的，考虑每一条边最多经过多少次。最多是两边的子树较小的那个的节点个数次乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, 因为小的那个子树里的点全部跑出来，外面最多有这些点跑进去。</p>
<p>那么这个上界能否取到呢？怎么样才会取到呢？其实只要能保证每一条边都能取到必须得是这条边一个点相连的所有子树的和必须要比另一个点的子树要大，不然的话就没有办法确保每一个子树中的点都跑到了和它不相同的子树，也就没有办法确保边被跑满。那么就是要取重心了。</p>
<p>具体的做法也是比较的巧妙的，因为反正没有一个子树大小会超过整个树的一半，那么把它的编号加一半就肯定在另外一棵子树里面了。</p>
<p>代码实现得比较啰嗦，因为把链和菊花图分开存了，为了修正，需要记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号点儿子所在的 菊花图/链 的 下标/迭代器。后来发现其实可以一起处理的（因为都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 啊），但比较懒，就没有改。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#define int long long
const int N = 100005;
typedef std::vector&lt;int&gt; twt;
typedef std::vector&lt;twt&gt;::iterator IT;
twt g[N];
IT t;
std::vector&lt;twt&gt; fl, tr;
int min, ans[N], n, x, y, t2, t3, t4, max, ans2[N], dfn[N], num, size[N];
bool flag[N];
void dfs(int u, int fa) {
	twt tmp;
	dfn[++num] = u;
	size[u] = 1;
	for(int i = 0; i &lt; (signed)g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa) continue;
		dfs(v, u);
		size[u] += size[v];
		if(flag[v] == 0) tmp.push_back(v);
	}
	if(tmp.size() == 1 || tmp.size() == 2) {
		tmp.push_back(u);
		tr.push_back(tmp);
		flag[u] = 1;
		if(fa == 1) {
			if(tmp.size() == 2) t2 = tr.size()-1;
			else t = --tr.end(), t3 = tr.size()-1;
		}
	}
	else if(tmp.size() &gt; 2) {
		tmp.push_back(u);
		fl.push_back(tmp);
		flag[u] = 1;
		if(fa == 1) t4 = fl.size()-1;
	}
	max += 2*std::min(size[u], n - size[u]);
}
void fix() {
	if(t2 != 0) {
		tr[t2].push_back(1);
		return;
	}
	if(t3 != 0) {
		twt tmp;
		for(int i = 0; i &lt; (signed)tr[t3].size(); i++) tmp.push_back(tr[t3][i]);
		tmp.push_back(1);
		tr.erase(t);
		fl.push_back(tmp);
		return;
	}
	fl[t4].push_back(1);
}
signed main() {
//	freopen(&quot;village.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;village.out&quot;, &quot;w&quot;, stdout);
	
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt; n; i++) 
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y), 
		g[x].push_back(y), g[y].push_back(x);
	dfs(1, 0); 
	for(int i = 1; i &lt;= n; i++) ans2[dfn[i]] = dfn[(i+n/2-1)%n+1];
	if(flag[1] == 0) fix();
	for(int i = 0; i &lt; (signed)tr.size(); i++) 
		if(tr[i].size() == 3) {
			tr[i].push_back(tr[i][0]);
			for(int j = 0; j &lt; (signed)tr[i].size()-1; j++)
				ans[tr[i][j]] = tr[i][j+1];
			min += 4;
		}
		else {
			ans[tr[i][0]] = tr[i][1], ans[tr[i][1]] = tr[i][0];
			min += 2;
		}
	for(int i = 0; i &lt; (signed)fl.size(); i++) {
		min += 2 * ((signed)fl[i].size()-1);
		ans[fl[i][0]] = fl[i][1], ans[fl[i][1]] = fl[i][0];
		fl[i].push_back(fl[i][2]);
		for(int j = 2; j &lt; (signed)fl[i].size()-1; j++) ans[fl[i][j]] = fl[i][j+1];
	}
	printf(&quot;%lld %lld\n&quot;, min, max);
	for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]);
	puts(&quot;&quot;);
	for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans2[i]);
	return 0;
}
</code></pre>
<p>感觉思维难度其实挺大的，而模拟赛搬题人却说思维难度不高，NOIP <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span></span></span></span>……</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[梅 开 三 度]]></title>
        <id>https://acfboy.pw/mei-kai-san-du/</id>
        <link href="https://acfboy.pw/mei-kai-san-du/">
        </link>
        <updated>2021-04-22T04:53:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="离开">离开</h3>
<p>2021 年的元旦刚过，我居然这么就不经意间参加了一次考试，又得到了意料之外的录取的消息，于是三号下午，我便知道了那是我在 sy 的最后一天。</p>
<p>但那时肯定是兴奋而期待的，对未来充满了憧憬，虽有一点点淡淡的伤感，但肯定不会认真的思考对过去的告别，对所喜欢的人们作出自己无悔的告别。</p>
<p>所以我所作出的唯一的告别就是得到正式的通知以后在社会课上手写的一封告别信，用了 “萨曼·威斯高德·霍欧维斯·肖特·安特肖斯·艾斯·阿塞恩特·金神叹” 的自称和“一个焦点是木桩，一个焦点在远方”的典故。本想着在英文部分留下什么彩蛋，最终还是什么都没有留，只是写上了我这名字糟糕的翻译——不过，将标题译作“You are beautiful”。晚上等到几乎最后一个走，将信放在校牌里对着她的桌子。</p>
<p>甚至没有说出一声的再见。</p>
<p>但她在那天晚自修说的话我记得很清晰，至今还是——可能一直到我退役都会是——我洛谷个人主页唯一的一句话。</p>
<blockquote>
<p>翘翘以前很可爱，现在不可爱了。</p>
</blockquote>
<p>罗翔讲《会饮篇》，讲得很好，柏拉图写得很好，苏格拉底讲得也很好。爱是要追求自己想要的美好，而肉体上的幸福只是追求灵魂高贵的阶梯。最终还是向往他人所拥有的美好，向往灵魂的高贵。</p>
<p>罗翔老师的这一个多小时的直播确实起到了很好的作用，让我更加理性地去看待这个事情。她很自律，能为自己想要的而奋斗；也很阳光，充满纯洁和正气。这确实是我所向往而不曾拥有过的美好。</p>
<p>但我确实自知不配，所以什么也没有说过，从来就没有说过什么。</p>
<p>我就什么都没有说，就这么走了，但一个一个的脚印又确实印在操场上，印在时间里，印在人心里；为了改变现状做的微不足道的努力也同样弥漫在那段时光中。</p>
<h3 id="无言">无言</h3>
<p>我居然会很想她，准确的来讲，似乎走了之后，就想两个人，还有一个是 wc。</p>
<p>我本来期盼着 wc 能考上来的，我们还可以一起奔跑在晚霞中，但他没能来，无论只是恰好的失误还是什么其它的问题，这都一锤定音了，我将离开熟悉的 911,独自踏上新的旅程。</p>
<p>我怀念在 sy 大声朗读的日子，所以尽管没有早读课，仍然拿着一本书，或是经典诵读，或是必修上册，和翘翘响亮的声音，相约在清晨；我同样仍然喜爱身体稳定运行的感觉，所以继续奔跑在这儿的操场。但虽然脑中仍能想起“翘翘加油”的声音，仍能想起“不合时宜了”的忠告，抓着的灌水区似乎有着要被扯走的力度，却仍然没有办法专心地去练习，去静下心来思考。</p>
<p>911 的氛围真的好的多，虽然同样有吵闹而浮躁的时候，但同样有着充满理想而奋斗的人们。</p>
<p>sxyz 的机房环境，至少我所在的地方，似乎却不大对得起它强省强校的称号。但当自己深陷在其中的时候，却不是那么好拒绝的。不是怀着一点点的热血、吟着华丽的篇章就能做到的。</p>
<p>于是，翘翘以前很可爱，现在不可爱了。最可怕的其实是面对这样内心深处的声音而又无力去改变，它一点点地剥夺着人对美好的念想。</p>
<p>罗翔在《请回答2020》中谈到人为什么害怕孤独中谈得很彻底，或者说叔本华对这个问题认识得彻底，概括得也凝练。因为当你静下来的时候，会面对来自自己内心深处的声音，你想成为什么样的人，你为之奋斗了吗。但我没法去直面这样的声音，所以只能企图用吵闹和浮躁将其掩盖，或许所谓“娱乐至死”的原因也正是在此。</p>
<p>记得有一次我对她说“聒噪”——当然是水浒传里的聒噪，打扰了之类的意思——她说“我确实很聒噪”。或许每个人都会遇上这样的困境，但无论如何，在痛苦中沉沦，放弃自己的理想不是我想要的，我希望能为自己所想要的而奋斗，尽管可能无法坦然面对内心所有的逼问，也许没有办法完全脱掉浮躁的外衣，但总比待在此处更加接近幸福。</p>
<p>我时常想她。怀疑这只是青春的萌动是不无道理，但我确实向往着能常怀正气，能为自己所爱的事业而奋斗。</p>
<p>对于那首“梦游天姥吟长恨歌”，我至今还是不明白她最初的意图是什么，不过我也将它看作是她给我的劝诫。实验操作考试，英语口语考试，我几乎没有和她说过话，这是无言。但我更常面对的是，对内心深处逼问的无言。</p>
<h3 id="上路">上路</h3>
<p>今天体育中考了，我迟到了以为要上楼拿准考证时在楼梯上碰到她，她主动的叫了一声“翘翘”。等到真正到考场后似乎有很多的时间，至少可以问个“吟长恨歌”的事，但我却不敢去说什么。然后就只是在操场入口看见过一眼。但等我跑的时候却见她在那弯道处喊加油。</p>
<p>前两次的考试中的无言让我觉得她对我很冷淡，但那个瞬间，我发觉其实冷淡的是我，我不敢主动叫她，也从未为她加油呐喊过。或许是我不敢面对，因为我在努力去为自己想要的而奋斗上取得了彻底的失败。我们两个的关系自然是没有继续的可能，我也不配哇。</p>
<p>但追求灵魂的高贵，追求她所拥有的美好，何必局限在这点上。</p>
<p>我所能做的，当然只有，也确实应该只有，怀着追求自身所想要的美好的梦想，和他人给予的鼓励，独自一人上路了。人生是没有人能陪你到最后的旅程，我长跑中也常体验过这样的感觉，我来这里之后，几乎不再有人和我跑过全程或者大多数的旅程了。</p>
<p>生命中的很多人，在你前行的路上陪过你一段，给你留下了美好的回忆，也足够了。他/她 的精神的品质，完全可以留在你的心里，陪你去走更远。你脑中留下的，也是 他/她 最好的年纪，最好的样子。</p>
<p>在“梦游天姥”之前，她还给过填过一行字，那是现代汉语，“心怀热爱，奔赴山海”，我记得我好像填成的是“爱怀热心，奔山赴海”，<s>我怎么语感如此糟糕</s>, 其实又何尝不可以呢？我所爱的，所向往的，也确实是怀着一颗少年炽热的心，去迎接生活中的挑战。</p>
<p>我非常感谢并想念那些曾经陪伴我走过一段的人（怎么突然就有 wzf 的腔调了），但不得不告别，独自一人踏上另一段旅程了。但他们其实都陪在我身边，不是吗？我跑得累的时候，仿佛一转头，就是那几个陪跑的人，仿佛下一个弯道，就有着“翘翘加油”的呼声。和一道题奋战的时候一抬头，他们何尝不在。</p>
<h3 id="最后">最后</h3>
<p>不知道她是怎么看待我的，我感觉我的什么心思她清楚的很，感觉总是她给我疯狂暗示然后我又啥也不懂，憨憨的，想问个啥也是毫无计划<s>一头雾水两眼抓瞎模式</s>。</p>
<p>还记得有一次跑完五千她说了什么“同化”“异化”，我没明白，再追问也不说了，现在也不知道什么意思，最近看了一本书结果感觉这居然牵扯到黑格尔的哲学？？？当然也有可能不是同个东西。</p>
<p>好像我对她是一无所知的。</p>
<p>然后，大概就得向我初中时代很多很熟悉但又一无所知的人告别了，以后，各自保重。</p>
<p>而 sxyz 又何曾没有为自己的梦想默默奋斗的人呢，不可被一些 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mo>×</mo></mrow><annotation encoding="application/x-tex">\times \times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">×</span></span></span></span> 所诓骗，要自己去看地底下。</p>
<p>现在忽然又想起刚刚读完的王小波《三十而立》，则似乎满眼都是对自我的坚持了。</p>
<blockquote>
<p>内心坚持着梅的圣洁高雅，面对逆境坚持梅的傲雪自强，对待生活时刻保持梅的清雅俊逸，此之谓梅开三度。</p>
</blockquote>
<p>翘翘加油。</p>
<p><s>花那么多时间写下这些似乎有些不合时宜</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC035C] Skolem XOR Tree]]></title>
        <id>https://acfboy.pw/agc035c/</id>
        <link href="https://acfboy.pw/agc035c/">
        </link>
        <updated>2021-04-21T00:09:39.000Z</updated>
        <summary type="html"><![CDATA[<p>止步于一个死胡同里了，没能换一种思路出正解。感觉做这种构造题的方向也没有搞对。</p>
]]></summary>
        <content type="html"><![CDATA[<p>止步于一个死胡同里了，没能换一种思路出正解。感觉做这种构造题的方向也没有搞对。</p>
<!-- more -->
<blockquote>
<p>构造一颗大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span> 的树，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的权值都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>, 使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span></span></span></span> 路径上的异或和都为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 或断言这不可能。</p>
</blockquote>
<p>开始的时候去研究了一下连续数异或的性质，发现连续四个一组异或起来是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，如下。</p>
<pre><code>00000
00001
00010
00011
---
00100
00101
00110
00111
---
01000
01001
01010
01011
---
01100
01101
01110
01111
</code></pre>
<p>这一点的正确性挺显然的，于是我们对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn><mi>k</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n = 4k+3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的就有了一种构造方案，即把三个一组，后面每四个一组进行构造，用笔模拟一下发现四个四个的构造都是独立且成立的，那么随便选一个点连起来就可以了。</p>
<p>那么其它情况呢？能断言其不成立吗？我就束手无策了。</p>
<p>其实一条路走不通，得确定它确实走不通，然后换条路试试，而不可放弃啊。</p>
<p>其实做这种构造题应该先确定一个绝对没有解的条件，再去尝试构造剩下的。</p>
<p>那么什么事绝对没有解的呢？<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的幂次的时候肯定不行，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">n&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 中间在这最高位上肯定不会有了。</p>
<p>那么考虑剩下的怎么去构造，其实有一个很“显然”的性质，那就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是偶数时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn><mo>⊕</mo><mn>1</mn><mo>=</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x+1 \oplus 1 = x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>， 是奇数时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⊕</mo><mn>1</mn><mo>=</mo><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x \oplus 1 = x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 那么我们就可以用下图构造了。</p>
<figure data-type="image" tabindex="1"><img src="https://www.hualigs.cn/image/607f6b8455e90.jpg" alt="" loading="lazy"></figure>
<p>把每一组偶数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 都向上面连接就可以了。</p>
<p>至于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 直接接在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 下面就好了，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>⊕</mo><mn>3</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 \oplus 3 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。还有就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是偶数时会多出来，再想想怎么修补。</p>
<p>可发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>→</mo><mtext>lowbit</mtext><mo>(</mo><mi>n</mi><mo>)</mo><mo>→</mo><mn>1</mn><mo>→</mo><mi>n</mi><mo>−</mo><mtext>lowbit</mtext><mo>(</mo><mi>n</mi><mo>)</mo><mo>+</mo><mn>1</mn><mo>→</mo><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">n \rightarrow \text{lowbit}(n) \rightarrow 1 \rightarrow n - \text{lowbit}(n)+1 \rightarrow n&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lowbit</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lowbit</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 满足条件，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>lowbit</mtext><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{lowbit}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lowbit</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 是偶的，所以这样的路一定存在。</p>
<p>代码就不放了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2012]守卫]]></title>
        <id>https://acfboy.pw/apio2012shou-wei/</id>
        <link href="https://acfboy.pw/apio2012shou-wei/">
        </link>
        <updated>2021-04-20T11:01:41.000Z</updated>
        <summary type="html"><![CDATA[<p>一道从开始就被我想歪的题目，以至于写了一天最后发现根本就是错误的算法，只好照题解写去了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一道从开始就被我想歪的题目，以至于写了一天最后发现根本就是错误的算法，只好照题解写去了。</p>
<!-- more -->
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 的区间内有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个标记在整数上，给出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 段区间内有/没有标记，输出一定有标记的数字。</p>
</blockquote>
<p>看完题我就直接给出了一堆“显然”的结论：</p>
<ol>
<li>去掉没有的，若有的区间长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 那这个就肯定是的了。</li>
<li>把肯定是的去掉，当且仅当剩下还有的标记数和现在有覆盖标记的数字数一样的时候有一定有标记的数字，且一定是全都是。</li>
</ol>
<p>看上去是不是挺有道理？于是我就设计了一个用 <code>std::set</code> 的算法，用 <code>(twt){st, len}</code> 表示从 <code>st</code> 开始长度 <code>len</code> 的有覆盖，维护一个可能有的区间，和一个一定没有到区间，然后用一定没有的在有的区间内除去，然后判一下前面两条就行了。合并区间的时候注意有标记的区间刚刚好相接是不能接上的，因为要注意一号判断。</p>
<p>似乎好有道理，然后我就写、调了俩小时，最后获得了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 分的优异成绩。</p>
<p>其实反例很显然：</p>
<pre><code class="language-cpp">3 1 3
1 1 1
1 2 1
1 3 1
</code></pre>
<p>这样我认为是无法确定的，其实第一个明显是可以确定的。解决这个问题可不是仅仅把开始时长度就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的判掉那么简单。</p>
<p>比如这组反例：</p>
<pre><code class="language-cpp">5 1 3
2 3 1
1 5 1
3 3 0
</code></pre>
<p>把前两段并起来后就损失了它们单独的信息了！</p>
<p>所以前面的断言根本就是错的。浪费了我许多的时间。<strong>在开始写代码前一定要想清楚，充分考虑算法的正确性是否成立。</strong></p>
<p>那么现在来讲正确的做法吧。</p>
<p>正确做法同样维护了可能由标记的区间并从中去掉了一定没有标记的区间，那它是如何处理在合并中的信息损失呢？</p>
<p>其实，正确做法根本不需要这个信息，<s>因为它不依赖于我的断言</s>。</p>
<p>想法很简单，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 记录前面到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 段所需的最少标记数量，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">g_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 记录从后面开始的。然后枚举每一个点就强制它不选，选它左边一个，再看下前后所需的会不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 就好了。</p>
<p>当然细节还是要处理的。</p>
<p>题解里处理合并的方式比我的 <code>set</code> 好多了，既快（没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>） 又好写 （不用处理迭代器删除的问题），用差分把现在不是肯定没有的点抓出来重新编号，用新编号表示线段的端点。</p>
<p>处理合并可以将一个端点排序后使用单调栈处理合并。至于找左右的线段端点？既然有序，直接二分就好了。</p>
<p>代码实现感觉也一些的难度。</p>
<pre><code class="language-cpp">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m);
	for(int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d%d&quot;, &amp;a[i].l, &amp;a[i].r, &amp;a[i].f);
		if(a[i].f == 0) ++b[a[i].l], --b[a[i].r+1];
	}
	int now = 0, cnt = 0;
	for(int i = 1; i &lt;= n; i++) {
		now += b[i];
		if(now == 0) L[i] = R[i] = ++cnt, be[cnt] = i;
	}
	if(cnt == k) {
		for(int i = 1; i &lt;= cnt; i++) printf(&quot;%d\n&quot;, be[i]);
		return 0;
	}
</code></pre>
<p>先是重新编号的过程，如果发现这些点恰好就是需要的，那么直接输出就可以了。</p>
<p>同时标记出了一个新的点左右最靠近的一个端点。</p>
<pre><code class="language-cpp">	L[n+1] = n+1;
	for(int i = 1; i &lt;= n; i++) 
		if(R[i] == 0) R[i] = R[i-1];
	for(int i = n; i &gt;= 1; i--) 
		if(L[i] == 0) L[i] = L[i+1];
	cnt = 0;
	for(int i = 1; i &lt;= m; i++) {
		if(a[i].f == 0) continue;
		if(L[a[i].l] &lt;= R[a[i].r]) a[++cnt].l = L[a[i].l], a[cnt].r = R[a[i].r];
	}
	std::sort(a+1, a+cnt+1);
</code></pre>
<p>然后更新 <code>a</code> 的编号并进行排序。</p>
<p>以下重新使用了 <code>L</code> 和 <code>R</code> 作为栈，注意这里的合并不是我假做法里的合并，而是把完全覆盖的给并掉了。还求出了 <code>f</code> 和 <code>g</code>。</p>
<pre><code>	int top = 0;
	for(int i = 1; i &lt;= cnt; i++) {
		while(top != 0 &amp;&amp; a[i].l &gt;= L[top] &amp;&amp; a[i].r &lt;= R[top]) top--;
		L[++top] = a[i].l, R[top] = a[i].r;
	}
	int l = n+1, r = 0;
	for(int i = 1; i &lt;= top; i++) {	
		if (L[i] &gt; r) f[i] = f[i-1] + 1, r = R[i];
		else f[i] = f[i-1];
	}
	for(int i = top; i &gt;= 1; i--) {
		if (R[i] &lt; l) g[i] = g[i+1] + 1, l = L[i];
		else g[i] = g[i+1];
	}
</code></pre>
<p>最后是关键的判断环节。</p>
<p>这里还需要说明一下，最后栈中的编号是剩下线段的编号，我们每次只判断了最右边一个是否是一定要有的，是因为这样子显然是最优的，因为放在这个位置右边也可能会利用到，而因为每一段覆盖只需要一个就可以了，其它地方判断出来是不能确定的，因为可以放到线段最右边的位置可能更优。</p>
<pre><code class="language-cpp">	bool flag = 0;
	for(int i = 1; i &lt;= top; i++) {
		if(f[i] == f[i-1]) continue;
		if (L[i] == R[i]) {
			printf(&quot;%d\n&quot;, be[R[i]]);
			flag = 1; 
			continue;
		}
		int l = 1, r = i - 1, x = 0, y = top + 1;
		while (l &lt;= r) {				 
			int mid = l + ((r - l) &gt;&gt; 1);
			if (R[mid] &lt; R[i] - 1) x = mid, l = mid + 1;
			else r = mid - 1;
		}
		l = i + 1, r = top;
		while (l &lt;= r) {
			int mid = l + ((r - l) &gt;&gt; 1);
			if (L[mid] &gt; R[i] - 1) y = mid, r = mid - 1;
			else l = mid + 1;
		}
		if (f[x] + g[y] + 1 &gt; k) {
			printf(&quot;%d\n&quot;, be[R[i]]);
			flag = 1;
		}
	}
	if(flag == 0) puts(&quot;-1&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Japanese Student Championship 2021 游记]]></title>
        <id>https://acfboy.pw/jsc2021/</id>
        <link href="https://acfboy.pw/jsc2021/">
        </link>
        <updated>2021-04-18T08:28:50.000Z</updated>
        <summary type="html"><![CDATA[<p>这场比赛还是有收获的，特别是对 E 题的坚持。</p>
<p>但比赛体验真的比较糟糕，在学校里比赛就感觉特别吵，而且 D 题开始还读错了题目，E 题没有在赛时通过，最后上蓝再次失败。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这场比赛还是有收获的，特别是对 E 题的坚持。</p>
<p>但比赛体验真的比较糟糕，在学校里比赛就感觉特别吵，而且 D 题开始还读错了题目，E 题没有在赛时通过，最后上蓝再次失败。</p>
<!-- more -->
<h2 id="a">A</h2>
<p>水题。</p>
<p>但开始时十分紧张，题目读了好久才明白，浪费了一些时间。</p>
<p>大概很多人一起比赛无形之中会增加紧张感吧。</p>
<h2 id="b">B</h2>
<p>水题。</p>
<p>做题开始有点儿状态了。</p>
<h2 id="c">C</h2>
<p>状态正常！</p>
<h2 id="d">D</h2>
<p>开始看错了题目，以为是要整个串的和是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的倍数，当然推不出什么结果，就直接看了别人的结论。</p>
<p>赛后发现读错题了之后就简单了，有一个显然的 dp， 然后它又可以很显然地化成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>p</mi><mo>−</mo><mn>2</mn><msup><mo>)</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(p-2)^{n-1}(p-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的形式。</p>
<h2 id="e">E</h2>
<p>最大的“亮点”，赛场上想了一会儿模拟了几个样例居然想到了正解。</p>
<p>不过实现起来就是另外一回事了，感觉细节特别特别多，然后就是……赛后补了一早上才过。</p>
<figure data-type="image" tabindex="1"><img src="https://www.hualigs.cn/image/607cc1c953043.jpg" alt="" loading="lazy"></figure>
<p>大致的思路其实很好想，就是每次分段一层一层的剖下来，然后对于每一个找出最多的把其它都改成它，然后就遇到了一堆的问题：</p>
<ol>
<li>如何快速找到最后一层的一个所对应的其它</li>
<li>若最后一层仍然回文怎么办</li>
<li>奇数个的如何匹配中间</li>
</ol>
<p>然后赛场上想到了设一个在最后串中左边有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个， 右边有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个就是每次加俩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 再加俩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>, 然后用栈处理有奇数个层的多出来的那个，先把所有当个的拉出来就好了，总和肯定不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。于是直接噼里啪啦写代码，写完错误一堆。</p>
<p>主要问题是考场上怕来不及，很多地方都没有想清楚，比如栈变化的那个操作序列怎么生成，又比如最后仍然回文应该怎么处理……</p>
<p>于是第二天还调了一早上才终于过了， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mo>+</mo></mrow><annotation encoding="application/x-tex">100+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">+</span></span></span></span> 行的代码。</p>
<p>最后一看题解发现人家 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> 几行就写完了。</p>
<p>好吧好吧，不过调这题大概真的锻炼了思维的严谨性，就把代码拿来纪念吧。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
std::vector&lt;int&gt; tmp;
const int N = 500005, SPJ = 19;
int k, n, sta[N], tub[28], ans, top, len, opt[N], pre[N], tns;
char st[N], st2[N];
bool check() {
	for(int i = 1; i &lt;= len; i++)
		if(st2[i] != st2[len-i+1]) return false;
	return true;
}
void doit(int opt) {
	for(int i = 0; i &lt; 26; i++) tub[i] = 0;
	for(int i = 0; i &lt; (signed)tmp.size(); i++) 
	    if(opt != SPJ) tub[st[tmp[i]]-'a'] ++;
	    else if(st[tmp[i]]-'a' != st2[tmp[i]]-'a') tub[st[tmp[i]]-'a'] ++;
	int maxj = 27;
	for(int i = 0; i &lt; 26; i++) 
		if(tub[i] &gt; tub[maxj]) maxj = i;
	int cnt = 0;
	for(int i = 0; i &lt; (signed)tmp.size(); i++) 
	    cnt += (st[tmp[i]] != maxj+'a'), st2[tmp[i]] = maxj + 'a';
	if(opt == SPJ) {
	    if(tmp[0] != (len+1)/2) tns = std::min(tns, cnt - pre[tmp[0]]);
	}
	else {
	    pre[tmp[0]] = cnt;
	    ans += cnt;
	}
}
int makeopt(int x) {
	if(x == 0) return 0;
	opt[1] = x;
	int j = 1;
	for(int i = x-1; i &gt;= 1; i--) {
		opt[++j] = i;
		for(int k = j-1; k &gt;= 1; k--) 
			opt[++j] = opt[k];
	}
	return j;
}
int main() {
	scanf(&quot;%d%s&quot;, &amp;k, st+1);
	n = strlen(st+1);
	if(k == 0) {
	    if(n == 1) return puts(&quot;impossible&quot;), 0;
	    ans = 1;
	    for(int i = 1; i &lt;= n; i++)
	        if(st[i] != st[n-i+1]) ans = 0;
	    printf(&quot;%d&quot;, ans);
	    return 0;
	}
	for(int i = 1; i &lt;= n; i++) st2[i] = st[i];
	if(k &gt; 20 || (n &gt;&gt; (k-1)) == 0 || (n &gt;&gt; k) == 1) return puts(&quot;impossible&quot;), 0;
	len = n;
	for(int j = 1; j &lt;= k; j++) {
		if(len &amp; 1) {
			int a = len &gt;&gt; 1;
			tmp.clear();
			int end = makeopt(top);
			tmp.push_back(a+1);
			for(int i = a+1, w = 1; i &lt;= n &amp;&amp; w &lt;= end; w++) {
				i += 2*a + sta[opt[w]] + 1;
				tmp.push_back(i);
			}
			doit(0);
			sta[++top] = 1;
		}
		else sta[++top] = 0;
		len &gt;&gt;= 1;
	}
	for(int i = 1; i &lt;= len; i++) {
		int a = i-1, b = len-i;
		tmp.clear();
		int end = makeopt(top);
		tmp.push_back(i);
		for(int j = i, c = 1, w = 1; j &lt;= n &amp;&amp; w &lt;= end; c++, w++) {
			if(c%2 == 1) j = j + 2*b + sta[opt[w]] + 1;
			else j = j + 2*a + sta[opt[w]] + 1;
			tmp.push_back(j);
		}
		doit(0);
	}
	if(len != 0 &amp;&amp; check()) {
	    tns = 0x3f3f3f3f;
	    for(int i = 1; i &lt;= len; i++) {
    		int a = i-1, b = len-i;
    		tmp.clear();
    		int end = makeopt(top);
    		tmp.push_back(i);
    		for(int j = i, c = 1, w = 1; j &lt;= n &amp;&amp; w &lt;= end; c++, w++) {
    			if(c%2 == 1) j = j + 2*b + sta[opt[w]] + 1;
    			else j = j + 2*a + sta[opt[w]] + 1;
    			tmp.push_back(j);
    		}
    		doit(SPJ);
    	}
    	ans = ans + tns;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.4.17 校内模拟赛游记]]></title>
        <id>https://acfboy.pw/2020417/</id>
        <link href="https://acfboy.pw/2020417/">
        </link>
        <updated>2021-04-17T07:28:17.000Z</updated>
        <summary type="html"><![CDATA[<p>研究了 T2 一会儿居然写快速谭炜谭变换去了，结果后来发现这题……</p>
<p>以后得改变做题的模式了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>研究了 T2 一会儿居然写快速谭炜谭变换去了，结果后来发现这题……</p>
<p>以后得改变做题的模式了。</p>
<!-- more -->
<h2 id="a">A</h2>
<blockquote>
<p>一只马，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的棋盘中能跳到几个点。</p>
</blockquote>
<p>对于大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">3 \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 的棋盘是都可以跳到的，因为在 上/下 和 右边 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的格子时就可以移动到右边的一个。</p>
<p>剩下的判掉就好了。</p>
<h2 id="b">B</h2>
<blockquote>
<p>输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 组数，每组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(l_i, d_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 每次两种操作：</p>
<ul>
<li>价值加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 去掉最左边的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">l_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个</li>
<li>把最后一个换到开头，其它每个后移</li>
</ul>
<p>求最大价值</p>
</blockquote>
<p>想了一下模拟了几个数据没有什么思路，唯一发现的性质就是它换了个寂寞，反正相对位置永远不变的。</p>
<p>想不到什么思路人又比较浮躁，于是直接大力 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">exFTT(extand</mtext><mtext> </mtext><mtext mathvariant="monospace">Fast</mtext><mtext> </mtext><mtext mathvariant="monospace">Tanweitan</mtext><mtext> </mtext><mtext mathvariant="monospace">Transform)</mtext></mrow><annotation encoding="application/x-tex">\texttt{exFTT(extand Fast Tanweitan Transform)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord texttt">exFTT(extand Fast Tanweitan Transform)</span></span></span></span></span>, 就是从头开始随机每个选不选，一波计算后发现期望最多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span> 次就可以构成一次操作，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 才 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> , 所以跑个几十万次没有问题。</p>
<p>然后……一下就被卡掉了。</p>
<p>因为从头开始选第一次选到后面的概率很小。于是就想着又随机每次从前还是从后开始，但是……对于分数来说还是没有任何用处，都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>, twt 直接无脑随机都有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>。</p>
<p>代码留作纪念吧，警示以后不要这么干了。</p>
<pre><code class="language-cpp">// Powered by exFTT(extand Fast Tanweitan Transform)
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt; 
#include &lt;algorithm&gt;
int n, ans, D;
bool vis[55];
struct twt { int l, d; } a[55];
int inc(int &amp;x) {
	x ++;
	if(x &gt; n) x = 1;
}
bool check(int x) {
	for(int j = 1; j &lt;= n; j++, D++) 
		if(!vis[j] &amp;&amp; a[j].l &lt;= x) return true;
	return false;
}
int main() {
	srand(time(0));
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i].l, &amp;a[i].d);
	while(D &lt; 50000000) {
		for(int j = 1; j &lt;= n; j++) vis[j] = 0;
		int now = 1, j = 1, num = n, an = 0;
		while(check(num)) {
			for( ; vis[j] || a[j].l &gt; num; inc(j), D++) ;
			if(rand()%2 == 0) { inc(j); continue; }
			an += a[j].d;
			int tmp = a[j].l;
			for(int cnt = 1; cnt &lt;= tmp; inc(j)) cnt += !vis[j], vis[j] = 1, D++,  num--;
		}
		ans = std::max(ans, an);
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
<p>然后是令人震惊的正解：直接 01 背包！</p>
<p>讲一下为什么：</p>
<ol>
<li>若选出来的一堆的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 大于了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那肯定没救了</li>
<li>若选出来的一堆 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,  那么肯定有一种方案可以选到这些所有，因为总有一个不会和其它接上。</li>
</ol>
<p>所以这就是一个 01 背包了。</p>
<h2 id="c">C</h2>
<p>不会。</p>
<h2 id="反思">反思</h2>
<p>感觉 B 题没做出来和我平时做了一会儿做不出就去看题解的做题习惯有很大的关系，失去了长时间思考的能力，就仿佛碎片化的阅读让人失去了读整本书的能力一样。</p>
<p>整天做些体力劳动远大于脑力劳动的练习是没有意义的，这样子追求所谓的过题量让算法竞赛本身的魅力丧失殆尽，此之谓失其本心。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 逛庙会]]></title>
        <id>https://acfboy.pw/guang-miao-hui/</id>
        <link href="https://acfboy.pw/guang-miao-hui/">
        </link>
        <updated>2021-04-17T00:07:58.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2238">传送门</a></p>
<p>状压 dp 的好题目，巧妙利用状压传递了有后效性的信息从而消除了后效性。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2238">传送门</a></p>
<p>状压 dp 的好题目，巧妙利用状压传递了有后效性的信息从而消除了后效性。</p>
<!-- more -->
<p>这题如果没有取周围的那么很容易想到一个 dp, 但由于会取周围的而且还要选出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个，所以有后效性，尝试通过改变 dp 的顺序来消除后效性，但是很遗憾，没有用。</p>
<p><s>所以上 老板dp/快速谭炜谭变换 吧。</s></p>
<p>然后我就没辙了，去看了 kkk 的题解，不得不说 kkk 的题解写得 <s>糟透了</s> <strong>真的好</strong>，非常考验读者的思维能力，不自己想根本就看不懂。</p>
<p>另一个解决后效性的方式：将需要记录的信息加入到状态中。</p>
<p>但知道了这一点要做这一题还是非常有难度，这题的状态还是很妙的。</p>
<p>考虑什么情况下是这题的难点，比如说要走如下的路径：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>→</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>→</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext mathvariant="sans-serif">twt</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>↓</mo></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}
\rightarrow &amp; \rightarrow \\
\textsf{twt} &amp; \downarrow
\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">→</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord textsf">twt</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">→</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">↓</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<p>那么 <code>twt</code> 的价值在两次中都可能被算进去，应该如何把取/没取的信息传递下去呢？这里有一个非常妙的做法，就是对于一个点，我们状压它 左下/下/右/右上 的状态。</p>
<p>这样子有什么的好处？那就是我们可以传递这样的一个状态了！</p>
<p>向右转移的时候必须保证其左下和原来的下是一样的，向下转移时保证新的右和原来的右下是一样的，这样子就可以把转角的信息（就是 <code>twt</code>）给不断传递了。</p>
<p>记得需要判断的是当前经过位置是一定要取的，然后还要取超过一个。</p>
<p>转移的时候只要加上相应的东西就可以了，因为剩下的都在其它的状态中判断过取不取的问题了，由于取了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span>, 可以保证其正确性。</p>
<p>代码：</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
const int N = 1005;
int n, m, sh[N][N], f[N][N][16];
int cnt[16] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4}; 
// 二进制中 1 的个数
char s[N];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	memset(f, 0x3f, sizeof f);
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%s&quot;, s+1);
		for(int j = 1; j &lt;= m; j++) sh[i][j] = (s[j] == '.' ? 0 : (s[j] - '0'));
	}
	f[1][1][15] = 0;
	for(int i = 1; i &lt;= n; i++) 
		for(int j = 1; j &lt;= m; j++)
			for(int k = 0; k &lt; 16; k++) {
				for(int k2 = 0; k2 &lt; 16; k2++) {
					if(((k&amp;4)==0) != ((k2&amp;8)==0) || !(k&amp;2) || cnt[k&amp;1] + cnt[k2&amp;6] &lt;= 1) continue;
					int cost = f[i][j][k];
					if(k2 &amp; 1) cost += sh[i+2][j-1];
					if(k2 &amp; 2) cost += sh[i+2][j];
					if(k2 &amp; 4) cost += sh[i+1][j+1];
					f[i+1][j][k2] = std::min(f[i+1][j][k2], cost);
				}
				for(int k2 = 0; k2 &lt; 16; k2++) {
					if(((k&amp;2)==0) != ((k2&amp;1)==0) || !(k&amp;4) || cnt[k&amp;8] + cnt[k2&amp;6] &lt;= 1) continue;
					int cost = f[i][j][k];
					if(k2 &amp; 8) cost += sh[i-1][j+2];
					if(k2 &amp; 4) cost += sh[i][j+2];
					if(k2 &amp; 2) cost += sh[i+1][j+1];
					f[i][j+1][k2] = std::min(f[i][j+1][k2], cost);
				}
			}
	printf(&quot;%d&quot;, f[n][m][15]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC037E] Reversing and Concatenating]]></title>
        <id>https://acfboy.pw/agc037e/</id>
        <link href="https://acfboy.pw/agc037e/">
        </link>
        <updated>2021-04-16T06:14:11.000Z</updated>
        <summary type="html"><![CDATA[<p>总算是自己做了一道 AGC，没有浪费 AGC 的妙妙题了。以前看题解把这么好的题目都浪费掉了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>总算是自己做了一道 AGC，没有浪费 AGC 的妙妙题了。以前看题解把这么好的题目都浪费掉了。</p>
<!-- more -->
<blockquote>
<p>操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次，每次将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 复制一份反转一遍拼在其后面，从新字符串中取一个子串作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>。求操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次后字典序最小的字符串。</p>
</blockquote>
<p>首先想到只进行一步这样的操作，显然是要把最小的那个在一起最长的取走，若有相同长度，那么后面的字典序要尽可能的小。</p>
<p>那么要进行更多的步骤怎么做呢，显然每次把最小的放在头上是不合理的，因为只有尾部的会被复制，而一次操作可以把任意一段扔到队尾或放到开头，所以除了开头可结尾，让最小的字母组成的一段放在最末尾肯定是最优的。</p>
<p>但如果存在同样的几组的怎么办呢，模拟几个小的数据观察就会发现，复制后前面的一段就会反过来拼在最小的那段复制完的后面，而这一段是永远不会变的。</p>
<p>比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="sans-serif">twtwa</mtext><mo>→</mo><mrow><mtext mathvariant="sans-serif">t</mtext><munder accentunder="true"><mtext mathvariant="sans-serif">wtwaa</mtext><mo stretchy="true">‾</mo></munder><mtext mathvariant="sans-serif">wtwt</mtext></mrow><mo>→</mo><mrow><mtext mathvariant="sans-serif">wt</mtext><munder accentunder="true"><mtext mathvariant="sans-serif">waaaa</mtext><mo stretchy="true">‾</mo></munder><mtext mathvariant="sans-serif">wtw</mtext></mrow><mo>→</mo><mtext mathvariant="sans-serif">aaaaw</mtext></mrow><annotation encoding="application/x-tex">\textsf{twtwa}\rightarrow  \textsf{t\underline{wtwaa}wtwt}\rightarrow \textsf{wt\underline{waaaa}wtw} \rightarrow \textsf{aaaaw}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.57143em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">twtwa</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7714300000000001em;vertical-align:-0.2em;"></span><span class="mord text"><span class="mord textsf">t</span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.57143em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textsf">w</span><span class="mord textsf">t</span><span class="mord textsf">w</span><span class="mord textsf">a</span><span class="mord textsf">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span><span class="mord textsf">wtwt</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77143em;vertical-align:-0.19999999999999996em;"></span><span class="mord text"><span class="mord textsf">wt</span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.44444000000000006em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textsf">w</span><span class="mord textsf">a</span><span class="mord textsf">a</span><span class="mord textsf">a</span><span class="mord textsf">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19999999999999996em;"><span></span></span></span></span></span><span class="mord textsf">wtw</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">aaaaw</span></span></span></span></span></p>
<p>虽然最后结果中前面的 <code>a</code> 的数量增加了，但最后一直是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="sans-serif">wtwt</mtext></mrow><annotation encoding="application/x-tex">\textsf{wtwt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.57143em;vertical-align:0em;"></span><span class="mord text"><span class="mord textsf">wtwt</span></span></span></span></span> 后面减少掉了一些，所以若开始时最小的字母组成的一块 <strong>前面一段倒过来</strong> 的字典序是最小的，变换后肯定也是最小的。</p>
<p>所以我们就有了以下做法：</p>
<ol>
<li>使用一步将最小的字母组成的最长的块（相同的取前面一段倒过来字典序最小的）移到最后。</li>
<li>按题目要求进行变换，同时保证最小的字母组成的一块在最后。</li>
<li>使用最后一步将最小的字母组成的移动到字符串最前面。</li>
</ol>
<p>需要注意的是，开始时取的前面一段字典序最小是要在复制后的意义下复制出来的部分前面一段字典序最小，因为那才是我们实际上取的，由于复制意义下才是我们真正取的，所以还要判断最后的几个字符复制以后成为最长的最小字母组成的一块的情况（因为这个调了很久）。</p>
<p>在第二步模拟时如果最小字母组成的那块长度已经大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, 就不用继续了。这条性质保证了时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的。（但第一步处理需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的时候要进行特判，因为没有机会让我们执行前两步了。</p>
<p>代码</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
int n, k;
std::string s;
int main() {
	std::cin &gt;&gt; n &gt;&gt; k;
	std::cin &gt;&gt; s;
	char min = 'z';
	for(int i = 0; i &lt; n; i++) min = std::min(min, s[i]);
	int maxj = 0, maxs = 0;
	std::string minpre;
	for(int i = 0; i &lt; n; i++) minpre += 'z'+1;
	for(int i = n-1; i &gt;= 0; i--) 
		if(s[i] == min) {
			int cnt = 0, j = i;
			for( ; j &gt;= 0 &amp;&amp; s[j] == min; cnt++, j--) ;
			std::string tmp1 = s.substr(j+1, n-1-j-1+1);
			std::string tmp2 = s.substr(n-j-1, n-n+j+1+1);
			std::reverse(tmp2.begin(), tmp2.end());
			std::string twt = tmp1 + tmp2;
			if(cnt &gt; maxs || cnt == maxs &amp;&amp; twt &lt; minpre) 
				maxs = cnt, maxj = j, minpre = twt;
		}	
	int j = n-1, cnt = 0;
	for( ; j &gt;= 0 &amp;&amp; s[j] == min; j--, cnt++) ;
	std::string tm = s.substr(n-j-1, j+1) + s.substr(j+1, n-j-1);
	std::reverse(tm.begin(), tm.end());
	if(cnt*2 &gt; maxs || cnt*2 == maxs &amp;&amp; tm &lt; minpre) maxs = cnt, maxj = j, minpre = tm;
	maxj ++;
	std::string t;
	t = s;
	std::reverse(t.begin(), t.end());
	s = s + t;
	if(k == 1) {
		s = s.substr(maxj, n);
		std::cout &lt;&lt; s;
		return 0;
	}
	if(maxj + maxs != n) {
		s = s.substr(n-maxj, n);
		k -= 1;
	}
	for(int i = 1; i &lt; k; i++) {
		t = s;
		std::reverse(t.begin(), t.end());
		s = s + t;
		s = s.substr(maxs, n);
		maxs &lt;&lt;= 1;
		if(maxs &gt;= n) break; 
	}
	if(maxs &gt; n) maxs = n;
	t = s;
	std::reverse(t.begin(), t.end());
	s = s + t;
	s = s.substr(n-maxs, n);
	std::cout &lt;&lt; s;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [AGC017E] Jigsaw]]></title>
        <id>https://acfboy.pw/agc017e/</id>
        <link href="https://acfboy.pw/agc017e/">
        </link>
        <updated>2021-04-15T06:25:24.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT2668">题目翻译传送门</a></p>
<p>这题其实十分的妙，尽管代码很短，但确实对得起它紫题的难度。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT2668">题目翻译传送门</a></p>
<p>这题其实十分的妙，尽管代码很短，但确实对得起它紫题的难度。</p>
<!-- more -->
<p>看到这样的一道题，首先一个很自然的想法就是按照能拼上的关系建图，然后通过一个神奇的方式找到一条路径。</p>
<p>但这样一来光建图就需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的时间，没有办法满足题目的需要。然后发现虽然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 很大，但是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 是很小的，那么下一个想法是，能不能使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 进行建图。</p>
<p>然后就有一个很妙的转换方式，其它题解里讲了一些转换为负的方法，很妙，其实不用这样，还得去处理负下标的问题，只需要确保两种会被映射到不相交的区间里就可以了，所以这样转化就可以了：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">r = d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>, 否则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">r = b+h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>。</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>c</mi><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">l = c+h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 否则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">l = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。</li>
</ul>
<p>经过这样的转换，右边的若和左边可以相接，它们就会变成一个一样的值，然后就可以用一条边来表示一块积木，这样边数和点数都在一个可接受的范围内。</p>
<p>然后就是要到若干条路径从小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点到大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点并经过所有边的问题了，找到经过每一条边的路径那么直接就可以想到欧拉回路，但这题目中不要求回到原点，也不一定是全部连通的（对应原来的积木中不一定全部是以凹凸的方式拼接的），所以又有了一个很巧妙的构造方式。</p>
<p>建立一个新的点，对于要构造的每一段路径将这个新点和它起点相连，在把终点与新点相连，然后找到一条欧拉回路，在把这新脸上的边和点给去掉就可以了。</p>
<p>所以可以根据欧拉回路要求满足的条件来判断是否能构造成功。有向图有欧拉回路的条件是每个点入度等于出度。</p>
<ol>
<li>对于小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点， 入度要小于等于出度，因为构造的时候还要和新点连边， 但不一定是最多只能小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 因为我们要找出若干条路径而不一定只有一条。</li>
<li>对于大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 的点同理。</li>
<li>每一块至少得有一个点入度出度不相等，因为全相等了再和新点连边就没有欧拉回路了。</li>
</ol>
<p>满足以上条件的就可以按上面数的构造出来，不满足的就肯定 <code>No</code> 了。</p>
<p>代码。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
const int H = 405;
int n, h, fa[H], a, b, c, d, l, r, in[H], out[H], ok[H];
int find(int x) {
	if(x != fa[x]) fa[x] = find(fa[x]);
	return fa[x];
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;h);
	for(int i = 1; i &lt;= 2*h; i++) fa[i] = i;
	for(int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
		if(d) r = d; else r = b+h;
		if(c) l = c+h; else l = a;
		out[l] ++, in[r] ++;
		int fx = find(l), fy = find(r);
		if(fx == fy) continue;
		fa[fx] = fy;
	}
	for(int i = 1; i &lt;= h; i++) if(in[i] &gt; out[i]) return puts(&quot;NO&quot;), 0;
	for(int i = h+1; i &lt;= 2*h; i++) if(in[i] &lt; out[i]) return puts(&quot;NO&quot;), 0;
	for(int i = 1; i &lt;= 2*h; i++) if(in[i] != out[i] || !in[i] &amp;&amp; !out[i]) ok[find(i)] = 1;
	for(int i = 1; i &lt;= 2*h; i++) if(fa[i] == i &amp;&amp; !ok[i]) return puts(&quot;NO&quot;), 0;
	puts(&quot;YES&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>